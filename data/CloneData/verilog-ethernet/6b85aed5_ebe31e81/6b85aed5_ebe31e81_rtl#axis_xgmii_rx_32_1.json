{"Source Block": ["verilog-ethernet/rtl/axis_xgmii_rx_32.v@244:369@HdlStmProcess", "        tkeep_mask = 4'b1111;\n    end\n    endcase\nend\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    reset_crc = 1'b0;\n    update_crc = 1'b0;\n\n    last_cycle_tkeep_next = last_cycle_tkeep_reg;\n\n    m_axis_tdata_next = 32'd0;\n    m_axis_tkeep_next = 4'd0;\n    m_axis_tvalid_next = 1'b0;\n    m_axis_tlast_next = 1'b0;\n    m_axis_tuser_next = 1'b0;\n\n    error_bad_frame_next = 1'b0;\n    error_bad_fcs_next = 1'b0;\n\n    case (state_reg)\n        STATE_IDLE: begin\n            // idle state - wait for packet\n            reset_crc = 1'b1;\n\n            if (xgmii_rxc_d2[0] && xgmii_rxd_d2[7:0] == XGMII_START) begin\n                // start condition\n                if (detect_error_masked) begin\n                    // error in first data word\n                    m_axis_tdata_next = 32'd0;\n                    m_axis_tkeep_next = 4'h1;\n                    m_axis_tvalid_next = 1'b1;\n                    m_axis_tlast_next = 1'b1;\n                    m_axis_tuser_next = 1'b1;\n                    error_bad_frame_next = 1'b1;\n                    state_next = STATE_IDLE;\n                end else begin\n                    reset_crc = 1'b0;\n                    update_crc = 1'b1;\n                    state_next = STATE_PREAMBLE;\n                end\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_PREAMBLE: begin\n            // drop preamble\n            update_crc = 1'b1;\n            state_next = STATE_PAYLOAD;\n        end\n        STATE_PAYLOAD: begin\n            // read payload\n            update_crc = 1'b1;\n\n            m_axis_tdata_next = xgmii_rxd_d2;\n            m_axis_tkeep_next = ~xgmii_rxc_d2;\n            m_axis_tvalid_next = 1'b1;\n            m_axis_tlast_next = 1'b0;\n            m_axis_tuser_next = 1'b0;\n\n            if (control_masked) begin\n                // control or error characters in packet\n                m_axis_tlast_next = 1'b1;\n                m_axis_tuser_next = 1'b1;\n                error_bad_frame_next = 1'b1;\n                reset_crc = 1'b1;\n                state_next = STATE_IDLE;\n            end else if (detect_term) begin\n                if (detect_term[0]) begin\n                    // end this cycle\n                    reset_crc = 1'b1;\n                    m_axis_tkeep_next = 4'b1111;\n                    m_axis_tlast_next = 1'b1;\n                    if (detect_term[0] && crc_valid3_save) begin\n                        // CRC valid\n                    end else begin\n                        m_axis_tuser_next = 1'b1;\n                        error_bad_frame_next = 1'b1;\n                        error_bad_fcs_next = 1'b1;\n                    end\n                    state_next = STATE_IDLE;\n                end else begin\n                    // need extra cycle\n                    last_cycle_tkeep_next = tkeep_mask;\n                    state_next = STATE_LAST;\n                end\n            end else begin\n                state_next = STATE_PAYLOAD;\n            end\n        end\n        STATE_LAST: begin\n            // last cycle of packet\n            m_axis_tdata_next = xgmii_rxd_d2;\n            m_axis_tkeep_next = last_cycle_tkeep_reg;\n            m_axis_tvalid_next = 1'b1;\n            m_axis_tlast_next = 1'b1;\n            m_axis_tuser_next = 1'b0;\n\n            reset_crc = 1'b1;\n\n            if ((detect_term_save[1] && crc_valid0_save) ||\n                (detect_term_save[2] && crc_valid1_save) ||\n                (detect_term_save[3] && crc_valid2_save)) begin\n                // CRC valid\n            end else begin\n                m_axis_tuser_next = 1'b1;\n                error_bad_frame_next = 1'b1;\n                error_bad_fcs_next = 1'b1;\n            end\n\n            if (xgmii_rxc_d1[0] && xgmii_rxd_d1[7:0] == XGMII_START) begin\n                // start condition\n                state_next = STATE_PAYLOAD;\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state_reg <= STATE_IDLE;\n\n"], "Clone Blocks": [["verilog-ethernet/rtl/axis_xgmii_rx_64.v@281:405", "        tkeep_mask = 8'b11111111;\n    end\n    endcase\nend\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    reset_crc = 1'b0;\n    update_crc = 1'b0;\n\n    last_cycle_tkeep_next = last_cycle_tkeep_reg;\n\n    m_axis_tdata_next = 64'd0;\n    m_axis_tkeep_next = 8'd0;\n    m_axis_tvalid_next = 1'b0;\n    m_axis_tlast_next = 1'b0;\n    m_axis_tuser_next = 1'b0;\n\n    error_bad_frame_next = 1'b0;\n    error_bad_fcs_next = 1'b0;\n\n    case (state_reg)\n        STATE_IDLE: begin\n            // idle state - wait for packet\n            reset_crc = 1'b1;\n\n            if (xgmii_rxc_d1[0] && xgmii_rxd_d1[7:0] == XGMII_START) begin\n                // start condition\n                if (detect_error_masked) begin\n                    // error in first data word\n                    m_axis_tdata_next = 64'd0;\n                    m_axis_tkeep_next = 8'h01;\n                    m_axis_tvalid_next = 1'b1;\n                    m_axis_tlast_next = 1'b1;\n                    m_axis_tuser_next = 1'b1;\n                    error_bad_frame_next = 1'b1;\n                    state_next = STATE_IDLE;\n                end else begin\n                    reset_crc = 1'b0;\n                    update_crc = 1'b1;\n                    state_next = STATE_PAYLOAD;\n                end\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_PAYLOAD: begin\n            // read payload\n            update_crc = 1'b1;\n\n            m_axis_tdata_next = xgmii_rxd_d1;\n            m_axis_tkeep_next = ~xgmii_rxc_d1;\n            m_axis_tvalid_next = 1'b1;\n            m_axis_tlast_next = 1'b0;\n            m_axis_tuser_next = 1'b0;\n\n            if (control_masked) begin\n                // control or error characters in packet\n                m_axis_tlast_next = 1'b1;\n                m_axis_tuser_next = 1'b1;\n                error_bad_frame_next = 1'b1;\n                reset_crc = 1'b1;\n                state_next = STATE_IDLE;\n            end else if (detect_term) begin\n                if (detect_term[4:0]) begin\n                    // end this cycle\n                    reset_crc = 1'b1;\n                    m_axis_tkeep_next = {tkeep_mask[3:0], 4'b1111};\n                    m_axis_tlast_next = 1'b1;\n                    if ((detect_term[0] && crc_valid7_save) ||\n                        (detect_term[1] && crc_valid0) ||\n                        (detect_term[2] && crc_valid1) ||\n                        (detect_term[3] && crc_valid2) ||\n                        (detect_term[4] && crc_valid3)) begin\n                        // CRC valid\n                    end else begin\n                        m_axis_tuser_next = 1'b1;\n                        error_bad_frame_next = 1'b1;\n                        error_bad_fcs_next = 1'b1;\n                    end\n                    state_next = STATE_IDLE;\n                end else begin\n                    // need extra cycle\n                    last_cycle_tkeep_next = {4'b0000, tkeep_mask[7:4]};\n                    state_next = STATE_LAST;\n                end\n            end else begin\n                state_next = STATE_PAYLOAD;\n            end\n        end\n        STATE_LAST: begin\n            // last cycle of packet\n            m_axis_tdata_next = xgmii_rxd_d1;\n            m_axis_tkeep_next = last_cycle_tkeep_reg;\n            m_axis_tvalid_next = 1'b1;\n            m_axis_tlast_next = 1'b1;\n            m_axis_tuser_next = 1'b0;\n\n            reset_crc = 1'b1;\n\n            if ((detect_term_save[5] && crc_valid0) ||\n                (detect_term_save[6] && crc_valid1) ||\n                (detect_term_save[7] && crc_valid2)) begin\n                // CRC valid\n            end else begin\n                m_axis_tuser_next = 1'b1;\n                error_bad_frame_next = 1'b1;\n                error_bad_fcs_next = 1'b1;\n            end\n\n            if (xgmii_rxc_d1[0] && xgmii_rxd_d1[7:0] == XGMII_START) begin\n                // start condition\n                state_next = STATE_PAYLOAD;\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state_reg <= STATE_IDLE;\n\n"]], "Diff Content": {"Delete": [[273, "                if (detect_error_masked) begin\n"]], "Add": [[273, "                if (control_masked) begin\n"]]}}