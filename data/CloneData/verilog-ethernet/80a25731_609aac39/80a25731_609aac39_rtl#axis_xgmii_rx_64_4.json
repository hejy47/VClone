{"Source Block": ["verilog-ethernet/rtl/axis_xgmii_rx_64.v@294:429@HdlStmProcess", "        tkeep_mask = 8'b11111111;\n    end\n    endcase\nend\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    reset_crc = 1'b0;\n    update_crc_last = 1'b0;\n\n    last_cycle_tkeep_next = last_cycle_tkeep_reg;\n\n    m_axis_tdata_next = {DATA_WIDTH{1'b0}};\n    m_axis_tkeep_next = {KEEP_WIDTH{1'b1}};\n    m_axis_tvalid_next = 1'b0;\n    m_axis_tlast_next = 1'b0;\n    m_axis_tuser_next = 1'b0;\n\n    error_bad_frame_next = 1'b0;\n    error_bad_fcs_next = 1'b0;\n\n    case (state_reg)\n        STATE_IDLE: begin\n            // idle state - wait for packet\n            reset_crc = 1'b1;\n\n            if (xgmii_rxc_d1[0] && xgmii_rxd_d1[7:0] == XGMII_START) begin\n                // start condition\n                if (control_masked) begin\n                    // control or error characters in first data word\n                    m_axis_tdata_next = {DATA_WIDTH{1'b0}};\n                    m_axis_tkeep_next = 8'h01;\n                    m_axis_tvalid_next = 1'b1;\n                    m_axis_tlast_next = 1'b1;\n                    m_axis_tuser_next = 1'b1;\n                    error_bad_frame_next = 1'b1;\n                    state_next = STATE_IDLE;\n                end else begin\n                    reset_crc = 1'b0;\n                    state_next = STATE_PAYLOAD;\n                end\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_PAYLOAD: begin\n            // read payload\n            m_axis_tdata_next = xgmii_rxd_d1;\n            m_axis_tkeep_next = {KEEP_WIDTH{1'b1}};\n            m_axis_tvalid_next = 1'b1;\n            m_axis_tlast_next = 1'b0;\n            m_axis_tuser_next = 1'b0;\n\n            last_cycle_tkeep_next = {4'b0000, tkeep_mask[7:4]};\n\n            if (control_masked) begin\n                // control or error characters in packet\n                m_axis_tlast_next = 1'b1;\n                m_axis_tuser_next = 1'b1;\n                error_bad_frame_next = 1'b1;\n                reset_crc = 1'b1;\n                state_next = STATE_IDLE;\n            end else if (detect_term) begin\n                if (detect_term[4:0]) begin\n                    // end this cycle\n                    reset_crc = 1'b1;\n                    m_axis_tkeep_next = {tkeep_mask[3:0], 4'b1111};\n                    m_axis_tlast_next = 1'b1;\n                    if ((detect_term[0] && crc_valid7_save) ||\n                        (detect_term[1] && crc_valid0) ||\n                        (detect_term[2] && crc_valid1) ||\n                        (detect_term[3] && crc_valid2) ||\n                        (detect_term[4] && crc_valid3)) begin\n                        // CRC valid\n                    end else begin\n                        m_axis_tuser_next = 1'b1;\n                        error_bad_frame_next = 1'b1;\n                        error_bad_fcs_next = 1'b1;\n                    end\n                    state_next = STATE_IDLE;\n                end else begin\n                    // need extra cycle\n                    update_crc_last = 1'b1;\n                    state_next = STATE_LAST;\n                end\n            end else begin\n                state_next = STATE_PAYLOAD;\n            end\n        end\n        STATE_LAST: begin\n            // last cycle of packet\n            m_axis_tdata_next = xgmii_rxd_d1;\n            m_axis_tkeep_next = last_cycle_tkeep_reg;\n            m_axis_tvalid_next = 1'b1;\n            m_axis_tlast_next = 1'b1;\n            m_axis_tuser_next = 1'b0;\n\n            reset_crc = 1'b1;\n\n            if ((detect_term_save[5] && crc_valid0) ||\n                (detect_term_save[6] && crc_valid1) ||\n                (detect_term_save[7] && crc_valid2)) begin\n                // CRC valid\n            end else begin\n                m_axis_tuser_next = 1'b1;\n                error_bad_frame_next = 1'b1;\n                error_bad_fcs_next = 1'b1;\n            end\n\n            if (xgmii_rxc_d1[0] && xgmii_rxd_d1[7:0] == XGMII_START) begin\n                // start condition\n                if (control_masked) begin\n                    // control or error characters in first data word\n                    m_axis_tdata_next = {DATA_WIDTH{1'b0}};\n                    m_axis_tkeep_next = 8'h01;\n                    m_axis_tvalid_next = 1'b1;\n                    m_axis_tlast_next = 1'b1;\n                    m_axis_tuser_next = 1'b1;\n                    error_bad_frame_next = 1'b1;\n                    state_next = STATE_IDLE;\n                end else begin\n                    reset_crc = 1'b0;\n                    state_next = STATE_PAYLOAD;\n                end\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    state_reg <= state_next;\n\n    m_axis_tdata_reg <= m_axis_tdata_next;\n"], "Clone Blocks": [["verilog-ethernet/rtl/axis_xgmii_rx_32.v@259:380", "        tkeep_mask = 4'b1111;\n    end\n    endcase\nend\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    reset_crc = 1'b0;\n\n    last_cycle_tkeep_next = last_cycle_tkeep_reg;\n\n    m_axis_tdata_next = {DATA_WIDTH{1'b0}};\n    m_axis_tkeep_next = {KEEP_WIDTH{1'b1}};\n    m_axis_tvalid_next = 1'b0;\n    m_axis_tlast_next = 1'b0;\n    m_axis_tuser_next = 1'b0;\n\n    start_packet_next = 1'b0;\n    error_bad_frame_next = 1'b0;\n    error_bad_fcs_next = 1'b0;\n\n    ptp_ts_next = ptp_ts_reg;\n\n    case (state_reg)\n        STATE_IDLE: begin\n            // idle state - wait for packet\n            reset_crc = 1'b1;\n\n            if (xgmii_rxc_d2[0] && xgmii_rxd_d2[7:0] == XGMII_START) begin\n                // start condition\n                if (control_masked) begin\n                    // control or error characters in first data word\n                    m_axis_tdata_next = {DATA_WIDTH{1'b0}};\n                    m_axis_tkeep_next = 4'h1;\n                    m_axis_tvalid_next = 1'b1;\n                    m_axis_tlast_next = 1'b1;\n                    m_axis_tuser_next = 1'b1;\n                    error_bad_frame_next = 1'b1;\n                    state_next = STATE_IDLE;\n                end else begin\n                    reset_crc = 1'b0;\n                    state_next = STATE_PREAMBLE;\n                end\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_PREAMBLE: begin\n            // drop preamble\n            ptp_ts_next = ptp_ts;\n            start_packet_next = 1'b1;\n            state_next = STATE_PAYLOAD;\n        end\n        STATE_PAYLOAD: begin\n            // read payload\n            m_axis_tdata_next = xgmii_rxd_d2;\n            m_axis_tkeep_next = {KEEP_WIDTH{1'b1}};\n            m_axis_tvalid_next = 1'b1;\n            m_axis_tlast_next = 1'b0;\n            m_axis_tuser_next = 1'b0;\n\n            last_cycle_tkeep_next = tkeep_mask;\n\n            if (control_masked) begin\n                // control or error characters in packet\n                m_axis_tlast_next = 1'b1;\n                m_axis_tuser_next = 1'b1;\n                error_bad_frame_next = 1'b1;\n                reset_crc = 1'b1;\n                state_next = STATE_IDLE;\n            end else if (detect_term) begin\n                if (detect_term[0]) begin\n                    // end this cycle\n                    reset_crc = 1'b1;\n                    m_axis_tkeep_next = 4'b1111;\n                    m_axis_tlast_next = 1'b1;\n                    if (detect_term[0] && crc_valid3_save) begin\n                        // CRC valid\n                    end else begin\n                        m_axis_tuser_next = 1'b1;\n                        error_bad_frame_next = 1'b1;\n                        error_bad_fcs_next = 1'b1;\n                    end\n                    state_next = STATE_IDLE;\n                end else begin\n                    // need extra cycle\n                    state_next = STATE_LAST;\n                end\n            end else begin\n                state_next = STATE_PAYLOAD;\n            end\n        end\n        STATE_LAST: begin\n            // last cycle of packet\n            m_axis_tdata_next = xgmii_rxd_d2;\n            m_axis_tkeep_next = last_cycle_tkeep_reg;\n            m_axis_tvalid_next = 1'b1;\n            m_axis_tlast_next = 1'b1;\n            m_axis_tuser_next = 1'b0;\n\n            reset_crc = 1'b1;\n\n            if ((detect_term_save[1] && crc_valid0_save) ||\n                (detect_term_save[2] && crc_valid1_save) ||\n                (detect_term_save[3] && crc_valid2_save)) begin\n                // CRC valid\n            end else begin\n                m_axis_tuser_next = 1'b1;\n                error_bad_frame_next = 1'b1;\n                error_bad_fcs_next = 1'b1;\n            end\n\n            state_next = STATE_IDLE;\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    state_reg <= state_next;\n\n    m_axis_tdata_reg <= m_axis_tdata_next;\n"]], "Diff Content": {"Delete": [[311, "    m_axis_tuser_next = 1'b0;\n"], [329, "                    m_axis_tuser_next = 1'b1;\n"], [346, "            m_axis_tuser_next = 1'b0;\n"], [353, "                m_axis_tuser_next = 1'b1;\n"], [370, "                        m_axis_tuser_next = 1'b1;\n"], [390, "            m_axis_tuser_next = 1'b0;\n"], [399, "                m_axis_tuser_next = 1'b1;\n"], [412, "                    m_axis_tuser_next = 1'b1;\n"]], "Add": [[311, "    m_axis_tuser_next = m_axis_tuser_reg;\n"], [311, "    m_axis_tuser_next[0] = 1'b0;\n"], [321, "                if (PTP_TS_ENABLE) begin\n"], [321, "                    m_axis_tuser_next[1 +: PTP_TS_WIDTH] = ptp_ts_reg;\n"], [321, "                end\n"], [329, "                    m_axis_tuser_next[0] = 1'b1;\n"], [346, "            m_axis_tuser_next[0] = 1'b0;\n"], [353, "                m_axis_tuser_next[0] = 1'b1;\n"], [370, "                        m_axis_tuser_next[0] = 1'b1;\n"], [390, "            m_axis_tuser_next[0] = 1'b0;\n"], [399, "                m_axis_tuser_next[0] = 1'b1;\n"], [412, "                    m_axis_tuser_next[0] = 1'b1;\n"]]}}