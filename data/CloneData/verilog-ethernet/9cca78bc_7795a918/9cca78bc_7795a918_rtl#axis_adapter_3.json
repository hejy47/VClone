{"Source Block": ["verilog-ethernet/rtl/axis_adapter.v@118:340@HdlStmProcess", "wire                        output_axis_tready_int_early;\n\nreg input_axis_tready_reg = 0, input_axis_tready_next;\nassign input_axis_tready = input_axis_tready_reg;\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    cycle_count_next = cycle_count_reg;\n\n    temp_tdata_next = temp_tdata_reg;\n    temp_tkeep_next = temp_tkeep_reg;\n    temp_tlast_next = temp_tlast_reg;\n    temp_tuser_next = temp_tuser_reg;\n\n    output_axis_tdata_int = 0;\n    output_axis_tkeep_int = 0;\n    output_axis_tvalid_int = 0;\n    output_axis_tlast_int = 0;\n    output_axis_tuser_int = 0;\n\n    input_axis_tready_next = 0;\n\n    case (state_reg)\n        STATE_IDLE: begin\n            // idle state - no data in registers\n            if (CYCLE_COUNT == 1) begin\n                // output and input same width - just act like a register\n\n                // accept data next cycle if output register ready next cycle\n                input_axis_tready_next = output_axis_tready_int_early;\n\n                // transfer through\n                output_axis_tdata_int = input_axis_tdata;\n                output_axis_tkeep_int = input_axis_tkeep;\n                output_axis_tvalid_int = input_axis_tvalid;\n                output_axis_tlast_int = input_axis_tlast;\n                output_axis_tuser_int = input_axis_tuser;\n\n                state_next = STATE_IDLE;\n            end else if (EXPAND_BUS) begin\n                // output bus is wider\n\n                // accept new data\n                input_axis_tready_next = 1;\n\n                if (input_axis_tvalid) begin\n                    // word transfer in - store it in data register\n                    \n                    // pass complete input word, zero-extended to temp register\n                    temp_tdata_next = input_axis_tdata;\n                    temp_tkeep_next = input_axis_tkeep;\n                    temp_tlast_next = input_axis_tlast;\n                    temp_tuser_next = input_axis_tuser;\n\n                    // first input cycle complete\n                    cycle_count_next = 1;\n\n                    if (input_axis_tlast) begin\n                        // got last signal on first cycle, so output it\n                        input_axis_tready_next = 0;\n                        state_next = STATE_TRANSFER_OUT;\n                    end else begin\n                        // otherwise, transfer in the rest of the words\n                        input_axis_tready_next = 1;\n                        state_next = STATE_TRANSFER_IN;\n                    end\n                end else begin\n                    state_next = STATE_IDLE;\n                end\n            end else begin\n                // output bus is narrower\n\n                // accept new data\n                input_axis_tready_next = 1;\n\n                if (input_axis_tvalid) begin\n                    // word transfer in - store it in data register\n                    cycle_count_next = 0;\n\n                    // pass complete input word, zero-extended to temp register\n                    temp_tdata_next = input_axis_tdata;\n                    temp_tkeep_next = input_axis_tkeep;\n                    temp_tlast_next = input_axis_tlast;\n                    temp_tuser_next = input_axis_tuser;\n\n                    // short-circuit and get first word out the door\n                    output_axis_tdata_int = input_axis_tdata;\n                    output_axis_tkeep_int = input_axis_tkeep;\n                    output_axis_tvalid_int = 1;\n                    output_axis_tlast_int = input_axis_tlast & ((CYCLE_COUNT == 1) | (input_axis_tkeep[CYCLE_KEEP_WIDTH-1:0] != {CYCLE_KEEP_WIDTH{1'b1}}));\n                    output_axis_tuser_int = input_axis_tuser & ((CYCLE_COUNT == 1) | (input_axis_tkeep[CYCLE_KEEP_WIDTH-1:0] != {CYCLE_KEEP_WIDTH{1'b1}}));\n\n                    if (output_axis_tready_int) begin\n                        // if output register is ready for first word, then move on to the next one\n                        cycle_count_next = 1;\n                    end\n\n                    // continue outputting words\n                    input_axis_tready_next = 0;\n                    state_next = STATE_TRANSFER_OUT;\n                end else begin\n                    state_next = STATE_IDLE;\n                end\n            end\n        end\n        STATE_TRANSFER_IN: begin\n            // transfer word to temp registers\n            // only used when output is wider\n\n            // accept new data\n            input_axis_tready_next = 1;\n\n            if (input_axis_tvalid) begin\n                // word transfer in - store in data register\n                \n                temp_tdata_next[cycle_count_reg*CYCLE_DATA_WIDTH +: CYCLE_DATA_WIDTH] = input_axis_tdata;\n                temp_tkeep_next[cycle_count_reg*CYCLE_KEEP_WIDTH +: CYCLE_KEEP_WIDTH] = input_axis_tkeep;\n                temp_tlast_next = input_axis_tlast;\n                temp_tuser_next = input_axis_tuser;\n\n                cycle_count_next = cycle_count_reg + 1;\n                \n                if ((cycle_count_reg == CYCLE_COUNT-1) | input_axis_tlast) begin\n                    // terminated by counter or tlast signal, output complete word\n                    // read input word next cycle if output will be ready\n                    input_axis_tready_next = output_axis_tready_int_early;\n                    state_next = STATE_TRANSFER_OUT;\n                end else begin\n                    // more words to read\n                    input_axis_tready_next = 1;\n                    state_next = STATE_TRANSFER_IN;\n                end\n            end else begin\n                state_next = STATE_TRANSFER_IN;\n            end\n        end\n        STATE_TRANSFER_OUT: begin\n            // transfer word to output registers\n\n            if (EXPAND_BUS) begin\n                // output bus is wider\n                \n                // do not accept new data\n                input_axis_tready_next = 0;\n\n                // single-cycle output of entire stored word (output wider)\n                output_axis_tdata_int = temp_tdata_reg;\n                output_axis_tkeep_int = temp_tkeep_reg;\n                output_axis_tvalid_int = 1;\n                output_axis_tlast_int = temp_tlast_reg;\n                output_axis_tuser_int = temp_tuser_reg;\n            \n                if (output_axis_tready_int) begin\n                    // word transfer out\n\n                    if (input_axis_tready & input_axis_tvalid) begin\n                        // word transfer in\n\n                        // pass complete input word, zero-extended to temp register\n                        temp_tdata_next = input_axis_tdata;\n                        temp_tkeep_next = input_axis_tkeep;\n                        temp_tlast_next = input_axis_tlast;\n                        temp_tuser_next = input_axis_tuser;\n\n                        // first input cycle complete\n                        cycle_count_next = 1;\n\n                        if (input_axis_tlast) begin\n                            // got last signal on first cycle, so output it\n                            input_axis_tready_next = 0;\n                            state_next = STATE_TRANSFER_OUT;\n                        end else begin\n                            // otherwise, transfer in the rest of the words\n                            input_axis_tready_next = 1;\n                            state_next = STATE_TRANSFER_IN;\n                        end\n                    end else begin\n                        input_axis_tready_next = 1;\n                        state_next = STATE_IDLE;\n                    end\n                end else begin\n                    state_next = STATE_TRANSFER_OUT;\n                end\n            end else begin\n                // output bus is narrower\n\n                // do not accept new data\n                input_axis_tready_next = 0;\n\n                // output current part of stored word (output narrower)\n                output_axis_tdata_int = temp_tdata_reg[cycle_count_reg*CYCLE_DATA_WIDTH +: CYCLE_DATA_WIDTH];\n                output_axis_tkeep_int = temp_tkeep_reg[cycle_count_reg*CYCLE_KEEP_WIDTH +: CYCLE_KEEP_WIDTH];\n                output_axis_tvalid_int = 1;\n                output_axis_tlast_int = temp_tlast_reg & ((cycle_count_reg == CYCLE_COUNT-1) | (temp_tkeep_reg[cycle_count_reg*CYCLE_KEEP_WIDTH +: CYCLE_KEEP_WIDTH] != {CYCLE_KEEP_WIDTH{1'b1}}));\n                output_axis_tuser_int = temp_tuser_reg & ((cycle_count_reg == CYCLE_COUNT-1) | (temp_tkeep_reg[cycle_count_reg*CYCLE_KEEP_WIDTH +: CYCLE_KEEP_WIDTH] != {CYCLE_KEEP_WIDTH{1'b1}}));\n\n                if (output_axis_tready_int) begin\n                    // word transfer out\n\n                    cycle_count_next = cycle_count_reg + 1;\n\n                    if ((cycle_count_reg == CYCLE_COUNT-1) | (temp_tkeep_reg[cycle_count_reg*CYCLE_KEEP_WIDTH +: CYCLE_KEEP_WIDTH] != {CYCLE_KEEP_WIDTH{1'b1}})) begin\n                        // terminated by counter or tlast signal\n                        \n                        input_axis_tready_next = 1;\n                        state_next = STATE_IDLE;\n                    end else begin\n                        // more words to write\n                        state_next = STATE_TRANSFER_OUT;\n                    end\n                end else begin\n                    state_next = STATE_TRANSFER_OUT;\n                end \n            end\n        end\n    endcase\nend\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state_reg <= STATE_IDLE;\n        cycle_count_reg <= 0;\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[164, "                if (input_axis_tvalid) begin\n"], [194, "                if (input_axis_tvalid) begin\n"], [205, "                    output_axis_tdata_int = input_axis_tdata;\n"], [206, "                    output_axis_tkeep_int = input_axis_tkeep;\n"], [208, "                    output_axis_tlast_int = input_axis_tlast & ((CYCLE_COUNT == 1) | (input_axis_tkeep[CYCLE_KEEP_WIDTH-1:0] != {CYCLE_KEEP_WIDTH{1'b1}}));\n"], [209, "                    output_axis_tuser_int = input_axis_tuser & ((CYCLE_COUNT == 1) | (input_axis_tkeep[CYCLE_KEEP_WIDTH-1:0] != {CYCLE_KEEP_WIDTH{1'b1}}));\n"], [217, "                    input_axis_tready_next = 0;\n"], [218, "                    state_next = STATE_TRANSFER_OUT;\n"], [231, "            if (input_axis_tvalid) begin\n"], [312, "                output_axis_tlast_int = temp_tlast_reg & ((cycle_count_reg == CYCLE_COUNT-1) | (temp_tkeep_reg[cycle_count_reg*CYCLE_KEEP_WIDTH +: CYCLE_KEEP_WIDTH] != {CYCLE_KEEP_WIDTH{1'b1}}));\n"], [313, "                output_axis_tuser_int = temp_tuser_reg & ((cycle_count_reg == CYCLE_COUNT-1) | (temp_tkeep_reg[cycle_count_reg*CYCLE_KEEP_WIDTH +: CYCLE_KEEP_WIDTH] != {CYCLE_KEEP_WIDTH{1'b1}}));\n"], [320, "                    if ((cycle_count_reg == CYCLE_COUNT-1) | (temp_tkeep_reg[cycle_count_reg*CYCLE_KEEP_WIDTH +: CYCLE_KEEP_WIDTH] != {CYCLE_KEEP_WIDTH{1'b1}})) begin\n"]], "Add": [[164, "                if (input_axis_tready & input_axis_tvalid) begin\n"], [194, "                if (input_axis_tready & input_axis_tvalid) begin\n"], [196, "                    if (CYCLE_COUNT == 1) begin\n"], [196, "                        last_cycle = 1;\n"], [196, "                    end else if (input_axis_tkeep[CYCLE_KEEP_WIDTH-1:0] != {CYCLE_KEEP_WIDTH{1'b1}}) begin\n"], [196, "                        last_cycle = 1;\n"], [196, "                    end else if (input_axis_tkeep[(CYCLE_KEEP_WIDTH*2)-1:CYCLE_KEEP_WIDTH] == {CYCLE_KEEP_WIDTH{1'b0}}) begin\n"], [196, "                        last_cycle = 1;\n"], [196, "                    end else begin\n"], [196, "                        last_cycle = 0;\n"], [196, "                    end\n"], [206, "                    output_axis_tdata_int = input_axis_tdata[CYCLE_DATA_WIDTH-1:0];\n"], [206, "                    output_axis_tkeep_int = input_axis_tkeep[CYCLE_KEEP_WIDTH-1:0];\n"], [209, "                    output_axis_tlast_int = input_axis_tlast & last_cycle;\n"], [209, "                    output_axis_tuser_int = input_axis_tuser & last_cycle;\n"], [218, "                    if (!last_cycle || !output_axis_tready_int) begin\n"], [218, "                        input_axis_tready_next = 0;\n"], [218, "                        state_next = STATE_TRANSFER_OUT;\n"], [218, "                    end else begin\n"], [218, "                        state_next = STATE_IDLE;\n"], [218, "                    end\n"], [231, "            if (input_axis_tready & input_axis_tvalid) begin\n"], [306, "                if (cycle_count_reg == CYCLE_COUNT-1) begin\n"], [306, "                    last_cycle = 1;\n"], [306, "                end else if (temp_tkeep_reg[cycle_count_reg*CYCLE_KEEP_WIDTH +: CYCLE_KEEP_WIDTH] != {CYCLE_KEEP_WIDTH{1'b1}}) begin\n"], [306, "                    last_cycle = 1;\n"], [306, "                end else if (temp_tkeep_reg[(cycle_count_reg+1)*CYCLE_KEEP_WIDTH +: CYCLE_KEEP_WIDTH] == {CYCLE_KEEP_WIDTH{1'b0}}) begin\n"], [306, "                    last_cycle = 1;\n"], [306, "                end else begin\n"], [306, "                    last_cycle = 0;\n"], [306, "                end\n"], [313, "                output_axis_tlast_int = temp_tlast_reg & last_cycle;\n"], [313, "                output_axis_tuser_int = temp_tuser_reg & last_cycle;\n"], [320, "                    if (last_cycle) begin\n"]]}}