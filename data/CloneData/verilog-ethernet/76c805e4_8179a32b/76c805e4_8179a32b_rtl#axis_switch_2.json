{"Source Block": ["verilog-ethernet/rtl/axis_switch.v@263:350@HdlStmFor", "            .m_axis_tdest(int_s_axis_tdest[m*DEST_WIDTH +: DEST_WIDTH]),\n            .m_axis_tuser(int_s_axis_tuser[m*USER_WIDTH +: USER_WIDTH])\n        );\n    end // s_ifaces\n\n    for (n = 0; n < M_COUNT; n = n + 1) begin : m_ifaces\n\n        // arbitration\n        wire [S_COUNT-1:0] request;\n        wire [S_COUNT-1:0] acknowledge;\n        wire [S_COUNT-1:0] grant;\n        wire grant_valid;\n        wire [CL_S_COUNT-1:0] grant_encoded;\n\n        arbiter #(\n            .PORTS(S_COUNT),\n            .TYPE(ARB_TYPE),\n            .BLOCK(\"ACKNOWLEDGE\"),\n            .LSB_PRIORITY(LSB_PRIORITY)\n        )\n        arb_inst (\n            .clk(clk),\n            .rst(rst),\n            .request(request),\n            .acknowledge(acknowledge),\n            .grant(grant),\n            .grant_valid(grant_valid),\n            .grant_encoded(grant_encoded)\n        );\n\n        // mux\n        wire [DATA_WIDTH-1:0] s_axis_tdata_mux   = int_s_axis_tdata[grant_encoded*DATA_WIDTH +: DATA_WIDTH];\n        wire [KEEP_WIDTH-1:0] s_axis_tkeep_mux   = int_s_axis_tkeep[grant_encoded*KEEP_WIDTH +: KEEP_WIDTH];\n        wire                  s_axis_tvalid_mux  = int_axis_tvalid[grant_encoded*S_COUNT+n] && grant_valid;\n        wire                  s_axis_tready_mux;\n        wire                  s_axis_tlast_mux   = int_s_axis_tlast[grant_encoded];\n        wire [ID_WIDTH-1:0]   s_axis_tid_mux     = int_s_axis_tid[grant_encoded*ID_WIDTH +: ID_WIDTH];\n        wire [DEST_WIDTH-1:0] s_axis_tdest_mux   = int_s_axis_tdest[grant_encoded*DEST_WIDTH +: DEST_WIDTH];\n        wire [USER_WIDTH-1:0] s_axis_tuser_mux   = int_s_axis_tuser[grant_encoded*USER_WIDTH +: USER_WIDTH];\n\n        assign int_axis_tready[n*S_COUNT +: S_COUNT] = (grant_valid && s_axis_tready_mux) << grant_encoded;\n\n        for (m = 0; m < S_COUNT; m = m + 1) begin\n            assign request[m] = int_axis_tvalid[m*M_COUNT+n] && !grant[m];\n            assign acknowledge[m] = grant[m] && int_axis_tvalid[m*M_COUNT+n] && s_axis_tlast_mux && s_axis_tready_mux;\n        end\n\n        // M side register\n        axis_register #(\n            .DATA_WIDTH(DATA_WIDTH),\n            .KEEP_ENABLE(KEEP_ENABLE),\n            .KEEP_WIDTH(KEEP_WIDTH),\n            .LAST_ENABLE(1),\n            .ID_ENABLE(ID_ENABLE),\n            .ID_WIDTH(ID_WIDTH),\n            .DEST_ENABLE(1),\n            .DEST_WIDTH(DEST_WIDTH),\n            .USER_ENABLE(USER_ENABLE),\n            .USER_WIDTH(USER_WIDTH),\n            .REG_TYPE(M_REG_TYPE)\n        )\n        reg_inst (\n            .clk(clk),\n            .rst(rst),\n            // AXI input\n            .s_axis_tdata(s_axis_tdata_mux),\n            .s_axis_tkeep(s_axis_tkeep_mux),\n            .s_axis_tvalid(s_axis_tvalid_mux),\n            .s_axis_tready(s_axis_tready_mux),\n            .s_axis_tlast(s_axis_tlast_mux),\n            .s_axis_tid(s_axis_tid_mux),\n            .s_axis_tdest(s_axis_tdest_mux),\n            .s_axis_tuser(s_axis_tuser_mux),\n            // AXI output\n            .m_axis_tdata(m_axis_tdata[n*DATA_WIDTH +: DATA_WIDTH]),\n            .m_axis_tkeep(m_axis_tkeep[n*KEEP_WIDTH +: KEEP_WIDTH]),\n            .m_axis_tvalid(m_axis_tvalid[n]),\n            .m_axis_tready(m_axis_tready[n]),\n            .m_axis_tlast(m_axis_tlast[n]),\n            .m_axis_tid(m_axis_tid[n*ID_WIDTH +: ID_WIDTH]),\n            .m_axis_tdest(m_axis_tdest[n*DEST_WIDTH +: DEST_WIDTH]),\n            .m_axis_tuser(m_axis_tuser[n*USER_WIDTH +: USER_WIDTH])\n        );\n    end // m_ifaces\n\nendgenerate\n\nendmodule\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[296, "        wire                  s_axis_tvalid_mux  = int_axis_tvalid[grant_encoded*S_COUNT+n] && grant_valid;\n"]], "Add": [[296, "        wire                  s_axis_tvalid_mux  = int_axis_tvalid[grant_encoded*M_COUNT+n] && grant_valid;\n"]]}}