{"Source Block": ["verilog-ethernet/rtl/udp_ip_rx.v@229:395@HdlStmProcess", "\nassign busy = busy_reg;\nassign error_header_early_termination = error_header_early_termination_reg;\nassign error_payload_early_termination = error_payload_early_termination_reg;\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    s_ip_hdr_ready_next = 1'b0;\n    s_ip_payload_axis_tready_next = 1'b0;\n\n    store_ip_hdr = 1'b0;\n    store_udp_source_port_0 = 1'b0;\n    store_udp_source_port_1 = 1'b0;\n    store_udp_dest_port_0 = 1'b0;\n    store_udp_dest_port_1 = 1'b0;\n    store_udp_length_0 = 1'b0;\n    store_udp_length_1 = 1'b0;\n    store_udp_checksum_0 = 1'b0;\n    store_udp_checksum_1 = 1'b0;\n\n    store_last_word = 1'b0;\n\n    hdr_ptr_next = hdr_ptr_reg;\n    word_count_next = word_count_reg;\n\n    m_udp_hdr_valid_next = m_udp_hdr_valid_reg && !m_udp_hdr_ready;\n\n    error_header_early_termination_next = 1'b0;\n    error_payload_early_termination_next = 1'b0;\n\n    m_udp_payload_axis_tdata_int = 8'd0;\n    m_udp_payload_axis_tvalid_int = 1'b0;\n    m_udp_payload_axis_tlast_int = 1'b0;\n    m_udp_payload_axis_tuser_int = 1'b0;\n\n    case (state_reg)\n        STATE_IDLE: begin\n            // idle state - wait for header\n            hdr_ptr_next = 3'd0;\n            s_ip_hdr_ready_next = !m_udp_hdr_valid_next;\n\n            if (s_ip_hdr_ready && s_ip_hdr_valid) begin\n                s_ip_hdr_ready_next = 1'b0;\n                s_ip_payload_axis_tready_next = 1'b1;\n                store_ip_hdr = 1'b1;\n                state_next = STATE_READ_HEADER;\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_READ_HEADER: begin\n            // read header state\n            s_ip_payload_axis_tready_next = 1'b1;\n            word_count_next = m_udp_length_reg - 16'd8;\n\n            if (s_ip_payload_axis_tready && s_ip_payload_axis_tvalid) begin\n                // word transfer in - store it\n                hdr_ptr_next = hdr_ptr_reg + 3'd1;\n                state_next = STATE_READ_HEADER;\n\n                case (hdr_ptr_reg)\n                    3'h0: store_udp_source_port_1 = 1'b1;\n                    3'h1: store_udp_source_port_0 = 1'b1;\n                    3'h2: store_udp_dest_port_1 = 1'b1;\n                    3'h3: store_udp_dest_port_0 = 1'b1;\n                    3'h4: store_udp_length_1 = 1'b1;\n                    3'h5: store_udp_length_0 = 1'b1;\n                    3'h6: store_udp_checksum_1 = 1'b1;\n                    3'h7: begin\n                        store_udp_checksum_0 = 1'b1;\n                        m_udp_hdr_valid_next = 1'b1;\n                        s_ip_payload_axis_tready_next = m_udp_payload_axis_tready_int_early;\n                        state_next = STATE_READ_PAYLOAD;\n                    end\n                endcase\n\n                if (s_ip_payload_axis_tlast) begin\n                    error_header_early_termination_next = 1'b1;\n                    m_udp_hdr_valid_next = 1'b0;\n                    s_ip_hdr_ready_next = !m_udp_hdr_valid_next;\n                    s_ip_payload_axis_tready_next = 1'b0;\n                    state_next = STATE_IDLE;\n                end\n\n            end else begin\n                state_next = STATE_READ_HEADER;\n            end\n        end\n        STATE_READ_PAYLOAD: begin\n            // read payload\n            s_ip_payload_axis_tready_next = m_udp_payload_axis_tready_int_early;\n\n            m_udp_payload_axis_tdata_int = s_ip_payload_axis_tdata;\n            m_udp_payload_axis_tvalid_int = s_ip_payload_axis_tvalid;\n            m_udp_payload_axis_tlast_int = s_ip_payload_axis_tlast;\n            m_udp_payload_axis_tuser_int = s_ip_payload_axis_tuser;\n\n            if (s_ip_payload_axis_tready && s_ip_payload_axis_tvalid) begin\n                // word transfer through\n                word_count_next = word_count_reg - 16'd1;\n                if (s_ip_payload_axis_tlast) begin\n                    if (word_count_reg != 16'd1) begin\n                        // end of frame, but length does not match\n                        m_udp_payload_axis_tuser_int = 1'b1;\n                        error_payload_early_termination_next = 1'b1;\n                    end\n                    s_ip_hdr_ready_next = !m_udp_hdr_valid_next;\n                    s_ip_payload_axis_tready_next = 1'b0;\n                    state_next = STATE_IDLE;\n                end else begin\n                    if (word_count_reg == 16'd1) begin\n                        store_last_word = 1'b1;\n                        m_udp_payload_axis_tvalid_int = 1'b0;\n                        state_next = STATE_READ_PAYLOAD_LAST;\n                    end else begin\n                        state_next = STATE_READ_PAYLOAD;\n                    end\n                end\n            end else begin\n                state_next = STATE_READ_PAYLOAD;\n            end\n        end\n        STATE_READ_PAYLOAD_LAST: begin\n            // read and discard until end of frame\n            s_ip_payload_axis_tready_next = m_udp_payload_axis_tready_int_early;\n\n            m_udp_payload_axis_tdata_int = last_word_data_reg;\n            m_udp_payload_axis_tvalid_int = s_ip_payload_axis_tvalid && s_ip_payload_axis_tlast;\n            m_udp_payload_axis_tlast_int = s_ip_payload_axis_tlast;\n            m_udp_payload_axis_tuser_int = s_ip_payload_axis_tuser;\n\n            if (s_ip_payload_axis_tready && s_ip_payload_axis_tvalid) begin\n                if (s_ip_payload_axis_tlast) begin\n                    s_ip_hdr_ready_next = !m_udp_hdr_valid_next;\n                    s_ip_payload_axis_tready_next = 1'b0;\n                    state_next = STATE_IDLE;\n                end else begin\n                    state_next = STATE_READ_PAYLOAD_LAST;\n                end\n            end else begin\n                state_next = STATE_READ_PAYLOAD_LAST;\n            end\n        end\n        STATE_WAIT_LAST: begin\n            // wait for end of frame; read and discard\n            s_ip_payload_axis_tready_next = 1'b1;\n\n            if (s_ip_payload_axis_tready && s_ip_payload_axis_tvalid) begin\n                if (s_ip_payload_axis_tlast) begin\n                    s_ip_hdr_ready_next = !m_udp_hdr_valid_next;\n                    s_ip_payload_axis_tready_next = 1'b0;\n                    state_next = STATE_IDLE;\n                end else begin\n                    state_next = STATE_WAIT_LAST;\n                end\n            end else begin\n                state_next = STATE_WAIT_LAST;\n            end\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state_reg <= STATE_IDLE;\n        s_ip_hdr_ready_reg <= 1'b0;\n"], "Clone Blocks": [["verilog-ethernet/rtl/udp_ip_tx.v@213:364", "assign m_ip_dest_ip = m_ip_dest_ip_reg;\n\nassign busy = busy_reg;\nassign error_payload_early_termination = error_payload_early_termination_reg;\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    s_udp_hdr_ready_next = 1'b0;\n    s_udp_payload_axis_tready_next = 1'b0;\n\n    store_udp_hdr = 1'b0;\n\n    store_last_word = 1'b0;\n\n    hdr_ptr_next = hdr_ptr_reg;\n    word_count_next = word_count_reg;\n\n    m_ip_hdr_valid_next = m_ip_hdr_valid_reg && !m_ip_hdr_ready;\n\n    error_payload_early_termination_next = 1'b0;\n\n    m_ip_payload_axis_tdata_int = 8'd0;\n    m_ip_payload_axis_tvalid_int = 1'b0;\n    m_ip_payload_axis_tlast_int = 1'b0;\n    m_ip_payload_axis_tuser_int = 1'b0;\n\n    case (state_reg)\n        STATE_IDLE: begin\n            // idle state - wait for data\n            hdr_ptr_next = 3'd0;\n            s_udp_hdr_ready_next = !m_ip_hdr_valid_next;\n\n            if (s_udp_hdr_ready && s_udp_hdr_valid) begin\n                store_udp_hdr = 1'b1;\n                s_udp_hdr_ready_next = 1'b0;\n                m_ip_hdr_valid_next = 1'b1;\n                if (m_ip_payload_axis_tready_int_reg) begin\n                    m_ip_payload_axis_tvalid_int = 1'b1;\n                    m_ip_payload_axis_tdata_int = s_udp_source_port[15: 8];\n                    hdr_ptr_next = 3'd1;\n                end\n                state_next = STATE_WRITE_HEADER;\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_WRITE_HEADER: begin\n            // write header state\n            word_count_next = udp_length_reg - 16'd8;\n\n            if (m_ip_payload_axis_tready_int_reg) begin\n                // word transfer out\n                hdr_ptr_next = hdr_ptr_reg + 3'd1;\n                m_ip_payload_axis_tvalid_int = 1'b1;\n                state_next = STATE_WRITE_HEADER;\n                case (hdr_ptr_reg)\n                    3'h0: m_ip_payload_axis_tdata_int = udp_source_port_reg[15: 8];\n                    3'h1: m_ip_payload_axis_tdata_int = udp_source_port_reg[ 7: 0];\n                    3'h2: m_ip_payload_axis_tdata_int = udp_dest_port_reg[15: 8];\n                    3'h3: m_ip_payload_axis_tdata_int = udp_dest_port_reg[ 7: 0];\n                    3'h4: m_ip_payload_axis_tdata_int = udp_length_reg[15: 8];\n                    3'h5: m_ip_payload_axis_tdata_int = udp_length_reg[ 7: 0];\n                    3'h6: m_ip_payload_axis_tdata_int = udp_checksum_reg[15: 8];\n                    3'h7: begin\n                        m_ip_payload_axis_tdata_int = udp_checksum_reg[ 7: 0];\n                        s_udp_payload_axis_tready_next = m_ip_payload_axis_tready_int_early;\n                        state_next = STATE_WRITE_PAYLOAD;\n                    end\n                endcase\n            end else begin\n                state_next = STATE_WRITE_HEADER;\n            end\n        end\n        STATE_WRITE_PAYLOAD: begin\n            // write payload\n            s_udp_payload_axis_tready_next = m_ip_payload_axis_tready_int_early;\n\n            m_ip_payload_axis_tdata_int = s_udp_payload_axis_tdata;\n            m_ip_payload_axis_tvalid_int = s_udp_payload_axis_tvalid;\n            m_ip_payload_axis_tlast_int = s_udp_payload_axis_tlast;\n            m_ip_payload_axis_tuser_int = s_udp_payload_axis_tuser;\n\n            if (s_udp_payload_axis_tready && s_udp_payload_axis_tvalid) begin\n                // word transfer through\n                word_count_next = word_count_reg - 16'd1;\n                if (s_udp_payload_axis_tlast) begin\n                    if (word_count_reg != 16'd1) begin\n                        // end of frame, but length does not match\n                        m_ip_payload_axis_tuser_int = 1'b1;\n                        error_payload_early_termination_next = 1'b1;\n                    end\n                    s_udp_hdr_ready_next = !m_ip_hdr_valid_next;\n                    s_udp_payload_axis_tready_next = 1'b0;\n                    state_next = STATE_IDLE;\n                end else begin\n                    if (word_count_reg == 16'd1) begin\n                        store_last_word = 1'b1;\n                        m_ip_payload_axis_tvalid_int = 1'b0;\n                        state_next = STATE_WRITE_PAYLOAD_LAST;\n                    end else begin\n                        state_next = STATE_WRITE_PAYLOAD;\n                    end\n                end\n            end else begin\n                state_next = STATE_WRITE_PAYLOAD;\n            end\n        end\n        STATE_WRITE_PAYLOAD_LAST: begin\n            // read and discard until end of frame\n            s_udp_payload_axis_tready_next = m_ip_payload_axis_tready_int_early;\n\n            m_ip_payload_axis_tdata_int = last_word_data_reg;\n            m_ip_payload_axis_tvalid_int = s_udp_payload_axis_tvalid && s_udp_payload_axis_tlast;\n            m_ip_payload_axis_tlast_int = s_udp_payload_axis_tlast;\n            m_ip_payload_axis_tuser_int = s_udp_payload_axis_tuser;\n\n            if (s_udp_payload_axis_tready && s_udp_payload_axis_tvalid) begin\n                if (s_udp_payload_axis_tlast) begin\n                    s_udp_hdr_ready_next = !m_ip_hdr_valid_next;\n                    s_udp_payload_axis_tready_next = 1'b0;\n                    state_next = STATE_IDLE;\n                end else begin\n                    state_next = STATE_WRITE_PAYLOAD_LAST;\n                end\n            end else begin\n                state_next = STATE_WRITE_PAYLOAD_LAST;\n            end\n        end\n        STATE_WAIT_LAST: begin\n            // wait for end of frame; read and discard\n            s_udp_payload_axis_tready_next = 1'b1;\n\n            if (s_udp_payload_axis_tvalid) begin\n                if (s_udp_payload_axis_tlast) begin\n                    s_udp_hdr_ready_next = !m_ip_hdr_valid_next;\n                    s_udp_payload_axis_tready_next = 1'b0;\n                    state_next = STATE_IDLE;\n                end else begin\n                    state_next = STATE_WAIT_LAST;\n                end\n            end else begin\n                state_next = STATE_WAIT_LAST;\n            end\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state_reg <= STATE_IDLE;\n        s_udp_hdr_ready_reg <= 1'b0;\n"], ["verilog-ethernet/rtl/udp_ip_rx_64.v@255:416", "        4'd7: count2keep = 8'b01111111;\n        4'd8: count2keep = 8'b11111111;\n    endcase\nendfunction\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    s_ip_hdr_ready_next = 1'b0;\n    s_ip_payload_axis_tready_next = 1'b0;\n\n    store_ip_hdr = 1'b0;\n    store_hdr_word_0 = 1'b0;\n\n    store_last_word = 1'b0;\n\n    word_count_next = word_count_reg;\n\n    m_udp_hdr_valid_next = m_udp_hdr_valid_reg && !m_udp_hdr_ready;\n\n    error_header_early_termination_next = 1'b0;\n    error_payload_early_termination_next = 1'b0;\n\n    m_udp_payload_axis_tdata_int = 64'd0;\n    m_udp_payload_axis_tkeep_int = 8'd0;\n    m_udp_payload_axis_tvalid_int = 1'b0;\n    m_udp_payload_axis_tlast_int = 1'b0;\n    m_udp_payload_axis_tuser_int = 1'b0;\n\n    case (state_reg)\n        STATE_IDLE: begin\n            // idle state - wait for header\n            s_ip_hdr_ready_next = !m_udp_hdr_valid_next;\n\n            if (s_ip_hdr_ready && s_ip_hdr_valid) begin\n                s_ip_hdr_ready_next = 1'b0;\n                s_ip_payload_axis_tready_next = 1'b1;\n                store_ip_hdr = 1'b1;\n                state_next = STATE_READ_HEADER;\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_READ_HEADER: begin\n            // read header state\n            s_ip_payload_axis_tready_next = 1'b1;\n\n            word_count_next = {s_ip_payload_axis_tdata[39:32], s_ip_payload_axis_tdata[47:40]} - 16'd8;\n\n            if (s_ip_payload_axis_tready && s_ip_payload_axis_tvalid) begin\n                // word transfer in - store it\n                state_next = STATE_READ_HEADER;\n\n                store_hdr_word_0 = 1'b1;\n                m_udp_hdr_valid_next = 1'b1;\n                s_ip_payload_axis_tready_next = m_udp_payload_axis_tready_int_early;\n                state_next = STATE_READ_PAYLOAD;\n\n                if (s_ip_payload_axis_tlast) begin\n                    error_header_early_termination_next = 1'b1;\n                    m_udp_hdr_valid_next = 1'b0;\n                    s_ip_hdr_ready_next = !m_udp_hdr_valid_next;\n                    s_ip_payload_axis_tready_next = 1'b0;\n                    state_next = STATE_IDLE;\n                end\n\n            end else begin\n                state_next = STATE_READ_HEADER;\n            end\n        end\n        STATE_READ_PAYLOAD: begin\n            // read payload\n            s_ip_payload_axis_tready_next = m_udp_payload_axis_tready_int_early;\n\n            m_udp_payload_axis_tdata_int = s_ip_payload_axis_tdata;\n            m_udp_payload_axis_tkeep_int = s_ip_payload_axis_tkeep;\n            m_udp_payload_axis_tvalid_int = s_ip_payload_axis_tvalid;\n            m_udp_payload_axis_tlast_int = s_ip_payload_axis_tlast;\n            m_udp_payload_axis_tuser_int = s_ip_payload_axis_tuser;\n\n            store_last_word = 1'b1;\n\n            if (s_ip_payload_axis_tready && s_ip_payload_axis_tvalid) begin\n                // word transfer through\n                word_count_next = word_count_reg - 16'd8;\n                if (word_count_reg <= 8) begin\n                    // have entire payload\n                    m_udp_payload_axis_tkeep_int = s_ip_payload_axis_tkeep & count2keep(word_count_reg);\n                    if (s_ip_payload_axis_tlast) begin\n                        if (keep2count(s_ip_payload_axis_tkeep) < word_count_reg[4:0]) begin\n                            // end of frame, but length does not match\n                            error_payload_early_termination_next = 1'b1;\n                            m_udp_payload_axis_tuser_int = 1'b1;\n                        end\n                        s_ip_payload_axis_tready_next = 1'b0;\n                        s_ip_hdr_ready_next = !m_udp_hdr_valid_next;\n                        state_next = STATE_IDLE;\n                    end else begin\n                        m_udp_payload_axis_tvalid_int = 1'b0;\n                        state_next = STATE_READ_PAYLOAD_LAST;\n                    end\n                end else begin\n                    if (s_ip_payload_axis_tlast) begin\n                        // end of frame, but length does not match\n                        error_payload_early_termination_next = 1'b1;\n                        m_udp_payload_axis_tuser_int = 1'b1;\n                        s_ip_payload_axis_tready_next = 1'b0;\n                        s_ip_hdr_ready_next = !m_udp_hdr_valid_next;\n                        state_next = STATE_IDLE;\n                    end else begin\n                        state_next = STATE_READ_PAYLOAD;\n                    end\n                end\n            end else begin\n                state_next = STATE_READ_PAYLOAD;\n            end\n        end\n        STATE_READ_PAYLOAD_LAST: begin\n            // read and discard until end of frame\n            s_ip_payload_axis_tready_next = m_udp_payload_axis_tready_int_early;\n\n            m_udp_payload_axis_tdata_int = last_word_data_reg;\n            m_udp_payload_axis_tkeep_int = last_word_keep_reg;\n            m_udp_payload_axis_tvalid_int = s_ip_payload_axis_tvalid && s_ip_payload_axis_tlast;\n            m_udp_payload_axis_tlast_int = s_ip_payload_axis_tlast;\n            m_udp_payload_axis_tuser_int = s_ip_payload_axis_tuser;\n\n            if (s_ip_payload_axis_tready && s_ip_payload_axis_tvalid) begin\n                if (s_ip_payload_axis_tlast) begin\n                    s_ip_hdr_ready_next = !m_udp_hdr_valid_next;\n                    s_ip_payload_axis_tready_next = 1'b0;\n                    state_next = STATE_IDLE;\n                end else begin\n                    state_next = STATE_READ_PAYLOAD_LAST;\n                end\n            end else begin\n                state_next = STATE_READ_PAYLOAD_LAST;\n            end\n        end\n        STATE_WAIT_LAST: begin\n            // wait for end of frame; read and discard\n            s_ip_payload_axis_tready_next = 1'b1;\n\n            if (s_ip_payload_axis_tready && s_ip_payload_axis_tvalid) begin\n                if (s_ip_payload_axis_tlast) begin\n                    s_ip_hdr_ready_next = !m_udp_hdr_valid_next;\n                    s_ip_payload_axis_tready_next = 1'b0;\n                    state_next = STATE_IDLE;\n                end else begin\n                    state_next = STATE_WAIT_LAST;\n                end\n            end else begin\n                state_next = STATE_WAIT_LAST;\n            end\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state_reg <= STATE_IDLE;\n        s_ip_hdr_ready_reg <= 1'b0;\n"]], "Diff Content": {"Delete": [[323, "            m_udp_payload_axis_tvalid_int = s_ip_payload_axis_tvalid;\n"], [357, "            m_udp_payload_axis_tvalid_int = s_ip_payload_axis_tvalid && s_ip_payload_axis_tlast;\n"]], "Add": [[329, "                m_udp_payload_axis_tvalid_int = 1'b1;\n"], [364, "                    m_udp_payload_axis_tvalid_int = 1'b1;\n"]]}}