{"Source Block": ["verilog-ethernet/rtl/ip_eth_rx_64.v@276:507@HdlStmProcess", "        shift_eth_payload_axis_tuser = (s_eth_payload_axis_tuser && (s_eth_payload_axis_tkeep[7:4] == 0));\n        shift_eth_payload_s_tready = !(s_eth_payload_axis_tlast && s_eth_payload_axis_tvalid && transfer_in_save);\n    end\nend\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    flush_save = 1'b0;\n    transfer_in_save = 1'b0;\n\n    s_eth_hdr_ready_next = 1'b0;\n    s_eth_payload_axis_tready_next = 1'b0;\n\n    store_eth_hdr = 1'b0;\n    store_hdr_word_0 = 1'b0;\n    store_hdr_word_1 = 1'b0;\n    store_hdr_word_2 = 1'b0;\n\n    store_last_word = 1'b0;\n\n    hdr_ptr_next = hdr_ptr_reg;\n    word_count_next = word_count_reg;\n\n    hdr_sum_temp = 32'd0;\n    hdr_sum_next = hdr_sum_reg;\n    check_hdr_next = check_hdr_reg;\n\n    m_ip_hdr_valid_next = m_ip_hdr_valid_reg && !m_ip_hdr_ready;\n\n    error_header_early_termination_next = 1'b0;\n    error_payload_early_termination_next = 1'b0;\n    error_invalid_header_next = 1'b0;\n    error_invalid_checksum_next = 1'b0;\n\n    m_ip_payload_axis_tdata_int = 64'd0;\n    m_ip_payload_axis_tkeep_int = 8'd0;\n    m_ip_payload_axis_tvalid_int = 1'b0;\n    m_ip_payload_axis_tlast_int = 1'b0;\n    m_ip_payload_axis_tuser_int = 1'b0;\n\n    case (state_reg)\n        STATE_IDLE: begin\n            // idle state - wait for header\n            hdr_ptr_next = 6'd0;\n            hdr_sum_next = 32'd0;\n            flush_save = 1'b1;\n            s_eth_hdr_ready_next = !m_ip_hdr_valid_next;\n\n            if (s_eth_hdr_ready && s_eth_hdr_valid) begin\n                s_eth_hdr_ready_next = 1'b0;\n                s_eth_payload_axis_tready_next = 1'b1;\n                store_eth_hdr = 1'b1;\n                state_next = STATE_READ_HEADER;\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_READ_HEADER: begin\n            // read header\n            s_eth_payload_axis_tready_next = shift_eth_payload_s_tready;\n            word_count_next = m_ip_length_reg - 5*4;\n\n            if (s_eth_payload_axis_tvalid) begin\n                // word transfer in - store it\n                hdr_ptr_next = hdr_ptr_reg + 6'd8;\n                transfer_in_save = 1'b1;\n                state_next = STATE_READ_HEADER;\n\n                case (hdr_ptr_reg)\n                    6'h00: begin\n                        store_hdr_word_0 = 1'b1;\n                    end\n                    6'h08: begin\n                        store_hdr_word_1 = 1'b1;\n                        hdr_sum_next = hdr_sum_high_reg + hdr_sum_low_reg;\n                    end\n                    6'h10: begin\n                        store_hdr_word_2 = 1'b1;\n                        hdr_sum_next = hdr_sum_reg + hdr_sum_high_reg + hdr_sum_low_reg;\n\n                        // check header checksum on next cycle for improved timing\n                        check_hdr_next = 1'b1;\n\n                        if (m_ip_version_reg != 4'd4 || m_ip_ihl_reg != 4'd5) begin\n                            error_invalid_header_next = 1'b1;\n                            s_eth_payload_axis_tready_next = shift_eth_payload_s_tready;\n                            state_next = STATE_WAIT_LAST;\n                        end else begin\n                            s_eth_payload_axis_tready_next = m_ip_payload_axis_tready_int_early && shift_eth_payload_s_tready;\n                            state_next = STATE_READ_PAYLOAD;\n                        end\n                    end\n                endcase\n\n                if (shift_eth_payload_axis_tlast) begin\n                    error_header_early_termination_next = 1'b1;\n                    error_invalid_header_next = 1'b0;\n                    error_invalid_checksum_next = 1'b0;\n                    m_ip_hdr_valid_next = 1'b0;\n                    s_eth_hdr_ready_next = !m_ip_hdr_valid_next;\n                    s_eth_payload_axis_tready_next = 1'b0;\n                    state_next = STATE_IDLE;\n                end\n\n            end else begin\n                state_next = STATE_READ_HEADER;\n            end\n        end\n        STATE_READ_PAYLOAD: begin\n            // read payload\n            s_eth_payload_axis_tready_next = m_ip_payload_axis_tready_int_early && shift_eth_payload_s_tready;\n\n            m_ip_payload_axis_tdata_int = shift_eth_payload_axis_tdata;\n            m_ip_payload_axis_tkeep_int = shift_eth_payload_axis_tkeep;\n            m_ip_payload_axis_tvalid_int = shift_eth_payload_axis_tvalid;\n            m_ip_payload_axis_tlast_int = shift_eth_payload_axis_tlast;\n            m_ip_payload_axis_tuser_int = shift_eth_payload_axis_tuser;\n\n            store_last_word = 1'b1;\n\n            if (m_ip_payload_axis_tready_int_reg && shift_eth_payload_axis_tvalid) begin\n                // word transfer through\n                word_count_next = word_count_reg - 16'd8;\n                transfer_in_save = 1'b1;\n                if (word_count_reg <= 8) begin\n                    // have entire payload\n                    m_ip_payload_axis_tkeep_int = shift_eth_payload_axis_tkeep & count2keep(word_count_reg);\n                    if (shift_eth_payload_axis_tlast) begin\n                        if (keep2count(shift_eth_payload_axis_tkeep) < word_count_reg[4:0]) begin\n                            // end of frame, but length does not match\n                            error_payload_early_termination_next = 1'b1;\n                            m_ip_payload_axis_tuser_int = 1'b1;\n                        end\n                        s_eth_payload_axis_tready_next = 1'b0;\n                        flush_save = 1'b1;\n                        s_eth_hdr_ready_next = !m_ip_hdr_valid_reg && !check_hdr_reg;\n                        state_next = STATE_IDLE;\n                    end else begin\n                        m_ip_payload_axis_tvalid_int = 1'b0;\n                        state_next = STATE_READ_PAYLOAD_LAST;\n                    end\n                end else begin\n                    if (shift_eth_payload_axis_tlast) begin\n                        // end of frame, but length does not match\n                        error_payload_early_termination_next = 1'b1;\n                        m_ip_payload_axis_tuser_int = 1'b1;\n                        s_eth_payload_axis_tready_next = 1'b0;\n                        flush_save = 1'b1;\n                        s_eth_hdr_ready_next = !m_ip_hdr_valid_reg && !check_hdr_reg;\n                        state_next = STATE_IDLE;\n                    end else begin\n                        state_next = STATE_READ_PAYLOAD;\n                    end\n                end\n            end else begin\n                state_next = STATE_READ_PAYLOAD;\n            end\n\n            if (check_hdr_reg) begin\n                check_hdr_next = 1'b0;\n\n                hdr_sum_temp = hdr_sum_reg[15:0] + hdr_sum_reg[19:16] + hdr_sum_low_reg;\n\n                if (hdr_sum_temp != 19'h0ffff && hdr_sum_temp != 19'h1fffe) begin\n                    // bad checksum\n                    error_invalid_checksum_next = 1'b1;\n                    m_ip_payload_axis_tvalid_int = 1'b0;\n                    if (shift_eth_payload_axis_tlast && shift_eth_payload_axis_tvalid) begin\n                        // only one payload cycle; return to idle now\n                        s_eth_hdr_ready_next = !m_ip_hdr_valid_reg && !check_hdr_reg;\n                        state_next = STATE_IDLE;\n                    end else begin\n                        // drop payload\n                        s_eth_payload_axis_tready_next = shift_eth_payload_s_tready;\n                        state_next = STATE_WAIT_LAST;\n                    end\n                end else begin\n                    // good checksum; transfer header\n                    m_ip_hdr_valid_next = 1'b1;\n                end\n            end\n        end\n        STATE_READ_PAYLOAD_LAST: begin\n            // read and discard until end of frame\n            s_eth_payload_axis_tready_next = m_ip_payload_axis_tready_int_early && shift_eth_payload_s_tready;\n\n            m_ip_payload_axis_tdata_int = last_word_data_reg;\n            m_ip_payload_axis_tkeep_int = last_word_keep_reg;\n            m_ip_payload_axis_tvalid_int = shift_eth_payload_axis_tvalid && shift_eth_payload_axis_tlast;\n            m_ip_payload_axis_tlast_int = shift_eth_payload_axis_tlast;\n            m_ip_payload_axis_tuser_int = shift_eth_payload_axis_tuser;\n\n            if (m_ip_payload_axis_tready_int_reg && shift_eth_payload_axis_tvalid) begin\n                transfer_in_save = 1'b1;\n                if (shift_eth_payload_axis_tlast) begin\n                    s_eth_payload_axis_tready_next = 1'b0;\n                    flush_save = 1'b1;\n                    s_eth_hdr_ready_next = !m_ip_hdr_valid_next;\n                    state_next = STATE_IDLE;\n                end else begin\n                    state_next = STATE_READ_PAYLOAD_LAST;\n                end\n            end else begin\n                state_next = STATE_READ_PAYLOAD_LAST;\n            end\n        end\n        STATE_WAIT_LAST: begin\n            // read and discard until end of frame\n            s_eth_payload_axis_tready_next = shift_eth_payload_s_tready;\n\n            if (shift_eth_payload_axis_tvalid) begin\n                transfer_in_save = 1'b1;\n                if (shift_eth_payload_axis_tlast) begin\n                    s_eth_payload_axis_tready_next = 1'b0;\n                    flush_save = 1'b1;\n                    s_eth_hdr_ready_next = !m_ip_hdr_valid_next;\n                    state_next = STATE_IDLE;\n                end else begin\n                    state_next = STATE_WAIT_LAST;\n                end\n            end else begin\n                state_next = STATE_WAIT_LAST;\n            end\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state_reg <= STATE_IDLE;\n        s_eth_hdr_ready_reg <= 1'b0;\n"], "Clone Blocks": [["verilog-ethernet/rtl/ip_eth_rx.v@227:436", "        t = a+b;\n        add1c16b = t[15:0] + t[16];\n    end\nendfunction\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    s_eth_hdr_ready_next = 1'b0;\n    s_eth_payload_axis_tready_next = 1'b0;\n\n    store_eth_hdr = 1'b0;\n    store_ip_version_ihl = 1'b0;\n    store_ip_dscp_ecn = 1'b0;\n    store_ip_length_0 = 1'b0;\n    store_ip_length_1 = 1'b0;\n    store_ip_identification_0 = 1'b0;\n    store_ip_identification_1 = 1'b0;\n    store_ip_flags_fragment_offset_0 = 1'b0;\n    store_ip_flags_fragment_offset_1 = 1'b0;\n    store_ip_ttl = 1'b0;\n    store_ip_protocol = 1'b0;\n    store_ip_header_checksum_0 = 1'b0;\n    store_ip_header_checksum_1 = 1'b0;\n    store_ip_source_ip_0 = 1'b0;\n    store_ip_source_ip_1 = 1'b0;\n    store_ip_source_ip_2 = 1'b0;\n    store_ip_source_ip_3 = 1'b0;\n    store_ip_dest_ip_0 = 1'b0;\n    store_ip_dest_ip_1 = 1'b0;\n    store_ip_dest_ip_2 = 1'b0;\n    store_ip_dest_ip_3 = 1'b0;\n\n    store_last_word = 1'b0;\n\n    hdr_ptr_next = hdr_ptr_reg;\n    word_count_next = word_count_reg;\n\n    hdr_sum_next = hdr_sum_reg;\n\n    m_ip_hdr_valid_next = m_ip_hdr_valid_reg && !m_ip_hdr_ready;\n\n    error_header_early_termination_next = 1'b0;\n    error_payload_early_termination_next = 1'b0;\n    error_invalid_header_next = 1'b0;\n    error_invalid_checksum_next = 1'b0;\n\n    m_ip_payload_axis_tdata_int = 8'd0;\n    m_ip_payload_axis_tvalid_int = 1'b0;\n    m_ip_payload_axis_tlast_int = 1'b0;\n    m_ip_payload_axis_tuser_int = 1'b0;\n\n    case (state_reg)\n        STATE_IDLE: begin\n            // idle state - wait for header\n            hdr_ptr_next = 16'd0;\n            hdr_sum_next = 16'd0;\n            s_eth_hdr_ready_next = !m_ip_hdr_valid_next;\n\n            if (s_eth_hdr_ready && s_eth_hdr_valid) begin\n                s_eth_hdr_ready_next = 1'b0;\n                s_eth_payload_axis_tready_next = 1'b1;\n                store_eth_hdr = 1'b1;\n                state_next = STATE_READ_HEADER;\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_READ_HEADER: begin\n            // read header\n            s_eth_payload_axis_tready_next = 1'b1;\n            word_count_next = m_ip_length_reg - 5*4;\n\n            if (s_eth_payload_axis_tready && s_eth_payload_axis_tvalid) begin\n                // word transfer in - store it\n                hdr_ptr_next = hdr_ptr_reg + 6'd1;\n                state_next = STATE_READ_HEADER;\n\n                if (hdr_ptr_reg[0]) begin\n                    hdr_sum_next = add1c16b(hdr_sum_reg, {8'd0, s_eth_payload_axis_tdata});\n                end else begin\n                    hdr_sum_next = add1c16b(hdr_sum_reg, {s_eth_payload_axis_tdata, 8'd0});\n                end\n\n                case (hdr_ptr_reg)\n                    6'h00: store_ip_version_ihl = 1'b1;\n                    6'h01: store_ip_dscp_ecn = 1'b1;\n                    6'h02: store_ip_length_1 = 1'b1;\n                    6'h03: store_ip_length_0 = 1'b1;\n                    6'h04: store_ip_identification_1 = 1'b1;\n                    6'h05: store_ip_identification_0 = 1'b1;\n                    6'h06: store_ip_flags_fragment_offset_1 = 1'b1;\n                    6'h07: store_ip_flags_fragment_offset_0 = 1'b1;\n                    6'h08: store_ip_ttl = 1'b1;\n                    6'h09: store_ip_protocol = 1'b1;\n                    6'h0A: store_ip_header_checksum_1 = 1'b1;\n                    6'h0B: store_ip_header_checksum_0 = 1'b1;\n                    6'h0C: store_ip_source_ip_3 = 1'b1;\n                    6'h0D: store_ip_source_ip_2 = 1'b1;\n                    6'h0E: store_ip_source_ip_1 = 1'b1;\n                    6'h0F: store_ip_source_ip_0 = 1'b1;\n                    6'h10: store_ip_dest_ip_3 = 1'b1;\n                    6'h11: store_ip_dest_ip_2 = 1'b1;\n                    6'h12: store_ip_dest_ip_1 = 1'b1;\n                    6'h13: begin\n                        store_ip_dest_ip_0 = 1'b1;\n                        if (m_ip_version_reg != 4'd4 || m_ip_ihl_reg != 4'd5) begin\n                            error_invalid_header_next = 1'b1;\n                            state_next = STATE_WAIT_LAST;\n                        end else if (hdr_sum_next != 16'hffff) begin\n                            error_invalid_checksum_next = 1'b1;\n                            state_next = STATE_WAIT_LAST;\n                        end else begin\n                            m_ip_hdr_valid_next = 1'b1;\n                            s_eth_payload_axis_tready_next = m_ip_payload_axis_tready_int_early;\n                            state_next = STATE_READ_PAYLOAD;\n                        end\n                    end\n                endcase\n\n                if (s_eth_payload_axis_tlast) begin\n                    error_header_early_termination_next = 1'b1;\n                    m_ip_hdr_valid_next = 1'b0;\n                    s_eth_hdr_ready_next = !m_ip_hdr_valid_next;\n                    s_eth_payload_axis_tready_next = 1'b0;\n                    state_next = STATE_IDLE;\n                end\n\n            end else begin\n                state_next = STATE_READ_HEADER;\n            end\n        end\n        STATE_READ_PAYLOAD: begin\n            // read payload\n            s_eth_payload_axis_tready_next = m_ip_payload_axis_tready_int_early;\n\n            m_ip_payload_axis_tdata_int = s_eth_payload_axis_tdata;\n            m_ip_payload_axis_tvalid_int = s_eth_payload_axis_tvalid;\n            m_ip_payload_axis_tlast_int = s_eth_payload_axis_tlast;\n            m_ip_payload_axis_tuser_int = s_eth_payload_axis_tuser;\n\n            if (s_eth_payload_axis_tready && s_eth_payload_axis_tvalid) begin\n                // word transfer through\n                word_count_next = word_count_reg - 16'd1;\n                if (s_eth_payload_axis_tlast) begin\n                    if (word_count_reg > 16'd1) begin\n                        // end of frame, but length does not match\n                        m_ip_payload_axis_tuser_int = 1'b1;\n                        error_payload_early_termination_next = 1'b1;\n                    end\n                    s_eth_hdr_ready_next = !m_ip_hdr_valid_next;\n                    s_eth_payload_axis_tready_next = 1'b0;\n                    state_next = STATE_IDLE;\n                end else begin\n                    if (word_count_reg == 16'd1) begin\n                        store_last_word = 1'b1;\n                        m_ip_payload_axis_tvalid_int = 1'b0;\n                        state_next = STATE_READ_PAYLOAD_LAST;\n                    end else begin\n                        state_next = STATE_READ_PAYLOAD;\n                    end\n                end\n            end else begin\n                state_next = STATE_READ_PAYLOAD;\n            end\n        end\n        STATE_READ_PAYLOAD_LAST: begin\n            // read and discard until end of frame\n            s_eth_payload_axis_tready_next = m_ip_payload_axis_tready_int_early;\n\n            m_ip_payload_axis_tdata_int = last_word_data_reg;\n            m_ip_payload_axis_tvalid_int = s_eth_payload_axis_tvalid && s_eth_payload_axis_tlast;\n            m_ip_payload_axis_tlast_int = s_eth_payload_axis_tlast;\n            m_ip_payload_axis_tuser_int = s_eth_payload_axis_tuser;\n\n            if (s_eth_payload_axis_tready && s_eth_payload_axis_tvalid) begin\n                if (s_eth_payload_axis_tlast) begin\n                    s_eth_hdr_ready_next = !m_ip_hdr_valid_next;\n                    s_eth_payload_axis_tready_next = 1'b0;\n                    state_next = STATE_IDLE;\n                end else begin\n                    state_next = STATE_READ_PAYLOAD_LAST;\n                end\n            end else begin\n                state_next = STATE_READ_PAYLOAD_LAST;\n            end\n        end\n        STATE_WAIT_LAST: begin\n            // read and discard until end of frame\n            s_eth_payload_axis_tready_next = 1'b1;\n\n            if (s_eth_payload_axis_tready && s_eth_payload_axis_tvalid) begin\n                if (s_eth_payload_axis_tlast) begin\n                    s_eth_hdr_ready_next = !m_ip_hdr_valid_next;\n                    s_eth_payload_axis_tready_next = 1'b0;\n                    state_next = STATE_IDLE;\n                end else begin\n                    state_next = STATE_WAIT_LAST;\n                end\n            end else begin\n                state_next = STATE_WAIT_LAST;\n            end\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state_reg <= STATE_IDLE;\n        s_eth_hdr_ready_reg <= 1'b0;\n"]], "Diff Content": {"Delete": [[391, "            m_ip_payload_axis_tvalid_int = shift_eth_payload_axis_tvalid;\n"], [465, "            m_ip_payload_axis_tvalid_int = shift_eth_payload_axis_tvalid && shift_eth_payload_axis_tlast;\n"]], "Add": [[400, "                m_ip_payload_axis_tvalid_int = 1'b1;\n"], [474, "                    m_ip_payload_axis_tvalid_int = 1'b1;\n"]]}}