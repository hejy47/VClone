{"Source Block": ["verilog-ethernet/rtl/axis_frame_length_adjust.v@133:443@HdlStmProcess", "assign status_frame_length = status_frame_length_reg;\nassign status_frame_original_length = status_frame_original_length_reg;\n\ninteger i, word_cnt;\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    store_last_word = 0;\n\n    frame_ptr_next = frame_ptr_reg;\n\n    short_counter_next = short_counter_reg;\n    long_counter_next = long_counter_reg;\n\n    output_axis_tdata_int = 0;\n    output_axis_tkeep_int = 0;\n    output_axis_tvalid_int = 0;\n    output_axis_tlast_int = 0;\n    output_axis_tuser_int = 0;\n\n    input_axis_tready_next = 0;\n\n    last_cycle_tuser_next = last_cycle_tuser_reg;\n\n    status_valid_next = status_valid_reg & ~status_ready;\n    status_frame_pad_next = status_frame_pad_reg;\n    status_frame_truncate_next = status_frame_truncate_reg;\n    status_frame_length_next = status_frame_length_reg;\n    status_frame_original_length_next = status_frame_original_length_reg;\n\n    case (state_reg)\n        STATE_IDLE: begin\n            // idle state\n            // accept data next cycle if output register ready next cycle\n            input_axis_tready_next = output_axis_tready_int_early & (~status_valid_reg | status_ready);\n\n            output_axis_tdata_int = input_axis_tdata;\n            output_axis_tkeep_int = input_axis_tkeep;\n            output_axis_tvalid_int = input_axis_tvalid;\n            output_axis_tlast_int = input_axis_tlast;\n            output_axis_tuser_int = input_axis_tuser;\n\n            short_counter_next = length_min;\n            long_counter_next = length_max;\n\n            if (input_axis_tready & input_axis_tvalid) begin\n                // transfer through\n                word_cnt = 0;\n                for (i = 0; i <= KEEP_WIDTH; i = i + 1) begin\n                    //bit_cnt = bit_cnt + monitor_axis_tkeep[i];\n                    if (input_axis_tkeep == ({KEEP_WIDTH{1'b1}}) >> (KEEP_WIDTH-i)) word_cnt = i;\n                end\n                frame_ptr_next = frame_ptr_reg+KEEP_WIDTH;\n\n                if (short_counter_reg > KEEP_WIDTH) begin\n                    short_counter_next = short_counter_reg - KEEP_WIDTH;\n                end else begin\n                    short_counter_next = 0;\n                end\n\n                if (long_counter_reg > KEEP_WIDTH) begin\n                    long_counter_next = long_counter_reg - KEEP_WIDTH;\n                end else begin\n                    long_counter_next = 0;\n                end\n\n                if (long_counter_reg <= word_cnt) begin\n                    output_axis_tkeep_int = ({KEEP_WIDTH{1'b1}}) >> (KEEP_WIDTH-long_counter_reg);\n                    if (input_axis_tlast) begin\n                        status_valid_next = 1;\n                        status_frame_pad_next = 0;\n                        status_frame_truncate_next = word_cnt > long_counter_reg;\n                        status_frame_length_next = length_max;\n                        status_frame_original_length_next = frame_ptr_reg+word_cnt;\n                        input_axis_tready_next = output_axis_tready_int_early & status_ready;\n                        frame_ptr_next = 0;\n                        short_counter_next = length_min;\n                        long_counter_next = length_max;\n                        state_next = STATE_IDLE;\n                    end else begin\n                        output_axis_tvalid_int = 0;\n                        store_last_word = 1;\n                        state_next = STATE_TRUNCATE;\n                    end\n                end else begin\n                    if (input_axis_tlast) begin\n                        status_frame_original_length_next = frame_ptr_reg+word_cnt;\n                        if (short_counter_reg > word_cnt) begin\n                            if (short_counter_reg > KEEP_WIDTH) begin\n                                frame_ptr_next = frame_ptr_reg + KEEP_WIDTH;\n                                input_axis_tready_next = 0;\n                                output_axis_tkeep_int = {KEEP_WIDTH{1'b1}};\n                                output_axis_tlast_int = 0;\n                                output_axis_tuser_int = 0;\n                                last_cycle_tuser_next = input_axis_tuser;\n                                state_next = STATE_PAD;\n                            end else begin\n                                status_valid_next = 1;\n                                status_frame_pad_next = 1;\n                                status_frame_truncate_next = 0;\n                                status_frame_length_next = length_min;\n                                input_axis_tready_next = output_axis_tready_int_early & status_ready;\n                                output_axis_tkeep_int = ({KEEP_WIDTH{1'b1}}) >> (KEEP_WIDTH-(length_min - frame_ptr_reg));\n                                frame_ptr_next = 0;\n                                short_counter_next = length_min;\n                                long_counter_next = length_max;\n                                state_next = STATE_IDLE;\n                            end\n                        end else begin\n                            status_valid_next = 1;\n                            status_frame_pad_next = 0;\n                            status_frame_truncate_next = 0;\n                            status_frame_length_next = frame_ptr_reg+word_cnt;\n                            status_frame_original_length_next = frame_ptr_reg+word_cnt;\n                            input_axis_tready_next = output_axis_tready_int_early & status_ready;\n                            frame_ptr_next = 0;\n                            short_counter_next = length_min;\n                            long_counter_next = length_max;\n                            state_next = STATE_IDLE;\n                        end\n                    end else begin\n                        state_next = STATE_TRANSFER;\n                    end\n                end\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_TRANSFER: begin\n            // transfer data\n            // accept data next cycle if output register ready next cycle\n            input_axis_tready_next = output_axis_tready_int_early;\n\n            output_axis_tdata_int = input_axis_tdata;\n            output_axis_tkeep_int = input_axis_tkeep;\n            output_axis_tvalid_int = input_axis_tvalid;\n            output_axis_tlast_int = input_axis_tlast;\n            output_axis_tuser_int = input_axis_tuser;\n\n            if (input_axis_tready & input_axis_tvalid) begin\n                // transfer through\n                word_cnt = 0;\n                for (i = 0; i <= KEEP_WIDTH; i = i + 1) begin\n                    //bit_cnt = bit_cnt + monitor_axis_tkeep[i];\n                    if (input_axis_tkeep == ({KEEP_WIDTH{1'b1}}) >> (KEEP_WIDTH-i)) word_cnt = i;\n                end\n                frame_ptr_next = frame_ptr_reg+KEEP_WIDTH;\n\n                if (short_counter_reg > KEEP_WIDTH) begin\n                    short_counter_next = short_counter_reg - KEEP_WIDTH;\n                end else begin\n                    short_counter_next = 0;\n                end\n\n                if (long_counter_reg > KEEP_WIDTH) begin\n                    long_counter_next = long_counter_reg - KEEP_WIDTH;\n                end else begin\n                    long_counter_next = 0;\n                end\n\n                if (long_counter_reg <= word_cnt) begin\n                    output_axis_tkeep_int = ({KEEP_WIDTH{1'b1}}) >> (KEEP_WIDTH-long_counter_reg);\n                    if (input_axis_tlast) begin\n                        status_valid_next = 1;\n                        status_frame_pad_next = 0;\n                        status_frame_truncate_next = word_cnt > long_counter_reg;\n                        status_frame_length_next = length_max;\n                        status_frame_original_length_next = frame_ptr_reg+word_cnt;\n                        input_axis_tready_next = output_axis_tready_int_early & status_ready;\n                        frame_ptr_next = 0;\n                        short_counter_next = length_min;\n                        long_counter_next = length_max;\n                        state_next = STATE_IDLE;\n                    end else begin\n                        output_axis_tvalid_int = 0;\n                        store_last_word = 1;\n                        state_next = STATE_TRUNCATE;\n                    end\n                end else begin\n                    if (input_axis_tlast) begin\n                        status_frame_original_length_next = frame_ptr_reg+word_cnt;\n                        if (short_counter_reg > word_cnt) begin\n                            if (short_counter_reg > KEEP_WIDTH) begin\n                                frame_ptr_next = frame_ptr_reg + KEEP_WIDTH;\n                                input_axis_tready_next = 0;\n                                output_axis_tkeep_int = {KEEP_WIDTH{1'b1}};\n                                output_axis_tlast_int = 0;\n                                output_axis_tuser_int = 0;\n                                last_cycle_tuser_next = input_axis_tuser;\n                                state_next = STATE_PAD;\n                            end else begin\n                                status_valid_next = 1;\n                                status_frame_pad_next = 1;\n                                status_frame_truncate_next = 0;\n                                status_frame_length_next = length_min;\n                                input_axis_tready_next = output_axis_tready_int_early & status_ready;\n                                output_axis_tkeep_int = ({KEEP_WIDTH{1'b1}}) >> (KEEP_WIDTH-short_counter_reg);\n                                frame_ptr_next = 0;\n                                short_counter_next = length_min;\n                                long_counter_next = length_max;\n                                state_next = STATE_IDLE;\n                            end\n                        end else begin\n                            status_valid_next = 1;\n                            status_frame_pad_next = 0;\n                            status_frame_truncate_next = 0;\n                            status_frame_length_next = frame_ptr_reg+word_cnt;\n                            status_frame_original_length_next = frame_ptr_reg+word_cnt;\n                            input_axis_tready_next = output_axis_tready_int_early & status_ready;\n                            frame_ptr_next = 0;\n                            short_counter_next = length_min;\n                            long_counter_next = length_max;\n                            state_next = STATE_IDLE;\n                        end\n                    end else begin\n                        state_next = STATE_TRANSFER;\n                    end\n                end\n            end else begin\n                state_next = STATE_TRANSFER;\n            end\n        end\n        STATE_PAD: begin\n            // pad to minimum length\n            input_axis_tready_next = 0;\n\n            output_axis_tdata_int = 0;\n            output_axis_tkeep_int = {KEEP_WIDTH{1'b1}};\n            output_axis_tvalid_int = 1;\n            output_axis_tlast_int = 0;\n            output_axis_tuser_int = 0;\n\n            if (output_axis_tready_int) begin\n                frame_ptr_next = frame_ptr_reg + KEEP_WIDTH;\n\n                if (short_counter_reg > KEEP_WIDTH) begin\n                    short_counter_next = short_counter_reg - KEEP_WIDTH;\n                end else begin\n                    short_counter_next = 0;\n                end\n\n                if (long_counter_reg > KEEP_WIDTH) begin\n                    long_counter_next = long_counter_reg - KEEP_WIDTH;\n                end else begin\n                    long_counter_next = 0;\n                end\n\n                if (short_counter_reg <= KEEP_WIDTH) begin\n                    status_valid_next = 1;\n                    status_frame_pad_next = 1;\n                    status_frame_truncate_next = 0;\n                    status_frame_length_next = length_min;\n                    input_axis_tready_next = output_axis_tready_int_early & status_ready;\n                    output_axis_tkeep_int = ({KEEP_WIDTH{1'b1}}) >> (KEEP_WIDTH-short_counter_reg);\n                    output_axis_tlast_int = 1;\n                    output_axis_tuser_int = last_cycle_tuser_reg;\n                    frame_ptr_next = 0;\n                    short_counter_next = length_min;\n                    long_counter_next = length_max;\n                    state_next = STATE_IDLE;\n                end else begin\n                    state_next = STATE_PAD;\n                end\n            end else begin\n                state_next = STATE_PAD;\n            end\n        end\n        STATE_TRUNCATE: begin\n            // drop after maximum length\n            input_axis_tready_next = output_axis_tready_int_early;\n\n            output_axis_tdata_int = last_word_data_reg;\n            output_axis_tkeep_int = last_word_keep_reg;\n            output_axis_tvalid_int = input_axis_tvalid & input_axis_tlast;\n            output_axis_tlast_int = input_axis_tlast;\n            output_axis_tuser_int = input_axis_tuser;\n\n            if (input_axis_tready & input_axis_tvalid) begin\n                word_cnt = 0;\n                for (i = 0; i <= KEEP_WIDTH; i = i + 1) begin\n                    //bit_cnt = bit_cnt + monitor_axis_tkeep[i];\n                    if (input_axis_tkeep == ({KEEP_WIDTH{1'b1}}) >> (KEEP_WIDTH-i)) word_cnt = i;\n                end\n                frame_ptr_next = frame_ptr_reg+KEEP_WIDTH;\n\n                if (input_axis_tlast) begin\n                    status_valid_next = 1;\n                    status_frame_pad_next = 0;\n                    status_frame_truncate_next = 1;\n                    status_frame_length_next = length_max;\n                    status_frame_original_length_next = frame_ptr_reg+word_cnt;\n                    input_axis_tready_next = output_axis_tready_int_early & status_ready;\n                    frame_ptr_next = 0;\n                    short_counter_next = length_min;\n                    long_counter_next = length_max;\n                    state_next = STATE_IDLE;\n                end else begin\n                    state_next = STATE_TRUNCATE;\n                end\n            end else begin\n                state_next = STATE_TRUNCATE;\n            end\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state_reg <= STATE_IDLE;\n        frame_ptr_reg <= 0;\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[141, "    store_last_word = 0;\n"], [148, "    output_axis_tdata_int = 0;\n"], [149, "    output_axis_tkeep_int = 0;\n"], [150, "    output_axis_tvalid_int = 0;\n"], [151, "    output_axis_tlast_int = 0;\n"], [152, "    output_axis_tuser_int = 0;\n"], [154, "    input_axis_tready_next = 0;\n"], [191, "                    short_counter_next = 0;\n"], [197, "                    long_counter_next = 0;\n"], [203, "                        status_valid_next = 1;\n"], [204, "                        status_frame_pad_next = 0;\n"], [209, "                        frame_ptr_next = 0;\n"], [214, "                        output_axis_tvalid_int = 0;\n"], [215, "                        store_last_word = 1;\n"], [224, "                                input_axis_tready_next = 0;\n"], [226, "                                output_axis_tlast_int = 0;\n"], [227, "                                output_axis_tuser_int = 0;\n"], [231, "                                status_valid_next = 1;\n"], [232, "                                status_frame_pad_next = 1;\n"], [233, "                                status_frame_truncate_next = 0;\n"], [237, "                                frame_ptr_next = 0;\n"], [243, "                            status_valid_next = 1;\n"], [244, "                            status_frame_pad_next = 0;\n"], [245, "                            status_frame_truncate_next = 0;\n"], [249, "                            frame_ptr_next = 0;\n"], [285, "                    short_counter_next = 0;\n"], [291, "                    long_counter_next = 0;\n"], [297, "                        status_valid_next = 1;\n"], [298, "                        status_frame_pad_next = 0;\n"], [303, "                        frame_ptr_next = 0;\n"], [308, "                        output_axis_tvalid_int = 0;\n"], [309, "                        store_last_word = 1;\n"], [318, "                                input_axis_tready_next = 0;\n"], [320, "                                output_axis_tlast_int = 0;\n"], [321, "                                output_axis_tuser_int = 0;\n"], [325, "                                status_valid_next = 1;\n"], [326, "                                status_frame_pad_next = 1;\n"], [327, "                                status_frame_truncate_next = 0;\n"], [331, "                                frame_ptr_next = 0;\n"], [337, "                            status_valid_next = 1;\n"], [338, "                            status_frame_pad_next = 0;\n"], [339, "                            status_frame_truncate_next = 0;\n"], [343, "                            frame_ptr_next = 0;\n"], [358, "            input_axis_tready_next = 0;\n"], [360, "            output_axis_tdata_int = 0;\n"], [362, "            output_axis_tvalid_int = 1;\n"], [363, "            output_axis_tlast_int = 0;\n"], [364, "            output_axis_tuser_int = 0;\n"], [366, "            if (output_axis_tready_int) begin\n"], [372, "                    short_counter_next = 0;\n"], [378, "                    long_counter_next = 0;\n"], [382, "                    status_valid_next = 1;\n"], [383, "                    status_frame_pad_next = 1;\n"], [384, "                    status_frame_truncate_next = 0;\n"], [388, "                    output_axis_tlast_int = 1;\n"], [390, "                    frame_ptr_next = 0;\n"], [420, "                    status_valid_next = 1;\n"], [421, "                    status_frame_pad_next = 0;\n"], [422, "                    status_frame_truncate_next = 1;\n"], [426, "                    frame_ptr_next = 0;\n"]], "Add": [[141, "    store_last_word = 1'b0;\n"], [152, "    output_axis_tdata_int = {DATA_WIDTH{1'b0}};\n"], [152, "    output_axis_tkeep_int = {KEEP_WIDTH{1'b0}};\n"], [152, "    output_axis_tvalid_int = 1'b0;\n"], [152, "    output_axis_tlast_int = 1'b0;\n"], [152, "    output_axis_tuser_int = 1'b0;\n"], [154, "    input_axis_tready_next = 1'b0;\n"], [191, "                    short_counter_next = 16'd0;\n"], [197, "                    long_counter_next = 16'd0;\n"], [204, "                        status_valid_next = 1'b1;\n"], [204, "                        status_frame_pad_next = 1'b0;\n"], [209, "                        frame_ptr_next = 16'd0;\n"], [215, "                        output_axis_tvalid_int = 1'b0;\n"], [215, "                        store_last_word = 1'b1;\n"], [224, "                                input_axis_tready_next = 1'b0;\n"], [227, "                                output_axis_tlast_int = 1'b0;\n"], [227, "                                output_axis_tuser_int = 1'b0;\n"], [233, "                                status_valid_next = 1'b1;\n"], [233, "                                status_frame_pad_next = 1'b1;\n"], [233, "                                status_frame_truncate_next = 1'b0;\n"], [237, "                                frame_ptr_next = 16'd0;\n"], [245, "                            status_valid_next = 1'b1;\n"], [245, "                            status_frame_pad_next = 1'b0;\n"], [245, "                            status_frame_truncate_next = 1'b0;\n"], [249, "                            frame_ptr_next = 16'd0;\n"], [285, "                    short_counter_next = 16'd0;\n"], [291, "                    long_counter_next = 16'd0;\n"], [298, "                        status_valid_next = 1'b1;\n"], [298, "                        status_frame_pad_next = 1'b0;\n"], [303, "                        frame_ptr_next = 16'd0;\n"], [309, "                        output_axis_tvalid_int = 1'b0;\n"], [309, "                        store_last_word = 1'b1;\n"], [318, "                                input_axis_tready_next = 1'b0;\n"], [321, "                                output_axis_tlast_int = 1'b0;\n"], [321, "                                output_axis_tuser_int = 1'b0;\n"], [327, "                                status_valid_next = 1'b1;\n"], [327, "                                status_frame_pad_next = 1'b1;\n"], [327, "                                status_frame_truncate_next = 1'b0;\n"], [331, "                                frame_ptr_next = 16'd0;\n"], [339, "                            status_valid_next = 1'b1;\n"], [339, "                            status_frame_pad_next = 1'b0;\n"], [339, "                            status_frame_truncate_next = 1'b0;\n"], [343, "                            frame_ptr_next = 16'd0;\n"], [358, "            input_axis_tready_next = 1'b0;\n"], [360, "            output_axis_tdata_int = {DATA_WIDTH{1'b0}};\n"], [364, "            output_axis_tvalid_int = 1'b1;\n"], [364, "            output_axis_tlast_int = 1'b0;\n"], [364, "            output_axis_tuser_int = 1'b0;\n"], [366, "            if (output_axis_tready_int_reg) begin\n"], [372, "                    short_counter_next = 16'd0;\n"], [378, "                    long_counter_next = 16'd0;\n"], [384, "                    status_valid_next = 1'b1;\n"], [384, "                    status_frame_pad_next = 1'b1;\n"], [384, "                    status_frame_truncate_next = 1'b0;\n"], [388, "                    output_axis_tlast_int = 1'b1;\n"], [390, "                    frame_ptr_next = 16'd0;\n"], [422, "                    status_valid_next = 1'b1;\n"], [422, "                    status_frame_pad_next = 1'b0;\n"], [422, "                    status_frame_truncate_next = 1'b1;\n"], [426, "                    frame_ptr_next = 16'd0;\n"]]}}