{"Source Block": ["verilog-ethernet/rtl/axis_mux_4.v@221:270@HdlStmProcess", "assign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        output_axis_tdata_reg <= 0;\n        output_axis_tvalid_reg <= 0;\n        output_axis_tlast_reg <= 0;\n        output_axis_tuser_reg <= 0;\n        output_axis_tready_int <= 0;\n        temp_axis_tdata_reg <= 0;\n        temp_axis_tvalid_reg <= 0;\n        temp_axis_tlast_reg <= 0;\n        temp_axis_tuser_reg <= 0;\n    end else begin\n        // transfer sink ready state to source\n        output_axis_tready_int <= output_axis_tready_int_early;\n\n        if (output_axis_tready_int) begin\n            // input is ready\n            if (output_axis_tready | ~output_axis_tvalid_reg) begin\n                // output is ready or currently not valid, transfer data to output\n                output_axis_tdata_reg <= output_axis_tdata_int;\n                output_axis_tvalid_reg <= output_axis_tvalid_int;\n                output_axis_tlast_reg <= output_axis_tlast_int;\n                output_axis_tuser_reg <= output_axis_tuser_int;\n            end else begin\n                // output is not ready, store input in temp\n                temp_axis_tdata_reg <= output_axis_tdata_int;\n                temp_axis_tvalid_reg <= output_axis_tvalid_int;\n                temp_axis_tlast_reg <= output_axis_tlast_int;\n                temp_axis_tuser_reg <= output_axis_tuser_int;\n            end\n        end else if (output_axis_tready) begin\n            // input is not ready, but output is ready\n            output_axis_tdata_reg <= temp_axis_tdata_reg;\n            output_axis_tvalid_reg <= temp_axis_tvalid_reg;\n            output_axis_tlast_reg <= temp_axis_tlast_reg;\n            output_axis_tuser_reg <= temp_axis_tuser_reg;\n            temp_axis_tdata_reg <= 0;\n            temp_axis_tvalid_reg <= 0;\n            temp_axis_tlast_reg <= 0;\n            temp_axis_tuser_reg <= 0;\n        end\n    end\nend\n\nendmodule\n"], "Clone Blocks": [["verilog-ethernet/rtl/axis_demux_4.v@191:253", "assign output_3_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = current_output_tready | (~temp_axis_tvalid_reg & ~current_output_tvalid) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        output_axis_tdata_reg <= 0;\n        output_0_axis_tvalid_reg <= 0;\n        output_1_axis_tvalid_reg <= 0;\n        output_2_axis_tvalid_reg <= 0;\n        output_3_axis_tvalid_reg <= 0;\n        output_axis_tlast_reg <= 0;\n        output_axis_tuser_reg <= 0;\n        output_axis_tready_int <= 0;\n        temp_axis_tdata_reg <= 0;\n        temp_axis_tvalid_reg <= 0;\n        temp_axis_tlast_reg <= 0;\n        temp_axis_tuser_reg <= 0;\n    end else begin\n        // transfer sink ready state to source\n        output_axis_tready_int <= output_axis_tready_int_early;\n\n        if (output_axis_tready_int) begin\n            // input is ready\n            if (current_output_tready | ~current_output_tvalid) begin\n                // output is ready or currently not valid, transfer data to output\n                output_axis_tdata_reg <= output_axis_tdata_int;\n                case (select_reg)\n                    2'd0: output_0_axis_tvalid_reg <= output_axis_tvalid_int;\n                    2'd1: output_1_axis_tvalid_reg <= output_axis_tvalid_int;\n                    2'd2: output_2_axis_tvalid_reg <= output_axis_tvalid_int;\n                    2'd3: output_3_axis_tvalid_reg <= output_axis_tvalid_int;\n                endcase\n                output_axis_tlast_reg <= output_axis_tlast_int;\n                output_axis_tuser_reg <= output_axis_tuser_int;\n            end else begin\n                // output is not ready, store input in temp\n                temp_axis_tdata_reg <= output_axis_tdata_int;\n                temp_axis_tvalid_reg <= output_axis_tvalid_int;\n                temp_axis_tlast_reg <= output_axis_tlast_int;\n                temp_axis_tuser_reg <= output_axis_tuser_int;\n            end\n        end else if (current_output_tready) begin\n            // input is not ready, but output is ready\n            output_axis_tdata_reg <= temp_axis_tdata_reg;\n            case (select_reg)\n                2'd0: output_0_axis_tvalid_reg <= temp_axis_tvalid_reg;\n                2'd1: output_1_axis_tvalid_reg <= temp_axis_tvalid_reg;\n                2'd2: output_2_axis_tvalid_reg <= temp_axis_tvalid_reg;\n                2'd3: output_3_axis_tvalid_reg <= temp_axis_tvalid_reg;\n            endcase\n            output_axis_tlast_reg <= temp_axis_tlast_reg;\n            output_axis_tuser_reg <= temp_axis_tuser_reg;\n            temp_axis_tdata_reg <= 0;\n            temp_axis_tvalid_reg <= 0;\n            temp_axis_tlast_reg <= 0;\n            temp_axis_tuser_reg <= 0;\n        end\n    end\nend\n\nendmodule\n"], ["verilog-ethernet/rtl/axis_rate_limit.v@138:187", "assign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        output_axis_tdata_reg <= 0;\n        output_axis_tvalid_reg <= 0;\n        output_axis_tlast_reg <= 0;\n        output_axis_tuser_reg <= 0;\n        output_axis_tready_int <= 0;\n        temp_axis_tdata_reg <= 0;\n        temp_axis_tvalid_reg <= 0;\n        temp_axis_tlast_reg <= 0;\n        temp_axis_tuser_reg <= 0;\n    end else begin\n        // transfer sink ready state to source\n        output_axis_tready_int <= output_axis_tready_int_early;\n\n        if (output_axis_tready_int) begin\n            // input is ready\n            if (output_axis_tready | ~output_axis_tvalid_reg) begin\n                // output is ready or currently not valid, transfer data to output\n                output_axis_tdata_reg <= output_axis_tdata_int;\n                output_axis_tvalid_reg <= output_axis_tvalid_int;\n                output_axis_tlast_reg <= output_axis_tlast_int;\n                output_axis_tuser_reg <= output_axis_tuser_int;\n            end else begin\n                // output is not ready, store input in temp\n                temp_axis_tdata_reg <= output_axis_tdata_int;\n                temp_axis_tvalid_reg <= output_axis_tvalid_int;\n                temp_axis_tlast_reg <= output_axis_tlast_int;\n                temp_axis_tuser_reg <= output_axis_tuser_int;\n            end\n        end else if (output_axis_tready) begin\n            // input is not ready, but output is ready\n            output_axis_tdata_reg <= temp_axis_tdata_reg;\n            output_axis_tvalid_reg <= temp_axis_tvalid_reg;\n            output_axis_tlast_reg <= temp_axis_tlast_reg;\n            output_axis_tuser_reg <= temp_axis_tuser_reg;\n            temp_axis_tdata_reg <= 0;\n            temp_axis_tvalid_reg <= 0;\n            temp_axis_tlast_reg <= 0;\n            temp_axis_tuser_reg <= 0;\n        end\n    end\nend\n\nendmodule\n"], ["verilog-ethernet/rtl/axis_tap_64.v@196:251", "assign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        output_axis_tdata_reg <= 0;\n        output_axis_tkeep_reg <= 0;\n        output_axis_tvalid_reg <= 0;\n        output_axis_tlast_reg <= 0;\n        output_axis_tuser_reg <= 0;\n        output_axis_tready_int <= 0;\n        temp_axis_tdata_reg <= 0;\n        temp_axis_tkeep_reg <= 0;\n        temp_axis_tvalid_reg <= 0;\n        temp_axis_tlast_reg <= 0;\n        temp_axis_tuser_reg <= 0;\n    end else begin\n        // transfer sink ready state to source\n        output_axis_tready_int <= output_axis_tready_int_early;\n\n        if (output_axis_tready_int) begin\n            // input is ready\n            if (output_axis_tready | ~output_axis_tvalid_reg) begin\n                // output is ready or currently not valid, transfer data to output\n                output_axis_tdata_reg <= output_axis_tdata_int;\n                output_axis_tkeep_reg <= output_axis_tkeep_int;\n                output_axis_tvalid_reg <= output_axis_tvalid_int;\n                output_axis_tlast_reg <= output_axis_tlast_int;\n                output_axis_tuser_reg <= output_axis_tuser_int;\n            end else begin\n                // output is not ready, store input in temp\n                temp_axis_tdata_reg <= output_axis_tdata_int;\n                temp_axis_tkeep_reg <= output_axis_tkeep_int;\n                temp_axis_tvalid_reg <= output_axis_tvalid_int;\n                temp_axis_tlast_reg <= output_axis_tlast_int;\n                temp_axis_tuser_reg <= output_axis_tuser_int;\n            end\n        end else if (output_axis_tready) begin\n            // input is not ready, but output is ready\n            output_axis_tdata_reg <= temp_axis_tdata_reg;\n            output_axis_tkeep_reg <= temp_axis_tkeep_reg;\n            output_axis_tvalid_reg <= temp_axis_tvalid_reg;\n            output_axis_tlast_reg <= temp_axis_tlast_reg;\n            output_axis_tuser_reg <= temp_axis_tuser_reg;\n            temp_axis_tdata_reg <= 0;\n            temp_axis_tkeep_reg <= 0;\n            temp_axis_tvalid_reg <= 0;\n            temp_axis_tlast_reg <= 0;\n            temp_axis_tuser_reg <= 0;\n        end\n    end\nend\n\nendmodule\n"], ["verilog-ethernet/rtl/axis_frame_length_adjust.v@497:552", "assign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        output_axis_tdata_reg <= 0;\n        output_axis_tkeep_reg <= 0;\n        output_axis_tvalid_reg <= 0;\n        output_axis_tlast_reg <= 0;\n        output_axis_tuser_reg <= 0;\n        output_axis_tready_int <= 0;\n        temp_axis_tdata_reg <= 0;\n        temp_axis_tkeep_reg <= 0;\n        temp_axis_tvalid_reg <= 0;\n        temp_axis_tlast_reg <= 0;\n        temp_axis_tuser_reg <= 0;\n    end else begin\n        // transfer sink ready state to source\n        output_axis_tready_int <= output_axis_tready_int_early;\n\n        if (output_axis_tready_int) begin\n            // input is ready\n            if (output_axis_tready | ~output_axis_tvalid_reg) begin\n                // output is ready or currently not valid, transfer data to output\n                output_axis_tdata_reg <= output_axis_tdata_int;\n                output_axis_tkeep_reg <= output_axis_tkeep_int;\n                output_axis_tvalid_reg <= output_axis_tvalid_int;\n                output_axis_tlast_reg <= output_axis_tlast_int;\n                output_axis_tuser_reg <= output_axis_tuser_int;\n            end else begin\n                // output is not ready and currently valid, store input in temp\n                temp_axis_tdata_reg <= output_axis_tdata_int;\n                temp_axis_tkeep_reg <= output_axis_tkeep_int;\n                temp_axis_tvalid_reg <= output_axis_tvalid_int;\n                temp_axis_tlast_reg <= output_axis_tlast_int;\n                temp_axis_tuser_reg <= output_axis_tuser_int;\n            end\n        end else if (output_axis_tready) begin\n            // input is not ready, but output is ready\n            output_axis_tdata_reg <= temp_axis_tdata_reg;\n            output_axis_tkeep_reg <= temp_axis_tkeep_reg;\n            output_axis_tvalid_reg <= temp_axis_tvalid_reg;\n            output_axis_tlast_reg <= temp_axis_tlast_reg;\n            output_axis_tuser_reg <= temp_axis_tuser_reg;\n            temp_axis_tdata_reg <= 0;\n            temp_axis_tkeep_reg <= 0;\n            temp_axis_tvalid_reg <= 0;\n            temp_axis_tlast_reg <= 0;\n            temp_axis_tuser_reg <= 0;\n        end\n    end\nend\n\nendmodule\n"], ["verilog-ethernet/rtl/axis_adapter.v@411:466", "assign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        output_axis_tdata_reg <= 0;\n        output_axis_tkeep_reg <= 0;\n        output_axis_tvalid_reg <= 0;\n        output_axis_tlast_reg <= 0;\n        output_axis_tuser_reg <= 0;\n        output_axis_tready_int <= 0;\n        temp_axis_tdata_reg <= 0;\n        temp_axis_tkeep_reg <= 0;\n        temp_axis_tvalid_reg <= 0;\n        temp_axis_tlast_reg <= 0;\n        temp_axis_tuser_reg <= 0;\n    end else begin\n        // transfer sink ready state to source\n        output_axis_tready_int <= output_axis_tready_int_early;\n\n        if (output_axis_tready_int) begin\n            // input is ready\n            if (output_axis_tready | ~output_axis_tvalid_reg) begin\n                // output is ready or currently not valid, transfer data to output\n                output_axis_tdata_reg <= output_axis_tdata_int;\n                output_axis_tkeep_reg <= output_axis_tkeep_int;\n                output_axis_tvalid_reg <= output_axis_tvalid_int;\n                output_axis_tlast_reg <= output_axis_tlast_int;\n                output_axis_tuser_reg <= output_axis_tuser_int;\n            end else begin\n                // output is not ready and currently valid, store input in temp\n                temp_axis_tdata_reg <= output_axis_tdata_int;\n                temp_axis_tkeep_reg <= output_axis_tkeep_int;\n                temp_axis_tvalid_reg <= output_axis_tvalid_int;\n                temp_axis_tlast_reg <= output_axis_tlast_int;\n                temp_axis_tuser_reg <= output_axis_tuser_int;\n            end\n        end else if (output_axis_tready) begin\n            // input is not ready, but output is ready\n            output_axis_tdata_reg <= temp_axis_tdata_reg;\n            output_axis_tkeep_reg <= temp_axis_tkeep_reg;\n            output_axis_tvalid_reg <= temp_axis_tvalid_reg;\n            output_axis_tlast_reg <= temp_axis_tlast_reg;\n            output_axis_tuser_reg <= temp_axis_tuser_reg;\n            temp_axis_tdata_reg <= 0;\n            temp_axis_tkeep_reg <= 0;\n            temp_axis_tvalid_reg <= 0;\n            temp_axis_tlast_reg <= 0;\n            temp_axis_tuser_reg <= 0;\n        end\n    end\nend\n\nendmodule\n"], ["verilog-ethernet/rtl/axis_mux_64_4.v@237:292", "assign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        output_axis_tdata_reg <= 0;\n        output_axis_tkeep_reg <= 0;\n        output_axis_tvalid_reg <= 0;\n        output_axis_tlast_reg <= 0;\n        output_axis_tuser_reg <= 0;\n        output_axis_tready_int <= 0;\n        temp_axis_tdata_reg <= 0;\n        temp_axis_tkeep_reg <= 0;\n        temp_axis_tvalid_reg <= 0;\n        temp_axis_tlast_reg <= 0;\n        temp_axis_tuser_reg <= 0;\n    end else begin\n        // transfer sink ready state to source\n        output_axis_tready_int <= output_axis_tready_int_early;\n\n        if (output_axis_tready_int) begin\n            // input is ready\n            if (output_axis_tready | ~output_axis_tvalid_reg) begin\n                // output is ready or currently not valid, transfer data to output\n                output_axis_tdata_reg <= output_axis_tdata_int;\n                output_axis_tkeep_reg <= output_axis_tkeep_int;\n                output_axis_tvalid_reg <= output_axis_tvalid_int;\n                output_axis_tlast_reg <= output_axis_tlast_int;\n                output_axis_tuser_reg <= output_axis_tuser_int;\n            end else begin\n                // output is not ready, store input in temp\n                temp_axis_tdata_reg <= output_axis_tdata_int;\n                temp_axis_tkeep_reg <= output_axis_tkeep_int;\n                temp_axis_tvalid_reg <= output_axis_tvalid_int;\n                temp_axis_tlast_reg <= output_axis_tlast_int;\n                temp_axis_tuser_reg <= output_axis_tuser_int;\n            end\n        end else if (output_axis_tready) begin\n            // input is not ready, but output is ready\n            output_axis_tdata_reg <= temp_axis_tdata_reg;\n            output_axis_tkeep_reg <= temp_axis_tkeep_reg;\n            output_axis_tvalid_reg <= temp_axis_tvalid_reg;\n            output_axis_tlast_reg <= temp_axis_tlast_reg;\n            output_axis_tuser_reg <= temp_axis_tuser_reg;\n            temp_axis_tdata_reg <= 0;\n            temp_axis_tkeep_reg <= 0;\n            temp_axis_tvalid_reg <= 0;\n            temp_axis_tlast_reg <= 0;\n            temp_axis_tuser_reg <= 0;\n        end\n    end\nend\n\nendmodule\n"], ["verilog-ethernet/rtl/axis_tap.v@185:234", "assign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        output_axis_tdata_reg <= 0;\n        output_axis_tvalid_reg <= 0;\n        output_axis_tlast_reg <= 0;\n        output_axis_tuser_reg <= 0;\n        output_axis_tready_int <= 0;\n        temp_axis_tdata_reg <= 0;\n        temp_axis_tvalid_reg <= 0;\n        temp_axis_tlast_reg <= 0;\n        temp_axis_tuser_reg <= 0;\n    end else begin\n        // transfer sink ready state to source\n        output_axis_tready_int <= output_axis_tready_int_early;\n\n        if (output_axis_tready_int) begin\n            // input is ready\n            if (output_axis_tready | ~output_axis_tvalid_reg) begin\n                // output is ready or currently not valid, transfer data to output\n                output_axis_tdata_reg <= output_axis_tdata_int;\n                output_axis_tvalid_reg <= output_axis_tvalid_int;\n                output_axis_tlast_reg <= output_axis_tlast_int;\n                output_axis_tuser_reg <= output_axis_tuser_int;\n            end else begin\n                // output is not ready, store input in temp\n                temp_axis_tdata_reg <= output_axis_tdata_int;\n                temp_axis_tvalid_reg <= output_axis_tvalid_int;\n                temp_axis_tlast_reg <= output_axis_tlast_int;\n                temp_axis_tuser_reg <= output_axis_tuser_int;\n            end\n        end else if (output_axis_tready) begin\n            // input is not ready, but output is ready\n            output_axis_tdata_reg <= temp_axis_tdata_reg;\n            output_axis_tvalid_reg <= temp_axis_tvalid_reg;\n            output_axis_tlast_reg <= temp_axis_tlast_reg;\n            output_axis_tuser_reg <= temp_axis_tuser_reg;\n            temp_axis_tdata_reg <= 0;\n            temp_axis_tvalid_reg <= 0;\n            temp_axis_tlast_reg <= 0;\n            temp_axis_tuser_reg <= 0;\n        end\n    end\nend\n\nendmodule\n"], ["verilog-ethernet/rtl/axis_frame_join_4.v@337:386", "assign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        output_axis_tdata_reg <= 0;\n        output_axis_tvalid_reg <= 0;\n        output_axis_tlast_reg <= 0;\n        output_axis_tuser_reg <= 0;\n        output_axis_tready_int <= 0;\n        temp_axis_tdata_reg <= 0;\n        temp_axis_tvalid_reg <= 0;\n        temp_axis_tlast_reg <= 0;\n        temp_axis_tuser_reg <= 0;\n    end else begin\n        // transfer sink ready state to source\n        output_axis_tready_int <= output_axis_tready_int_early;\n\n        if (output_axis_tready_int) begin\n            // input is ready\n            if (output_axis_tready | ~output_axis_tvalid_reg) begin\n                // output is ready or currently not valid, transfer data to output\n                output_axis_tdata_reg <= output_axis_tdata_int;\n                output_axis_tvalid_reg <= output_axis_tvalid_int;\n                output_axis_tlast_reg <= output_axis_tlast_int;\n                output_axis_tuser_reg <= output_axis_tuser_int;\n            end else begin\n                // output is not ready, store input in temp\n                temp_axis_tdata_reg <= output_axis_tdata_int;\n                temp_axis_tvalid_reg <= output_axis_tvalid_int;\n                temp_axis_tlast_reg <= output_axis_tlast_int;\n                temp_axis_tuser_reg <= output_axis_tuser_int;\n            end\n        end else if (output_axis_tready) begin\n            // input is not ready, but output is ready\n            output_axis_tdata_reg <= temp_axis_tdata_reg;\n            output_axis_tvalid_reg <= temp_axis_tvalid_reg;\n            output_axis_tlast_reg <= temp_axis_tlast_reg;\n            output_axis_tuser_reg <= temp_axis_tuser_reg;\n            temp_axis_tdata_reg <= 0;\n            temp_axis_tvalid_reg <= 0;\n            temp_axis_tlast_reg <= 0;\n            temp_axis_tuser_reg <= 0;\n        end\n    end\nend\n\nendmodule\n"], ["verilog-ethernet/rtl/axis_stat_counter.v@285:334", "assign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        output_axis_tdata_reg <= 0;\n        output_axis_tvalid_reg <= 0;\n        output_axis_tlast_reg <= 0;\n        output_axis_tuser_reg <= 0;\n        output_axis_tready_int <= 0;\n        temp_axis_tdata_reg <= 0;\n        temp_axis_tvalid_reg <= 0;\n        temp_axis_tlast_reg <= 0;\n        temp_axis_tuser_reg <= 0;\n    end else begin\n        // transfer sink ready state to source\n        output_axis_tready_int <= output_axis_tready_int_early;\n\n        if (output_axis_tready_int) begin\n            // input is ready\n            if (output_axis_tready | ~output_axis_tvalid_reg) begin\n                // output is ready or currently not valid, transfer data to output\n                output_axis_tdata_reg <= output_axis_tdata_int;\n                output_axis_tvalid_reg <= output_axis_tvalid_int;\n                output_axis_tlast_reg <= output_axis_tlast_int;\n                output_axis_tuser_reg <= output_axis_tuser_int;\n            end else begin\n                // output is not ready, store input in temp\n                temp_axis_tdata_reg <= output_axis_tdata_int;\n                temp_axis_tvalid_reg <= output_axis_tvalid_int;\n                temp_axis_tlast_reg <= output_axis_tlast_int;\n                temp_axis_tuser_reg <= output_axis_tuser_int;\n            end\n        end else if (output_axis_tready) begin\n            // input is not ready, but output is ready\n            output_axis_tdata_reg <= temp_axis_tdata_reg;\n            output_axis_tvalid_reg <= temp_axis_tvalid_reg;\n            output_axis_tlast_reg <= temp_axis_tlast_reg;\n            output_axis_tuser_reg <= temp_axis_tuser_reg;\n            temp_axis_tdata_reg <= 0;\n            temp_axis_tvalid_reg <= 0;\n            temp_axis_tlast_reg <= 0;\n            temp_axis_tuser_reg <= 0;\n        end\n    end\nend\n\nendmodule\n"], ["verilog-ethernet/rtl/axis_rate_limit_64.v@146:201", "assign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        output_axis_tdata_reg <= 0;\n        output_axis_tkeep_reg <= 0;\n        output_axis_tvalid_reg <= 0;\n        output_axis_tlast_reg <= 0;\n        output_axis_tuser_reg <= 0;\n        output_axis_tready_int <= 0;\n        temp_axis_tdata_reg <= 0;\n        temp_axis_tkeep_reg <= 0;\n        temp_axis_tvalid_reg <= 0;\n        temp_axis_tlast_reg <= 0;\n        temp_axis_tuser_reg <= 0;\n    end else begin\n        // transfer sink ready state to source\n        output_axis_tready_int <= output_axis_tready_int_early;\n\n        if (output_axis_tready_int) begin\n            // input is ready\n            if (output_axis_tready | ~output_axis_tvalid_reg) begin\n                // output is ready or currently not valid, transfer data to output\n                output_axis_tdata_reg <= output_axis_tdata_int;\n                output_axis_tkeep_reg <= output_axis_tkeep_int;\n                output_axis_tvalid_reg <= output_axis_tvalid_int;\n                output_axis_tlast_reg <= output_axis_tlast_int;\n                output_axis_tuser_reg <= output_axis_tuser_int;\n            end else begin\n                // output is not ready, store input in temp\n                temp_axis_tdata_reg <= output_axis_tdata_int;\n                temp_axis_tkeep_reg <= output_axis_tkeep_int;\n                temp_axis_tvalid_reg <= output_axis_tvalid_int;\n                temp_axis_tlast_reg <= output_axis_tlast_int;\n                temp_axis_tuser_reg <= output_axis_tuser_int;\n            end\n        end else if (output_axis_tready) begin\n            // input is not ready, but output is ready\n            output_axis_tdata_reg <= temp_axis_tdata_reg;\n            output_axis_tkeep_reg <= temp_axis_tkeep_reg;\n            output_axis_tvalid_reg <= temp_axis_tvalid_reg;\n            output_axis_tlast_reg <= temp_axis_tlast_reg;\n            output_axis_tuser_reg <= temp_axis_tuser_reg;\n            temp_axis_tdata_reg <= 0;\n            temp_axis_tkeep_reg <= 0;\n            temp_axis_tvalid_reg <= 0;\n            temp_axis_tlast_reg <= 0;\n            temp_axis_tuser_reg <= 0;\n        end\n    end\nend\n\nendmodule\n"]], "Diff Content": {"Delete": [[228, "        output_axis_tdata_reg <= 0;\n"], [229, "        output_axis_tvalid_reg <= 0;\n"], [230, "        output_axis_tlast_reg <= 0;\n"], [231, "        output_axis_tuser_reg <= 0;\n"], [232, "        output_axis_tready_int <= 0;\n"], [233, "        temp_axis_tdata_reg <= 0;\n"], [234, "        temp_axis_tvalid_reg <= 0;\n"], [235, "        temp_axis_tlast_reg <= 0;\n"], [236, "        temp_axis_tuser_reg <= 0;\n"], [239, "        output_axis_tready_int <= output_axis_tready_int_early;\n"], [241, "        if (output_axis_tready_int) begin\n"], [243, "            if (output_axis_tready | ~output_axis_tvalid_reg) begin\n"], [245, "                output_axis_tdata_reg <= output_axis_tdata_int;\n"], [246, "                output_axis_tvalid_reg <= output_axis_tvalid_int;\n"], [247, "                output_axis_tlast_reg <= output_axis_tlast_int;\n"], [248, "                output_axis_tuser_reg <= output_axis_tuser_int;\n"], [249, "            end else begin\n"], [251, "                temp_axis_tdata_reg <= output_axis_tdata_int;\n"], [252, "                temp_axis_tvalid_reg <= output_axis_tvalid_int;\n"], [253, "                temp_axis_tlast_reg <= output_axis_tlast_int;\n"], [254, "                temp_axis_tuser_reg <= output_axis_tuser_int;\n"], [255, "            end\n"], [256, "        end else if (output_axis_tready) begin\n"], [258, "            output_axis_tdata_reg <= temp_axis_tdata_reg;\n"], [259, "            output_axis_tvalid_reg <= temp_axis_tvalid_reg;\n"], [260, "            output_axis_tlast_reg <= temp_axis_tlast_reg;\n"], [261, "            output_axis_tuser_reg <= temp_axis_tuser_reg;\n"], [262, "            temp_axis_tdata_reg <= 0;\n"], [263, "            temp_axis_tvalid_reg <= 0;\n"], [264, "            temp_axis_tlast_reg <= 0;\n"], [265, "            temp_axis_tuser_reg <= 0;\n"], [266, "        end\n"]], "Add": [[236, "        output_axis_tvalid_reg <= 1'b0;\n"], [236, "        output_axis_tready_int_reg <= 1'b0;\n"], [236, "        temp_axis_tvalid_reg <= 1'b0;\n"], [266, "        output_axis_tvalid_reg <= output_axis_tvalid_next;\n"], [266, "        output_axis_tready_int_reg <= output_axis_tready_int_early;\n"], [266, "        temp_axis_tvalid_reg <= temp_axis_tvalid_next;\n"], [266, "    end\n"], [266, "    if (store_axis_int_to_output) begin\n"], [266, "        output_axis_tdata_reg <= output_axis_tdata_int;\n"], [266, "        output_axis_tlast_reg <= output_axis_tlast_int;\n"], [266, "        output_axis_tuser_reg <= output_axis_tuser_int;\n"], [266, "    end else if (store_axis_temp_to_output) begin\n"], [266, "        output_axis_tdata_reg <= temp_axis_tdata_reg;\n"], [266, "        output_axis_tlast_reg <= temp_axis_tlast_reg;\n"], [266, "        output_axis_tuser_reg <= temp_axis_tuser_reg;\n"], [266, "    end\n"], [266, "    if (store_axis_int_to_temp) begin\n"], [266, "        temp_axis_tdata_reg <= output_axis_tdata_int;\n"], [266, "        temp_axis_tlast_reg <= output_axis_tlast_int;\n"], [266, "        temp_axis_tuser_reg <= output_axis_tuser_int;\n"]]}}