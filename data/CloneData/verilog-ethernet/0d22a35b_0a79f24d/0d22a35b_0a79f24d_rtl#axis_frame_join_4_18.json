{"Source Block": ["verilog-ethernet/rtl/axis_frame_join_4.v@157:297@HdlStmProcess", "    endcase\nend\n\ninteger offset, i;\n\nalways @* begin\n    state_next = 2'bz;\n\n    frame_ptr_next = frame_ptr_reg;\n    port_sel_next = port_sel_reg;\n\n    input_0_axis_tready_next = 0;\n    input_1_axis_tready_next = 0;\n    input_2_axis_tready_next = 0;\n    input_3_axis_tready_next = 0;\n\n    output_axis_tdata_int = 0;\n    output_axis_tvalid_int = 0;\n    output_axis_tlast_int = 0;\n    output_axis_tuser_int = 0;\n\n    output_tuser_next = output_tuser_reg;\n\n    case (state_reg)\n        STATE_IDLE: begin\n            // idle state - wait for data\n            frame_ptr_next = 0;\n            port_sel_next = 0;\n            output_tuser_next = 0;\n\n            if (TAG_ENABLE) begin\n                // next cycle if started will send tag, so do not enable input\n                input_0_axis_tready_next = 0;\n            end else begin\n                // next cycle if started will send data, so enable input\n                input_0_axis_tready_next = output_axis_tready_int_early;\n            end\n            \n            if (input_0_axis_tvalid) begin\n                // input 0 valid; start transferring data\n                if (TAG_ENABLE) begin\n                    // tag enabled, so transmit it\n                    if (output_axis_tready_int) begin\n                        // output is ready, so short-circuit first tag byte\n                        frame_ptr_next = 1;\n                        output_axis_tdata_int = tag[(TAG_BYTE_WIDTH-1)*8 +: 8];\n                        output_axis_tvalid_int = 1;\n                    end\n                    state_next = STATE_WRITE_TAG;\n                end else begin\n                    // tag disabled, so transmit data\n                    if (output_axis_tready_int) begin\n                        // output is ready, so short-circuit first data byte\n                        output_axis_tdata_int = input_0_axis_tdata;\n                        output_axis_tvalid_int = 1;\n                    end\n                    state_next = STATE_TRANSFER;\n                end\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_WRITE_TAG: begin\n            // write tag data\n            if (output_axis_tready_int) begin\n                // output ready, so send tag byte\n                state_next = STATE_WRITE_TAG;\n                frame_ptr_next = frame_ptr_reg + 1;\n                output_axis_tvalid_int = 1;\n\n                offset = 0;\n                if (TAG_ENABLE) begin\n                    for (i = TAG_BYTE_WIDTH-1; i >= 0; i = i - 1) begin\n                        if (frame_ptr_reg == offset) begin\n                            output_axis_tdata_int = tag[i*8 +: 8];\n                        end\n                        offset = offset + 1;\n                    end\n                end\n                if (frame_ptr_reg == offset-1) begin\n                    input_0_axis_tready_next = output_axis_tready_int_early;\n                    state_next = STATE_TRANSFER;\n                end\n            end else begin\n                state_next = STATE_WRITE_TAG;\n            end\n        end\n        STATE_TRANSFER: begin\n            // transfer input data\n\n            // set ready for current input\n            case (port_sel_reg)\n                2'd0: input_0_axis_tready_next = output_axis_tready_int_early;\n                2'd1: input_1_axis_tready_next = output_axis_tready_int_early;\n                2'd2: input_2_axis_tready_next = output_axis_tready_int_early;\n                2'd3: input_3_axis_tready_next = output_axis_tready_int_early;\n            endcase\n\n            if (input_tvalid & output_axis_tready_int) begin\n                // output ready, transfer byte\n                state_next = STATE_TRANSFER;\n                output_axis_tdata_int = input_tdata;\n                output_axis_tvalid_int = input_tvalid;\n\n                if (input_tlast) begin\n                    // last flag received, switch to next port\n                    port_sel_next = port_sel_reg + 1;\n                    // save tuser - assert tuser out if ANY tuser asserts received\n                    output_tuser_next = output_tuser_next | input_tuser;\n                    // disable input\n                    input_0_axis_tready_next = 0;\n                    input_1_axis_tready_next = 0;\n                    input_2_axis_tready_next = 0;\n                    input_3_axis_tready_next = 0;\n\n                    if (port_sel_reg == 3) begin\n                        // last port - send tlast and tuser and revert to idle\n                        output_axis_tlast_int = 1;\n                        output_axis_tuser_int = output_tuser_next;\n                        state_next = STATE_IDLE;\n                    end else begin\n                        // otherwise, disable enable next port\n                        case (port_sel_next)\n                            2'd0: input_0_axis_tready_next = output_axis_tready_int_early;\n                            2'd1: input_1_axis_tready_next = output_axis_tready_int_early;\n                            2'd2: input_2_axis_tready_next = output_axis_tready_int_early;\n                            2'd3: input_3_axis_tready_next = output_axis_tready_int_early;\n                        endcase\n                    end\n                end\n            end else begin\n                state_next = STATE_TRANSFER;\n            end \n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state_reg <= STATE_IDLE;\n        frame_ptr_reg <= 0;\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[163, "    state_next = 2'bz;\n"], [168, "    input_0_axis_tready_next = 0;\n"], [169, "    input_1_axis_tready_next = 0;\n"], [170, "    input_2_axis_tready_next = 0;\n"], [171, "    input_3_axis_tready_next = 0;\n"], [173, "    output_axis_tdata_int = 0;\n"], [174, "    output_axis_tvalid_int = 0;\n"], [175, "    output_axis_tlast_int = 0;\n"], [176, "    output_axis_tuser_int = 0;\n"], [183, "            frame_ptr_next = 0;\n"], [184, "            port_sel_next = 0;\n"], [185, "            output_tuser_next = 0;\n"], [189, "                input_0_axis_tready_next = 0;\n"], [199, "                    if (output_axis_tready_int) begin\n"], [201, "                        frame_ptr_next = 1;\n"], [203, "                        output_axis_tvalid_int = 1;\n"], [208, "                    if (output_axis_tready_int) begin\n"], [211, "                        output_axis_tvalid_int = 1;\n"], [221, "            if (output_axis_tready_int) begin\n"], [225, "                output_axis_tvalid_int = 1;\n"], [255, "            if (input_tvalid & output_axis_tready_int) begin\n"], [267, "                    input_0_axis_tready_next = 0;\n"], [268, "                    input_1_axis_tready_next = 0;\n"], [269, "                    input_2_axis_tready_next = 0;\n"], [270, "                    input_3_axis_tready_next = 0;\n"], [272, "                    if (port_sel_reg == 3) begin\n"], [274, "                        output_axis_tlast_int = 1;\n"]], "Add": [[163, "    state_next = STATE_IDLE;\n"], [171, "    input_0_axis_tready_next = 1'b0;\n"], [171, "    input_1_axis_tready_next = 1'b0;\n"], [171, "    input_2_axis_tready_next = 1'b0;\n"], [171, "    input_3_axis_tready_next = 1'b0;\n"], [176, "    output_axis_tdata_int = 8'd0;\n"], [176, "    output_axis_tvalid_int = 1'b0;\n"], [176, "    output_axis_tlast_int = 1'b0;\n"], [176, "    output_axis_tuser_int = 1'b0;\n"], [185, "            frame_ptr_next = 3'd0;\n"], [185, "            port_sel_next = 2'd0;\n"], [185, "            output_tuser_next = 1'b0;\n"], [189, "                input_0_axis_tready_next = 1'b0;\n"], [199, "                    if (output_axis_tready_int_reg) begin\n"], [201, "                        frame_ptr_next = 3'd1;\n"], [203, "                        output_axis_tvalid_int = 1'b1;\n"], [208, "                    if (output_axis_tready_int_reg) begin\n"], [211, "                        output_axis_tvalid_int = 1'b1;\n"], [221, "            if (output_axis_tready_int_reg) begin\n"], [225, "                output_axis_tvalid_int = 1'b1;\n"], [255, "            if (input_tvalid & output_axis_tready_int_reg) begin\n"], [270, "                    input_0_axis_tready_next = 1'b0;\n"], [270, "                    input_1_axis_tready_next = 1'b0;\n"], [270, "                    input_2_axis_tready_next = 1'b0;\n"], [270, "                    input_3_axis_tready_next = 1'b0;\n"], [272, "                    if (port_sel_reg == 2'd3) begin\n"], [274, "                        output_axis_tlast_int = 1'b1;\n"]]}}