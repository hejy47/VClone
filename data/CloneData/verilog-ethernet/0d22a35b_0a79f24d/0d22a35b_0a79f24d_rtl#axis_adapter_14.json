{"Source Block": ["verilog-ethernet/rtl/axis_adapter.v@120:374@HdlStmProcess", "wire                        output_axis_tready_int_early;\n\nreg input_axis_tready_reg = 0, input_axis_tready_next;\nassign input_axis_tready = input_axis_tready_reg;\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    cycle_count_next = cycle_count_reg;\n\n    temp_tdata_next = temp_tdata_reg;\n    temp_tkeep_next = temp_tkeep_reg;\n    temp_tlast_next = temp_tlast_reg;\n    temp_tuser_next = temp_tuser_reg;\n\n    output_axis_tdata_int = 0;\n    output_axis_tkeep_int = 0;\n    output_axis_tvalid_int = 0;\n    output_axis_tlast_int = 0;\n    output_axis_tuser_int = 0;\n\n    input_axis_tready_next = 0;\n\n    case (state_reg)\n        STATE_IDLE: begin\n            // idle state - no data in registers\n            if (CYCLE_COUNT == 1) begin\n                // output and input same width - just act like a register\n\n                // accept data next cycle if output register ready next cycle\n                input_axis_tready_next = output_axis_tready_int_early;\n\n                // transfer through\n                output_axis_tdata_int = input_axis_tdata;\n                output_axis_tkeep_int = input_axis_tkeep;\n                output_axis_tvalid_int = input_axis_tvalid;\n                output_axis_tlast_int = input_axis_tlast;\n                output_axis_tuser_int = input_axis_tuser;\n\n                state_next = STATE_IDLE;\n            end else if (EXPAND_BUS) begin\n                // output bus is wider\n\n                // accept new data\n                input_axis_tready_next = 1;\n\n                if (input_axis_tready & input_axis_tvalid) begin\n                    // word transfer in - store it in data register\n                    \n                    // pass complete input word, zero-extended to temp register\n                    temp_tdata_next = input_axis_tdata;\n                    temp_tkeep_next = input_axis_tkeep;\n                    temp_tlast_next = input_axis_tlast;\n                    temp_tuser_next = input_axis_tuser;\n\n                    // first input cycle complete\n                    cycle_count_next = 1;\n\n                    if (input_axis_tlast) begin\n                        // got last signal on first cycle, so output it\n                        input_axis_tready_next = 0;\n                        state_next = STATE_TRANSFER_OUT;\n                    end else begin\n                        // otherwise, transfer in the rest of the words\n                        input_axis_tready_next = 1;\n                        state_next = STATE_TRANSFER_IN;\n                    end\n                end else begin\n                    state_next = STATE_IDLE;\n                end\n            end else begin\n                // output bus is narrower\n\n                // accept new data\n                input_axis_tready_next = 1;\n\n                if (input_axis_tready & input_axis_tvalid) begin\n                    // word transfer in - store it in data register\n                    cycle_count_next = 0;\n\n                    // is this the last cycle?\n                    if (CYCLE_COUNT == 1) begin\n                        // last cycle by counter value\n                        last_cycle = 1;\n                    end else if (input_axis_tkeep[CYCLE_KEEP_WIDTH-1:0] != {CYCLE_KEEP_WIDTH{1'b1}}) begin\n                        // last cycle by tkeep fall in current cycle\n                        last_cycle = 1;\n                    end else if (input_axis_tkeep[(CYCLE_KEEP_WIDTH*2)-1:CYCLE_KEEP_WIDTH] == {CYCLE_KEEP_WIDTH{1'b0}}) begin\n                        // last cycle by tkeep fall at end of current cycle\n                        last_cycle = 1;\n                    end else begin\n                        last_cycle = 0;\n                    end\n\n                    // pass complete input word, zero-extended to temp register\n                    temp_tdata_next = input_axis_tdata;\n                    temp_tkeep_next = input_axis_tkeep;\n                    temp_tlast_next = input_axis_tlast;\n                    temp_tuser_next = input_axis_tuser;\n\n                    // short-circuit and get first word out the door\n                    output_axis_tdata_int = input_axis_tdata[CYCLE_DATA_WIDTH-1:0];\n                    output_axis_tkeep_int = input_axis_tkeep[CYCLE_KEEP_WIDTH-1:0];\n                    output_axis_tvalid_int = 1;\n                    output_axis_tlast_int = input_axis_tlast & last_cycle;\n                    output_axis_tuser_int = input_axis_tuser & last_cycle;\n\n                    if (output_axis_tready_int) begin\n                        // if output register is ready for first word, then move on to the next one\n                        cycle_count_next = 1;\n                    end\n\n                    if (!last_cycle || !output_axis_tready_int) begin\n                        // continue outputting words\n                        input_axis_tready_next = 0;\n                        state_next = STATE_TRANSFER_OUT;\n                    end else begin\n                        state_next = STATE_IDLE;\n                    end\n                end else begin\n                    state_next = STATE_IDLE;\n                end\n            end\n        end\n        STATE_TRANSFER_IN: begin\n            // transfer word to temp registers\n            // only used when output is wider\n\n            // accept new data\n            input_axis_tready_next = 1;\n\n            if (input_axis_tready & input_axis_tvalid) begin\n                // word transfer in - store in data register\n                \n                temp_tdata_next[cycle_count_reg*CYCLE_DATA_WIDTH +: CYCLE_DATA_WIDTH] = input_axis_tdata;\n                temp_tkeep_next[cycle_count_reg*CYCLE_KEEP_WIDTH +: CYCLE_KEEP_WIDTH] = input_axis_tkeep;\n                temp_tlast_next = input_axis_tlast;\n                temp_tuser_next = input_axis_tuser;\n\n                cycle_count_next = cycle_count_reg + 1;\n                \n                if ((cycle_count_reg == CYCLE_COUNT-1) | input_axis_tlast) begin\n                    // terminated by counter or tlast signal, output complete word\n                    // read input word next cycle if output will be ready\n                    input_axis_tready_next = output_axis_tready_int_early;\n                    state_next = STATE_TRANSFER_OUT;\n                end else begin\n                    // more words to read\n                    input_axis_tready_next = 1;\n                    state_next = STATE_TRANSFER_IN;\n                end\n            end else begin\n                state_next = STATE_TRANSFER_IN;\n            end\n        end\n        STATE_TRANSFER_OUT: begin\n            // transfer word to output registers\n\n            if (EXPAND_BUS) begin\n                // output bus is wider\n                \n                // do not accept new data\n                input_axis_tready_next = 0;\n\n                // single-cycle output of entire stored word (output wider)\n                output_axis_tdata_int = temp_tdata_reg;\n                output_axis_tkeep_int = temp_tkeep_reg;\n                output_axis_tvalid_int = 1;\n                output_axis_tlast_int = temp_tlast_reg;\n                output_axis_tuser_int = temp_tuser_reg;\n            \n                if (output_axis_tready_int) begin\n                    // word transfer out\n\n                    if (input_axis_tready & input_axis_tvalid) begin\n                        // word transfer in\n\n                        // pass complete input word, zero-extended to temp register\n                        temp_tdata_next = input_axis_tdata;\n                        temp_tkeep_next = input_axis_tkeep;\n                        temp_tlast_next = input_axis_tlast;\n                        temp_tuser_next = input_axis_tuser;\n\n                        // first input cycle complete\n                        cycle_count_next = 1;\n\n                        if (input_axis_tlast) begin\n                            // got last signal on first cycle, so output it\n                            input_axis_tready_next = 0;\n                            state_next = STATE_TRANSFER_OUT;\n                        end else begin\n                            // otherwise, transfer in the rest of the words\n                            input_axis_tready_next = 1;\n                            state_next = STATE_TRANSFER_IN;\n                        end\n                    end else begin\n                        input_axis_tready_next = 1;\n                        state_next = STATE_IDLE;\n                    end\n                end else begin\n                    state_next = STATE_TRANSFER_OUT;\n                end\n            end else begin\n                // output bus is narrower\n\n                // do not accept new data\n                input_axis_tready_next = 0;\n\n                // is this the last cycle?\n                if (cycle_count_reg == CYCLE_COUNT-1) begin\n                    // last cycle by counter value\n                    last_cycle = 1;\n                end else if (temp_tkeep_reg[cycle_count_reg*CYCLE_KEEP_WIDTH +: CYCLE_KEEP_WIDTH] != {CYCLE_KEEP_WIDTH{1'b1}}) begin\n                    // last cycle by tkeep fall in current cycle\n                    last_cycle = 1;\n                end else if (temp_tkeep_reg[(cycle_count_reg+1)*CYCLE_KEEP_WIDTH +: CYCLE_KEEP_WIDTH] == {CYCLE_KEEP_WIDTH{1'b0}}) begin\n                    // last cycle by tkeep fall at end of current cycle\n                    last_cycle = 1;\n                end else begin\n                    last_cycle = 0;\n                end\n\n                // output current part of stored word (output narrower)\n                output_axis_tdata_int = temp_tdata_reg[cycle_count_reg*CYCLE_DATA_WIDTH +: CYCLE_DATA_WIDTH];\n                output_axis_tkeep_int = temp_tkeep_reg[cycle_count_reg*CYCLE_KEEP_WIDTH +: CYCLE_KEEP_WIDTH];\n                output_axis_tvalid_int = 1;\n                output_axis_tlast_int = temp_tlast_reg & last_cycle;\n                output_axis_tuser_int = temp_tuser_reg & last_cycle;\n\n                if (output_axis_tready_int) begin\n                    // word transfer out\n\n                    cycle_count_next = cycle_count_reg + 1;\n\n                    if (last_cycle) begin\n                        // terminated by counter or tlast signal\n                        \n                        input_axis_tready_next = 1;\n                        state_next = STATE_IDLE;\n                    end else begin\n                        // more words to write\n                        state_next = STATE_TRANSFER_OUT;\n                    end\n                end else begin\n                    state_next = STATE_TRANSFER_OUT;\n                end \n            end\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state_reg <= STATE_IDLE;\n        cycle_count_reg <= 0;\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[135, "    output_axis_tdata_int = 0;\n"], [136, "    output_axis_tkeep_int = 0;\n"], [137, "    output_axis_tvalid_int = 0;\n"], [138, "    output_axis_tlast_int = 0;\n"], [139, "    output_axis_tuser_int = 0;\n"], [141, "    input_axis_tready_next = 0;\n"], [164, "                input_axis_tready_next = 1;\n"], [176, "                    cycle_count_next = 1;\n"], [180, "                        input_axis_tready_next = 0;\n"], [184, "                        input_axis_tready_next = 1;\n"], [194, "                input_axis_tready_next = 1;\n"], [198, "                    cycle_count_next = 0;\n"], [203, "                        last_cycle = 1;\n"], [206, "                        last_cycle = 1;\n"], [209, "                        last_cycle = 1;\n"], [211, "                        last_cycle = 0;\n"], [223, "                    output_axis_tvalid_int = 1;\n"], [227, "                    if (output_axis_tready_int) begin\n"], [229, "                        cycle_count_next = 1;\n"], [232, "                    if (!last_cycle || !output_axis_tready_int) begin\n"], [234, "                        input_axis_tready_next = 0;\n"], [249, "            input_axis_tready_next = 1;\n"], [268, "                    input_axis_tready_next = 1;\n"], [282, "                input_axis_tready_next = 0;\n"], [287, "                output_axis_tvalid_int = 1;\n"], [291, "                if (output_axis_tready_int) begin\n"], [304, "                        cycle_count_next = 1;\n"], [308, "                            input_axis_tready_next = 0;\n"], [312, "                            input_axis_tready_next = 1;\n"], [316, "                        input_axis_tready_next = 1;\n"], [326, "                input_axis_tready_next = 0;\n"], [331, "                    last_cycle = 1;\n"], [334, "                    last_cycle = 1;\n"], [337, "                    last_cycle = 1;\n"], [339, "                    last_cycle = 0;\n"], [345, "                output_axis_tvalid_int = 1;\n"], [349, "                if (output_axis_tready_int) begin\n"], [357, "                        input_axis_tready_next = 1;\n"]], "Add": [[139, "    output_axis_tdata_int = {OUTPUT_DATA_WIDTH{1'b0}};\n"], [139, "    output_axis_tkeep_int = {OUTPUT_KEEP_WIDTH{1'b0}};\n"], [139, "    output_axis_tvalid_int = 1'b0;\n"], [139, "    output_axis_tlast_int = 1'b0;\n"], [139, "    output_axis_tuser_int = 1'b0;\n"], [141, "    input_axis_tready_next = 1'b0;\n"], [164, "                input_axis_tready_next = 1'b1;\n"], [176, "                    cycle_count_next = 8'd1;\n"], [180, "                        input_axis_tready_next = 1'b0;\n"], [184, "                        input_axis_tready_next = 1'b1;\n"], [194, "                input_axis_tready_next = 1'b1;\n"], [198, "                    cycle_count_next = 8'd0;\n"], [203, "                        last_cycle = 1'b1;\n"], [206, "                        last_cycle = 1'b1;\n"], [209, "                        last_cycle = 1'b1;\n"], [211, "                        last_cycle = 1'b0;\n"], [223, "                    output_axis_tvalid_int = 1'b1;\n"], [227, "                    if (output_axis_tready_int_reg) begin\n"], [229, "                        cycle_count_next = 8'd1;\n"], [232, "                    if (!last_cycle || !output_axis_tready_int_reg) begin\n"], [234, "                        input_axis_tready_next = 1'b0;\n"], [249, "            input_axis_tready_next = 1'b1;\n"], [268, "                    input_axis_tready_next = 1'b1;\n"], [282, "                input_axis_tready_next = 1'b0;\n"], [287, "                output_axis_tvalid_int = 1'b1;\n"], [291, "                if (output_axis_tready_int_reg) begin\n"], [304, "                        cycle_count_next = 8'd1;\n"], [308, "                            input_axis_tready_next = 1'b0;\n"], [312, "                            input_axis_tready_next = 1'b1;\n"], [316, "                        input_axis_tready_next = 1'b1;\n"], [326, "                input_axis_tready_next = 1'b0;\n"], [331, "                    last_cycle = 1'b1;\n"], [334, "                    last_cycle = 1'b1;\n"], [337, "                    last_cycle = 1'b1;\n"], [339, "                    last_cycle = 1'b0;\n"], [345, "                output_axis_tvalid_int = 1'b1;\n"], [349, "                if (output_axis_tready_int_reg) begin\n"], [357, "                        input_axis_tready_next = 1'b1;\n"]]}}