{"Source Block": ["verilog-ethernet/rtl/axis_xgmii_tx_32.v@307:578@HdlStmProcess", "            extra_cycle = 1'b0;\n        end\n    endcase\nend\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    reset_crc = 1'b0;\n    update_crc = 1'b0;\n\n    frame_ptr_next = frame_ptr_reg;\n\n    ifg_count_next = ifg_count_reg;\n    deficit_idle_count_next = deficit_idle_count_reg;\n\n    s_axis_tready_next = 1'b0;\n\n    s_tdata_next = s_tdata_reg;\n    s_tkeep_next = s_tkeep_reg;\n\n    m_axis_ptp_ts_next = m_axis_ptp_ts_reg;\n    m_axis_ptp_ts_tag_next = m_axis_ptp_ts_tag_reg;\n    m_axis_ptp_ts_valid_next = 1'b0;\n\n    // XGMII idle\n    xgmii_txd_next = {CTRL_WIDTH{XGMII_IDLE}};\n    xgmii_txc_next = {CTRL_WIDTH{1'b1}};\n\n    start_packet_next = 1'b0;\n    error_underflow_next = 1'b0;\n\n    case (state_reg)\n        STATE_IDLE: begin\n            // idle state - wait for data\n            frame_ptr_next = 16'd4;\n            reset_crc = 1'b1;\n\n            // XGMII idle\n            xgmii_txd_next = {CTRL_WIDTH{XGMII_IDLE}};\n            xgmii_txc_next = {CTRL_WIDTH{1'b1}};\n\n            s_tdata_next = s_axis_tdata_masked;\n            s_tkeep_next = s_axis_tkeep;\n\n            if (s_axis_tvalid) begin\n                // XGMII start and preamble\n                xgmii_txd_next = {{3{ETH_PRE}}, XGMII_START};\n                xgmii_txc_next = 4'b0001;\n                s_axis_tready_next = 1'b1;\n                state_next = STATE_PREAMBLE;\n            end else begin\n                ifg_count_next = 8'd0;\n                deficit_idle_count_next = 2'd0;\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_PREAMBLE: begin\n            // send preamble\n\n            s_tdata_next = s_axis_tdata_masked;\n            s_tkeep_next = s_axis_tkeep;\n\n            xgmii_txd_next = {ETH_SFD, {3{ETH_PRE}}};\n            xgmii_txc_next = 4'b0000;\n            s_axis_tready_next = 1'b1;\n            m_axis_ptp_ts_next = ptp_ts;\n            m_axis_ptp_ts_tag_next = s_axis_tuser >> 1;\n            m_axis_ptp_ts_valid_next = 1'b1;\n            start_packet_next = 1'b1;\n            state_next = STATE_PAYLOAD;\n        end\n        STATE_PAYLOAD: begin\n            // transfer payload\n            update_crc = 1'b1;\n            s_axis_tready_next = 1'b1;\n\n            frame_ptr_next = frame_ptr_reg + 16'd4;\n\n            xgmii_txd_next = s_tdata_reg;\n            xgmii_txc_next = 4'b0000;\n\n            s_tdata_next = s_axis_tdata_masked;\n            s_tkeep_next = s_axis_tkeep;\n\n            if (s_axis_tvalid) begin\n                if (s_axis_tlast) begin\n                    frame_ptr_next = frame_ptr_reg + keep2count(s_axis_tkeep);\n                    s_axis_tready_next = 1'b0;\n                    if (s_axis_tuser[0]) begin\n                        xgmii_txd_next = {XGMII_TERM, {3{XGMII_ERROR}}};\n                        xgmii_txc_next = 4'b1111;\n                        frame_ptr_next = 16'd0;\n                        ifg_count_next = 8'd10;\n                        state_next = STATE_IFG;\n                    end else begin\n                        s_axis_tready_next = 1'b0;\n\n                        if (ENABLE_PADDING && (frame_ptr_reg < MIN_FL_NOCRC_MS || (frame_ptr_reg == MIN_FL_NOCRC_MS && keep2count(s_axis_tkeep) < MIN_FL_NOCRC_LS))) begin\n                            s_tkeep_next = 4'hf;\n                            frame_ptr_next = frame_ptr_reg + 16'd4;\n\n                            if (frame_ptr_reg < (MIN_FL_NOCRC_LS > 0 ? MIN_FL_NOCRC_MS : MIN_FL_NOCRC_MS-4)) begin\n                                state_next = STATE_PAD;\n                            end else begin\n                                s_tkeep_next = 4'hf >> ((4-MIN_FL_NOCRC_LS) % 4);\n\n                                state_next = STATE_FCS_1;\n                            end\n                        end else begin\n                            state_next = STATE_FCS_1;\n                        end\n                    end\n                end else begin\n                    state_next = STATE_PAYLOAD;\n                end\n            end else begin\n                // tvalid deassert, fail frame\n                xgmii_txd_next = {XGMII_TERM, {3{XGMII_ERROR}}};\n                xgmii_txc_next = 4'b1111;\n                frame_ptr_next = 16'd0;\n                ifg_count_next = 8'd10;\n                error_underflow_next = 1'b1;\n                state_next = STATE_WAIT_END;\n            end\n        end\n        STATE_PAD: begin\n            // pad frame to MIN_FRAME_LENGTH\n            s_axis_tready_next = 1'b0;\n\n            xgmii_txd_next = s_tdata_reg;\n            xgmii_txc_next = {CTRL_WIDTH{1'b0}};\n\n            s_tdata_next = 32'd0;\n            s_tkeep_next = 4'hf;\n\n            update_crc = 1'b1;\n            frame_ptr_next = frame_ptr_reg + 16'd4;\n\n            if (frame_ptr_reg < (MIN_FL_NOCRC_LS > 0 ? MIN_FL_NOCRC_MS : MIN_FL_NOCRC_MS-4)) begin\n                state_next = STATE_PAD;\n            end else begin\n                s_tkeep_next = 4'hf >> ((4-MIN_FL_NOCRC_LS) % 4);\n\n                state_next = STATE_FCS_1;\n            end\n        end\n        STATE_FCS_1: begin\n            // last cycle\n            s_axis_tready_next = 1'b0;\n\n            xgmii_txd_next = fcs_output_txd_0;\n            xgmii_txc_next = fcs_output_txc_0;\n\n            frame_ptr_next = 16'd0;\n\n            ifg_count_next = (ifg_delay > 8'd12 ? ifg_delay : 8'd12) - ifg_offset + deficit_idle_count_reg;\n            state_next = STATE_FCS_2;\n        end\n        STATE_FCS_2: begin\n            // last cycle\n            s_axis_tready_next = 1'b0;\n\n            xgmii_txd_next = fcs_output_txd_1;\n            xgmii_txc_next = fcs_output_txc_1;\n\n            frame_ptr_next = 16'd0;\n\n            if (extra_cycle) begin\n                state_next = STATE_FCS_3;\n            end else begin\n                state_next = STATE_IFG;\n            end\n        end\n        STATE_FCS_3: begin\n            // last cycle\n            s_axis_tready_next = 1'b0;\n\n            xgmii_txd_next = {{3{XGMII_IDLE}}, XGMII_TERM};\n            xgmii_txc_next = 4'b1111;\n\n            reset_crc = 1'b1;\n            frame_ptr_next = 16'd0;\n\n            if (ENABLE_DIC) begin\n                if (ifg_count_next > 8'd3) begin\n                    state_next = STATE_IFG;\n                end else begin\n                    deficit_idle_count_next = ifg_count_next;\n                    ifg_count_next = 8'd0;\n                    s_axis_tready_next = 1'b1;\n                    state_next = STATE_IDLE;\n                end\n            end else begin\n                if (ifg_count_next > 8'd0) begin\n                    state_next = STATE_IFG;\n                end else begin\n                    state_next = STATE_IDLE;\n                end\n            end\n        end\n        STATE_IFG: begin\n            // send IFG\n            if (ifg_count_reg > 8'd4) begin\n                ifg_count_next = ifg_count_reg - 8'd4;\n            end else begin\n                ifg_count_next = 8'd0;\n            end\n\n            reset_crc = 1'b1;\n\n            if (ENABLE_DIC) begin\n                if (ifg_count_next > 8'd3) begin\n                    state_next = STATE_IFG;\n                end else begin\n                    deficit_idle_count_next = ifg_count_next;\n                    ifg_count_next = 8'd0;\n                    state_next = STATE_IDLE;\n                end\n            end else begin\n                if (ifg_count_next > 8'd0) begin\n                    state_next = STATE_IFG;\n                end else begin\n                    state_next = STATE_IDLE;\n                end\n            end\n        end\n        STATE_WAIT_END: begin\n            // wait for end of frame\n            s_axis_tready_next = 1'b1;\n\n            if (ifg_count_reg > 8'd4) begin\n                ifg_count_next = ifg_count_reg - 8'd4;\n            end else begin\n                ifg_count_next = 8'd0;\n            end\n\n            reset_crc = 1'b1;\n\n            if (s_axis_tvalid) begin\n                if (s_axis_tlast) begin\n                    s_axis_tready_next = 1'b0;\n\n                    if (ENABLE_DIC) begin\n                        if (ifg_count_next > 8'd3) begin\n                            state_next = STATE_IFG;\n                        end else begin\n                            deficit_idle_count_next = ifg_count_next;\n                            ifg_count_next = 8'd0;\n                            state_next = STATE_IDLE;\n                        end\n                    end else begin\n                        if (ifg_count_next > 8'd0) begin\n                            state_next = STATE_IFG;\n                        end else begin\n                            state_next = STATE_IDLE;\n                        end\n                    end\n                end else begin\n                    state_next = STATE_WAIT_END;\n                end\n            end else begin\n                state_next = STATE_WAIT_END;\n            end\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    state_reg <= state_next;\n\n    frame_ptr_reg <= frame_ptr_next;\n"], "Clone Blocks": [["verilog-ethernet/rtl/axis_baser_tx_64.v@474:772", "            extra_cycle = 1'b1;\n        end\n    endcase\nend\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    reset_crc = 1'b0;\n    update_crc = 1'b0;\n\n    swap_lanes = 1'b0;\n    unswap_lanes = 1'b0;\n\n    frame_ptr_next = frame_ptr_reg;\n\n    ifg_count_next = ifg_count_reg;\n    deficit_idle_count_next = deficit_idle_count_reg;\n\n    s_axis_tready_next = 1'b0;\n\n    s_tdata_next = s_tdata_reg;\n    s_tkeep_next = s_tkeep_reg;\n\n    m_axis_ptp_ts_next = m_axis_ptp_ts_reg;\n    m_axis_ptp_ts_tag_next = m_axis_ptp_ts_tag_reg;\n    m_axis_ptp_ts_valid_next = 1'b0;\n    m_axis_ptp_ts_valid_int_next = 1'b0;\n\n    output_data_next = s_tdata_reg;\n    output_type_next = OUTPUT_TYPE_IDLE;\n\n    start_packet_next = 2'b00;\n    error_underflow_next = 1'b0;\n\n    if (m_axis_ptp_ts_valid_int_reg) begin\n        m_axis_ptp_ts_valid_next = 1'b1;\n        if (PTP_TS_WIDTH == 96 && $signed({1'b0, m_axis_ptp_ts_reg[45:16]}) - $signed(31'd1000000000) > 0) begin\n            // ns field rollover\n            m_axis_ptp_ts_next[45:16] = $signed({1'b0, m_axis_ptp_ts_reg[45:16]}) - $signed(31'd1000000000);\n            m_axis_ptp_ts_next[95:48] = m_axis_ptp_ts_reg[95:48] + 1;\n        end\n    end\n\n    case (state_reg)\n        STATE_IDLE: begin\n            // idle state - wait for data\n            frame_ptr_next = 16'd8;\n            reset_crc = 1'b1;\n            s_axis_tready_next = 1'b1;\n\n            output_data_next = s_tdata_reg;\n            output_type_next = OUTPUT_TYPE_IDLE;\n\n            s_tdata_next = s_axis_tdata_masked;\n            s_tkeep_next = s_axis_tkeep;\n\n            if (s_axis_tvalid) begin\n                // XGMII start and preamble\n                if (ifg_count_reg > 8'd0) begin\n                    // need to send more idles - swap lanes\n                    swap_lanes = 1'b1;\n                    if (PTP_TS_WIDTH == 96) begin\n                        m_axis_ptp_ts_next[45:0] = ptp_ts[45:0] + (((PTP_PERIOD_NS * 2**16 + PTP_PERIOD_FNS) * 3) >> 1);\n                        m_axis_ptp_ts_next[95:48] = ptp_ts[95:48];\n                    end else begin\n                        m_axis_ptp_ts_next = ptp_ts + (((PTP_PERIOD_NS * 2**16 + PTP_PERIOD_FNS) * 3) >> 1);\n                    end\n                    m_axis_ptp_ts_tag_next = s_axis_tuser >> 1;\n                    m_axis_ptp_ts_valid_int_next = 1'b1;\n                    start_packet_next = 2'b10;\n                end else begin\n                    // no more idles - unswap\n                    unswap_lanes = 1'b1;\n                    if (PTP_TS_WIDTH == 96) begin\n                        m_axis_ptp_ts_next[45:0] = ptp_ts[45:0] + (PTP_PERIOD_NS * 2**16 + PTP_PERIOD_FNS);\n                        m_axis_ptp_ts_next[95:48] = ptp_ts[95:48];\n                    end else begin\n                        m_axis_ptp_ts_next = ptp_ts + (PTP_PERIOD_NS * 2**16 + PTP_PERIOD_FNS);\n                    end\n                    m_axis_ptp_ts_tag_next = s_axis_tuser >> 1;\n                    m_axis_ptp_ts_valid_int_next = 1'b1;\n                    start_packet_next = 2'b01;\n                end\n                output_data_next = {ETH_SFD, {7{ETH_PRE}}};\n                output_type_next = OUTPUT_TYPE_START_0;\n                s_axis_tready_next = 1'b1;\n                state_next = STATE_PAYLOAD;\n            end else begin\n                ifg_count_next = 8'd0;\n                deficit_idle_count_next = 2'd0;\n                unswap_lanes = 1'b1;\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_PAYLOAD: begin\n            // transfer payload\n            update_crc = 1'b1;\n            s_axis_tready_next = 1'b1;\n\n            frame_ptr_next = frame_ptr_reg + 16'd8;\n\n            output_data_next = s_tdata_reg;\n            output_type_next = OUTPUT_TYPE_DATA;\n\n            s_tdata_next = s_axis_tdata_masked;\n            s_tkeep_next = s_axis_tkeep;\n\n            if (s_axis_tvalid) begin\n                if (s_axis_tlast) begin\n                    frame_ptr_next = frame_ptr_reg + keep2count(s_axis_tkeep);\n                    s_axis_tready_next = 1'b0;\n                    if (s_axis_tuser[0]) begin\n                        output_type_next = OUTPUT_TYPE_ERROR;\n                        frame_ptr_next = 16'd0;\n                        ifg_count_next = 8'd8;\n                        state_next = STATE_IFG;\n                    end else begin\n                        s_axis_tready_next = 1'b0;\n\n                        if (ENABLE_PADDING && (frame_ptr_reg < MIN_FL_NOCRC_MS || (frame_ptr_reg == MIN_FL_NOCRC_MS && keep2count(s_axis_tkeep) < MIN_FL_NOCRC_LS))) begin\n                            s_tkeep_next = 8'hff;\n                            frame_ptr_next = frame_ptr_reg + 16'd8;\n\n                            if (frame_ptr_reg < (MIN_FL_NOCRC_LS > 0 ? MIN_FL_NOCRC_MS : MIN_FL_NOCRC_MS-8)) begin\n                                state_next = STATE_PAD;\n                            end else begin\n                                s_tkeep_next = 8'hff >> ((8-MIN_FL_NOCRC_LS) % 8);\n\n                                state_next = STATE_FCS_1;\n                            end\n                        end else begin\n                            state_next = STATE_FCS_1;\n                        end\n                    end\n                end else begin\n                    state_next = STATE_PAYLOAD;\n                end\n            end else begin\n                // tvalid deassert, fail frame\n                output_type_next = OUTPUT_TYPE_ERROR;\n                frame_ptr_next = 16'd0;\n                ifg_count_next = 8'd8;\n                error_underflow_next = 1'b1;\n                state_next = STATE_WAIT_END;\n            end\n        end\n        STATE_PAD: begin\n            // pad frame to MIN_FRAME_LENGTH\n            s_axis_tready_next = 1'b0;\n\n            output_data_next = s_tdata_reg;\n            output_type_next = OUTPUT_TYPE_DATA;\n\n            s_tdata_next = 64'd0;\n            s_tkeep_next = 8'hff;\n\n            update_crc = 1'b1;\n            frame_ptr_next = frame_ptr_reg + 16'd8;\n\n            if (frame_ptr_reg < (MIN_FL_NOCRC_LS > 0 ? MIN_FL_NOCRC_MS : MIN_FL_NOCRC_MS-8)) begin\n                state_next = STATE_PAD;\n            end else begin\n                s_tkeep_next = 8'hff >> ((8-MIN_FL_NOCRC_LS) % 8);\n\n                state_next = STATE_FCS_1;\n            end\n        end\n        STATE_FCS_1: begin\n            // last cycle\n            s_axis_tready_next = 1'b0;\n\n            output_data_next = fcs_output_data_0;\n            output_type_next = fcs_output_type_0;\n\n            frame_ptr_next = 16'd0;\n\n            ifg_count_next = (ifg_delay > 8'd12 ? ifg_delay : 8'd12) - ifg_offset + (lanes_swapped ? 8'd4 : 8'd0) + deficit_idle_count_reg;\n            if (extra_cycle) begin\n                state_next = STATE_FCS_2;\n            end else begin\n                state_next = STATE_IFG;\n            end\n        end\n        STATE_FCS_2: begin\n            // last cycle\n            s_axis_tready_next = 1'b0;\n\n            output_data_next = fcs_output_data_1;\n            output_type_next = fcs_output_type_1;\n\n            reset_crc = 1'b1;\n            frame_ptr_next = 16'd0;\n\n            if (ENABLE_DIC) begin\n                if (ifg_count_next > 8'd7) begin\n                    state_next = STATE_IFG;\n                end else begin\n                    if (ifg_count_next >= 8'd4) begin\n                        deficit_idle_count_next = ifg_count_next - 8'd4;\n                    end else begin\n                        deficit_idle_count_next = ifg_count_next;\n                        ifg_count_next = 8'd0;\n                    end\n                    s_axis_tready_next = 1'b1;\n                    state_next = STATE_IDLE;\n                end\n            end else begin\n                if (ifg_count_next > 8'd4) begin\n                    state_next = STATE_IFG;\n                end else begin\n                    s_axis_tready_next = 1'b1;\n                    state_next = STATE_IDLE;\n                end\n            end\n        end\n        STATE_IFG: begin\n            // send IFG\n            if (ifg_count_reg > 8'd8) begin\n                ifg_count_next = ifg_count_reg - 8'd8;\n            end else begin\n                ifg_count_next = 8'd0;\n            end\n\n            reset_crc = 1'b1;\n\n            if (ENABLE_DIC) begin\n                if (ifg_count_next > 8'd7) begin\n                    state_next = STATE_IFG;\n                end else begin\n                    if (ifg_count_next >= 8'd4) begin\n                        deficit_idle_count_next = ifg_count_next - 8'd4;\n                    end else begin\n                        deficit_idle_count_next = ifg_count_next;\n                        ifg_count_next = 8'd0;\n                    end\n                    s_axis_tready_next = 1'b1;\n                    state_next = STATE_IDLE;\n                end\n            end else begin\n                if (ifg_count_next > 8'd4) begin\n                    state_next = STATE_IFG;\n                end else begin\n                    s_axis_tready_next = 1'b1;\n                    state_next = STATE_IDLE;\n                end\n            end\n        end\n        STATE_WAIT_END: begin\n            // wait for end of frame\n            s_axis_tready_next = 1'b1;\n\n            if (ifg_count_reg > 8'd4) begin\n                ifg_count_next = ifg_count_reg - 8'd4;\n            end else begin\n                ifg_count_next = 8'd0;\n            end\n\n            reset_crc = 1'b1;\n\n            if (s_axis_tvalid) begin\n                if (s_axis_tlast) begin\n                    s_axis_tready_next = 1'b0;\n\n                    if (ENABLE_DIC) begin\n                        if (ifg_count_next > 8'd7) begin\n                            state_next = STATE_IFG;\n                        end else begin\n                            if (ifg_count_next >= 8'd4) begin\n                                deficit_idle_count_next = ifg_count_next - 8'd4;\n                            end else begin\n                                deficit_idle_count_next = ifg_count_next;\n                                ifg_count_next = 8'd0;\n                            end\n                            s_axis_tready_next = 1'b1;\n                            state_next = STATE_IDLE;\n                        end\n                    end else begin\n                        if (ifg_count_next > 8'd4) begin\n                            state_next = STATE_IFG;\n                        end else begin\n                            s_axis_tready_next = 1'b1;\n                            state_next = STATE_IDLE;\n                        end\n                    end\n                end else begin\n                    state_next = STATE_WAIT_END;\n                end\n            end else begin\n                state_next = STATE_WAIT_END;\n            end\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    state_reg <= state_next;\n\n    frame_ptr_reg <= frame_ptr_next;\n"], ["verilog-ethernet/rtl/axis_xgmii_tx_64.v@419:721", "            extra_cycle = 1'b1;\n        end\n    endcase\nend\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    reset_crc = 1'b0;\n    update_crc = 1'b0;\n\n    swap_lanes = 1'b0;\n    unswap_lanes = 1'b0;\n\n    frame_ptr_next = frame_ptr_reg;\n\n    ifg_count_next = ifg_count_reg;\n    deficit_idle_count_next = deficit_idle_count_reg;\n\n    s_axis_tready_next = 1'b0;\n\n    s_tdata_next = s_tdata_reg;\n    s_tkeep_next = s_tkeep_reg;\n\n    m_axis_ptp_ts_next = m_axis_ptp_ts_reg;\n    m_axis_ptp_ts_tag_next = m_axis_ptp_ts_tag_reg;\n    m_axis_ptp_ts_valid_next = 1'b0;\n    m_axis_ptp_ts_valid_int_next = 1'b0;\n\n    // XGMII idle\n    xgmii_txd_next = {CTRL_WIDTH{XGMII_IDLE}};\n    xgmii_txc_next = {CTRL_WIDTH{1'b1}};\n\n    start_packet_next = 2'b00;\n    error_underflow_next = 1'b0;\n\n    if (m_axis_ptp_ts_valid_int_reg) begin\n        m_axis_ptp_ts_valid_next = 1'b1;\n        if (PTP_TS_WIDTH == 96 && $signed({1'b0, m_axis_ptp_ts_reg[45:16]}) - $signed(31'd1000000000) > 0) begin\n            // ns field rollover\n            m_axis_ptp_ts_next[45:16] = $signed({1'b0, m_axis_ptp_ts_reg[45:16]}) - $signed(31'd1000000000);\n            m_axis_ptp_ts_next[95:48] = m_axis_ptp_ts_reg[95:48] + 1;\n        end\n    end\n\n    case (state_reg)\n        STATE_IDLE: begin\n            // idle state - wait for data\n            frame_ptr_next = 16'd8;\n            reset_crc = 1'b1;\n            s_axis_tready_next = 1'b1;\n\n            // XGMII idle\n            xgmii_txd_next = {CTRL_WIDTH{XGMII_IDLE}};\n            xgmii_txc_next = {CTRL_WIDTH{1'b1}};\n\n            s_tdata_next = s_axis_tdata_masked;\n            s_tkeep_next = s_axis_tkeep;\n\n            if (s_axis_tvalid) begin\n                // XGMII start and preamble\n                if (ifg_count_reg > 8'd0) begin\n                    // need to send more idles - swap lanes\n                    swap_lanes = 1'b1;\n                    if (PTP_TS_WIDTH == 96) begin\n                        m_axis_ptp_ts_next[45:0] = ptp_ts[45:0] + (((PTP_PERIOD_NS * 2**16 + PTP_PERIOD_FNS) * 3) >> 1);\n                        m_axis_ptp_ts_next[95:48] = ptp_ts[95:48];\n                    end else begin\n                        m_axis_ptp_ts_next = ptp_ts + (((PTP_PERIOD_NS * 2**16 + PTP_PERIOD_FNS) * 3) >> 1);\n                    end\n                    m_axis_ptp_ts_tag_next = s_axis_tuser >> 1;\n                    m_axis_ptp_ts_valid_int_next = 1'b1;\n                    start_packet_next = 2'b10;\n                end else begin\n                    // no more idles - unswap\n                    unswap_lanes = 1'b1;\n                    if (PTP_TS_WIDTH == 96) begin\n                        m_axis_ptp_ts_next[45:0] = ptp_ts[45:0] + (PTP_PERIOD_NS * 2**16 + PTP_PERIOD_FNS);\n                        m_axis_ptp_ts_next[95:48] = ptp_ts[95:48];\n                    end else begin\n                        m_axis_ptp_ts_next = ptp_ts + (PTP_PERIOD_NS * 2**16 + PTP_PERIOD_FNS);\n                    end\n                    m_axis_ptp_ts_tag_next = s_axis_tuser >> 1;\n                    m_axis_ptp_ts_valid_int_next = 1'b1;\n                    start_packet_next = 2'b01;\n                end\n                xgmii_txd_next = {ETH_SFD, {6{ETH_PRE}}, XGMII_START};\n                xgmii_txc_next = 8'b00000001;\n                s_axis_tready_next = 1'b1;\n                state_next = STATE_PAYLOAD;\n            end else begin\n                ifg_count_next = 8'd0;\n                deficit_idle_count_next = 2'd0;\n                unswap_lanes = 1'b1;\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_PAYLOAD: begin\n            // transfer payload\n            update_crc = 1'b1;\n            s_axis_tready_next = 1'b1;\n\n            frame_ptr_next = frame_ptr_reg + 16'd8;\n\n            xgmii_txd_next = s_tdata_reg;\n            xgmii_txc_next = 8'b00000000;\n\n            s_tdata_next = s_axis_tdata_masked;\n            s_tkeep_next = s_axis_tkeep;\n\n            if (s_axis_tvalid) begin\n                if (s_axis_tlast) begin\n                    frame_ptr_next = frame_ptr_reg + keep2count(s_axis_tkeep);\n                    s_axis_tready_next = 1'b0;\n                    if (s_axis_tuser[0]) begin\n                        xgmii_txd_next = {{3{XGMII_IDLE}}, XGMII_TERM, {4{XGMII_ERROR}}};\n                        xgmii_txc_next = 8'b11111111;\n                        frame_ptr_next = 16'd0;\n                        ifg_count_next = 8'd8;\n                        state_next = STATE_IFG;\n                    end else begin\n                        s_axis_tready_next = 1'b0;\n\n                        if (ENABLE_PADDING && (frame_ptr_reg < MIN_FL_NOCRC_MS || (frame_ptr_reg == MIN_FL_NOCRC_MS && keep2count(s_axis_tkeep) < MIN_FL_NOCRC_LS))) begin\n                            s_tkeep_next = 8'hff;\n                            frame_ptr_next = frame_ptr_reg + 16'd8;\n\n                            if (frame_ptr_reg < (MIN_FL_NOCRC_LS > 0 ? MIN_FL_NOCRC_MS : MIN_FL_NOCRC_MS-8)) begin\n                                state_next = STATE_PAD;\n                            end else begin\n                                s_tkeep_next = 8'hff >> ((8-MIN_FL_NOCRC_LS) % 8);\n\n                                state_next = STATE_FCS_1;\n                            end\n                        end else begin\n                            state_next = STATE_FCS_1;\n                        end\n                    end\n                end else begin\n                    state_next = STATE_PAYLOAD;\n                end\n            end else begin\n                // tvalid deassert, fail frame\n                xgmii_txd_next = {{3{XGMII_IDLE}}, XGMII_TERM, {4{XGMII_ERROR}}};\n                xgmii_txc_next = 8'b11111111;\n                frame_ptr_next = 16'd0;\n                ifg_count_next = 8'd8;\n                error_underflow_next = 1'b1;\n                state_next = STATE_WAIT_END;\n            end\n        end\n        STATE_PAD: begin\n            // pad frame to MIN_FRAME_LENGTH\n            s_axis_tready_next = 1'b0;\n\n            xgmii_txd_next = s_tdata_reg;\n            xgmii_txc_next = {CTRL_WIDTH{1'b0}};\n\n            s_tdata_next = 64'd0;\n            s_tkeep_next = 8'hff;\n\n            update_crc = 1'b1;\n            frame_ptr_next = frame_ptr_reg + 16'd8;\n\n            if (frame_ptr_reg < (MIN_FL_NOCRC_LS > 0 ? MIN_FL_NOCRC_MS : MIN_FL_NOCRC_MS-8)) begin\n                state_next = STATE_PAD;\n            end else begin\n                s_tkeep_next = 8'hff >> ((8-MIN_FL_NOCRC_LS) % 8);\n\n                state_next = STATE_FCS_1;\n            end\n        end\n        STATE_FCS_1: begin\n            // last cycle\n            s_axis_tready_next = 1'b0;\n\n            xgmii_txd_next = fcs_output_txd_0;\n            xgmii_txc_next = fcs_output_txc_0;\n\n            frame_ptr_next = 16'd0;\n\n            ifg_count_next = (ifg_delay > 8'd12 ? ifg_delay : 8'd12) - ifg_offset + (lanes_swapped ? 8'd4 : 8'd0) + deficit_idle_count_reg;\n            if (extra_cycle) begin\n                state_next = STATE_FCS_2;\n            end else begin\n                state_next = STATE_IFG;\n            end\n        end\n        STATE_FCS_2: begin\n            // last cycle\n            s_axis_tready_next = 1'b0;\n\n            xgmii_txd_next = fcs_output_txd_1;\n            xgmii_txc_next = fcs_output_txc_1;\n\n            reset_crc = 1'b1;\n            frame_ptr_next = 16'd0;\n\n            if (ENABLE_DIC) begin\n                if (ifg_count_next > 8'd7) begin\n                    state_next = STATE_IFG;\n                end else begin\n                    if (ifg_count_next >= 8'd4) begin\n                        deficit_idle_count_next = ifg_count_next - 8'd4;\n                    end else begin\n                        deficit_idle_count_next = ifg_count_next;\n                        ifg_count_next = 8'd0;\n                    end\n                    s_axis_tready_next = 1'b1;\n                    state_next = STATE_IDLE;\n                end\n            end else begin\n                if (ifg_count_next > 8'd4) begin\n                    state_next = STATE_IFG;\n                end else begin\n                    s_axis_tready_next = 1'b1;\n                    state_next = STATE_IDLE;\n                end\n            end\n        end\n        STATE_IFG: begin\n            // send IFG\n            if (ifg_count_reg > 8'd8) begin\n                ifg_count_next = ifg_count_reg - 8'd8;\n            end else begin\n                ifg_count_next = 8'd0;\n            end\n\n            reset_crc = 1'b1;\n\n            if (ENABLE_DIC) begin\n                if (ifg_count_next > 8'd7) begin\n                    state_next = STATE_IFG;\n                end else begin\n                    if (ifg_count_next >= 8'd4) begin\n                        deficit_idle_count_next = ifg_count_next - 8'd4;\n                    end else begin\n                        deficit_idle_count_next = ifg_count_next;\n                        ifg_count_next = 8'd0;\n                    end\n                    s_axis_tready_next = 1'b1;\n                    state_next = STATE_IDLE;\n                end\n            end else begin\n                if (ifg_count_next > 8'd4) begin\n                    state_next = STATE_IFG;\n                end else begin\n                    s_axis_tready_next = 1'b1;\n                    state_next = STATE_IDLE;\n                end\n            end\n        end\n        STATE_WAIT_END: begin\n            // wait for end of frame\n            s_axis_tready_next = 1'b1;\n\n            if (ifg_count_reg > 8'd8) begin\n                ifg_count_next = ifg_count_reg - 8'd8;\n            end else begin\n                ifg_count_next = 8'd0;\n            end\n\n            reset_crc = 1'b1;\n\n            if (s_axis_tvalid) begin\n                if (s_axis_tlast) begin\n                    s_axis_tready_next = 1'b0;\n\n                    if (ENABLE_DIC) begin\n                        if (ifg_count_next > 8'd7) begin\n                            state_next = STATE_IFG;\n                        end else begin\n                            if (ifg_count_next >= 8'd4) begin\n                                deficit_idle_count_next = ifg_count_next - 8'd4;\n                            end else begin\n                                deficit_idle_count_next = ifg_count_next;\n                                ifg_count_next = 8'd0;\n                            end\n                            s_axis_tready_next = 1'b1;\n                            state_next = STATE_IDLE;\n                        end\n                    end else begin\n                        if (ifg_count_next > 8'd4) begin\n                            state_next = STATE_IFG;\n                        end else begin\n                            s_axis_tready_next = 1'b1;\n                            state_next = STATE_IDLE;\n                        end\n                    end\n                end else begin\n                    state_next = STATE_WAIT_END;\n                end\n            end else begin\n                state_next = STATE_WAIT_END;\n            end\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    state_reg <= state_next;\n\n    frame_ptr_reg <= frame_ptr_next;\n"]], "Diff Content": {"Delete": [[373, "            m_axis_ptp_ts_next = ptp_ts;\n"], [374, "            m_axis_ptp_ts_tag_next = s_axis_tuser >> 1;\n"], [375, "            m_axis_ptp_ts_valid_next = 1'b1;\n"]], "Add": [[330, "    if (start_packet_reg) begin\n"], [330, "        m_axis_ptp_ts_next = ptp_ts;\n"], [330, "        m_axis_ptp_ts_tag_next = s_axis_tuser >> 1;\n"], [330, "        m_axis_ptp_ts_valid_next = 1'b1;\n"], [330, "    end\n"]]}}