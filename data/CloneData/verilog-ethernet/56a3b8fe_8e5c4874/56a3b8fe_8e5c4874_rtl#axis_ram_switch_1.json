{"Source Block": ["verilog-ethernet/rtl/axis_ram_switch.v@350:775@HdlStmFor", "\ngenerate\n\n    genvar m, n;\n\n    for (m = 0; m < S_COUNT; m = m + 1) begin : s_ifaces\n\n        wire [DATA_WIDTH-1:0] port_axis_tdata;\n        wire [KEEP_WIDTH-1:0] port_axis_tkeep;\n        wire                  port_axis_tvalid;\n        wire                  port_axis_tready;\n        wire                  port_axis_tlast;\n        wire [ID_WIDTH-1:0]   port_axis_tid;\n        wire [DEST_WIDTH-1:0] port_axis_tdest;\n        wire [USER_WIDTH-1:0] port_axis_tuser;\n\n        axis_adapter #(\n            .S_DATA_WIDTH(S_DATA_WIDTH),\n            .S_KEEP_ENABLE(S_KEEP_ENABLE),\n            .S_KEEP_WIDTH(S_KEEP_WIDTH),\n            .M_DATA_WIDTH(DATA_WIDTH),\n            .M_KEEP_ENABLE(1),\n            .M_KEEP_WIDTH(KEEP_WIDTH),\n            .ID_ENABLE(ID_ENABLE),\n            .ID_WIDTH(ID_WIDTH),\n            .DEST_ENABLE(1),\n            .DEST_WIDTH(DEST_WIDTH),\n            .USER_ENABLE(USER_ENABLE),\n            .USER_WIDTH(USER_WIDTH)\n        )\n        adapter_inst (\n            .clk(clk),\n            .rst(rst),\n            // AXI input\n            .s_axis_tdata(s_axis_tdata[S_DATA_WIDTH*m +: S_DATA_WIDTH]),\n            .s_axis_tkeep(s_axis_tkeep[S_KEEP_WIDTH*m +: S_KEEP_WIDTH]),\n            .s_axis_tvalid(s_axis_tvalid[m]),\n            .s_axis_tready(s_axis_tready[m]),\n            .s_axis_tlast(s_axis_tlast[m]),\n            .s_axis_tid(s_axis_tid[ID_WIDTH*m +: ID_WIDTH]),\n            .s_axis_tdest(s_axis_tdest[DEST_WIDTH*m +: DEST_WIDTH]),\n            .s_axis_tuser(s_axis_tuser[USER_WIDTH*m +: USER_WIDTH]),\n            // AXI output\n            .m_axis_tdata(port_axis_tdata),\n            .m_axis_tkeep(port_axis_tkeep),\n            .m_axis_tvalid(port_axis_tvalid),\n            .m_axis_tready(port_axis_tready),\n            .m_axis_tlast(port_axis_tlast),\n            .m_axis_tid(port_axis_tid),\n            .m_axis_tdest(port_axis_tdest),\n            .m_axis_tuser(port_axis_tuser)\n        );\n\n        // decoding\n        reg [CL_M_COUNT-1:0] select_reg = 0, select_next;\n        reg drop_reg = 1'b0, drop_next;\n        reg select_valid_reg = 1'b0, select_valid_next;\n\n        integer k;\n\n        always @* begin\n            select_next = select_reg;\n            drop_next = drop_reg && !(port_axis_tvalid && port_axis_tready && port_axis_tlast);\n            select_valid_next = select_valid_reg && !(port_axis_tvalid && port_axis_tready && port_axis_tlast);\n\n            if (port_axis_tvalid && !select_valid_reg && !drop_reg) begin\n                select_next = 1'b0;\n                select_valid_next = 1'b0;\n                drop_next = 1'b1;\n                for (k = 0; k < M_COUNT; k = k + 1) begin\n                    if (M_BASE == 0) begin\n                        // M_BASE is zero, route with $clog2(M_COUNT) MSBs of tdest as port index\n                        if (port_axis_tdest[DEST_WIDTH-CL_M_COUNT +: CL_M_COUNT] == k && (M_CONNECT & (1 << (m+k*S_COUNT)))) begin\n                            select_next = k;\n                            select_valid_next = 1'b1;\n                            drop_next = 1'b0;\n                        end\n                    end else if (M_TOP == 0) begin\n                        // M_TOP is zero, assume equal to M_BASE\n                        if (port_axis_tdest == M_BASE[k*DEST_WIDTH +: DEST_WIDTH] && (M_CONNECT & (1 << (m+k*S_COUNT)))) begin\n                            select_next = k;\n                            select_valid_next = 1'b1;\n                            drop_next = 1'b0;\n                        end\n                    end else begin\n                        if (port_axis_tdest >= M_BASE[k*DEST_WIDTH +: DEST_WIDTH] && port_axis_tdest <= M_TOP[k*DEST_WIDTH +: DEST_WIDTH] && (M_CONNECT & (1 << (m+k*S_COUNT)))) begin\n                            select_next = k;\n                            select_valid_next = 1'b1;\n                            drop_next = 1'b0;\n                        end\n                    end\n                end\n            end\n        end\n\n        always @(posedge clk) begin\n            select_reg <= select_next;\n            drop_reg <= drop_next;\n            select_valid_reg <= select_valid_next;\n\n            if (rst) begin\n                select_valid_reg <= 1'b0;\n            end\n        end\n\n        // status arbitration\n        wire [M_COUNT-1:0] request;\n        wire [M_COUNT-1:0] acknowledge;\n        wire [M_COUNT-1:0] grant;\n        wire grant_valid;\n        wire [CL_M_COUNT-1:0] grant_encoded;\n\n        arbiter #(\n            .PORTS(M_COUNT),\n            .TYPE(ARB_TYPE),\n            .BLOCK(\"ACKNOWLEDGE\"),\n            .LSB_PRIORITY(LSB_PRIORITY)\n        )\n        cmd_status_arb_inst (\n            .clk(clk),\n            .rst(rst),\n            .request(request),\n            .acknowledge(acknowledge),\n            .grant(grant),\n            .grant_valid(grant_valid),\n            .grant_encoded(grant_encoded)\n        );\n\n        // mux\n        wire [CMD_ADDR_WIDTH-1:0] cmd_status_id_mux    = int_cmd_status_id[grant_encoded*CMD_ADDR_WIDTH +: CMD_ADDR_WIDTH];\n        wire                      cmd_status_valid_mux = int_cmd_status_valid[grant_encoded*S_COUNT+m] && grant_valid;\n        wire                      cmd_status_ready_mux;\n\n        assign int_cmd_status_ready[m*M_COUNT +: M_COUNT] = (grant_valid && cmd_status_ready_mux) << grant_encoded;\n\n        for (n = 0; n < M_COUNT; n = n + 1) begin\n            assign request[n] = int_cmd_status_valid[m+n*S_COUNT] && !grant[n];\n            assign acknowledge[n] = grant[n] && int_cmd_status_valid[m+n*S_COUNT] && cmd_status_ready_mux;\n        end\n\n        reg [ADDR_WIDTH:0] wr_ptr_reg = {ADDR_WIDTH+1{1'b0}}, wr_ptr_next;\n        reg [ADDR_WIDTH:0] wr_ptr_cur_reg = {ADDR_WIDTH+1{1'b0}}, wr_ptr_cur_next;\n        reg [ADDR_WIDTH:0] rd_ptr_reg = {ADDR_WIDTH+1{1'b0}}, rd_ptr_next;\n\n        reg [ADDR_WIDTH-1:0] len_reg = {ADDR_WIDTH{1'b0}}, len_next;\n\n        // full when first MSB different but rest same\n        wire full = wr_ptr_cur_reg == (rd_ptr_reg ^ {1'b1, {ADDR_WIDTH{1'b0}}});\n        // empty when pointers match exactly\n        wire empty = wr_ptr_reg == rd_ptr_reg;\n        // overflow within packet\n        wire full_wr = wr_ptr_cur_reg == (wr_ptr_reg ^ {1'b1, {ADDR_WIDTH{1'b0}}});\n\n        reg drop_frame_reg = 1'b0, drop_frame_next;\n        reg overflow_reg = 1'b0, overflow_next;\n        reg bad_frame_reg = 1'b0, bad_frame_next;\n        reg good_frame_reg = 1'b0, good_frame_next;\n\n        reg [DATA_WIDTH-1:0] ram_wr_data_reg = {DATA_WIDTH{1'b0}}, ram_wr_data_next;\n        reg [ADDR_WIDTH-1:0] ram_wr_addr_reg = {ADDR_WIDTH{1'b0}}, ram_wr_addr_next;\n        reg                  ram_wr_en_reg = 1'b0, ram_wr_en_next;\n        wire                 ram_wr_ack;\n\n        reg [2**CMD_ADDR_WIDTH-1:0] cmd_table_active = 0;\n        reg [2**CMD_ADDR_WIDTH-1:0] cmd_table_commit = 0;\n        reg [RAM_ADDR_WIDTH+1-1:0] cmd_table_addr_start[2**CMD_ADDR_WIDTH-1:0];\n        reg [RAM_ADDR_WIDTH+1-1:0] cmd_table_addr_end[2**CMD_ADDR_WIDTH-1:0];\n        reg [ADDR_WIDTH-1:0] cmd_table_len[2**CMD_ADDR_WIDTH-1:0];\n        reg [CL_M_COUNT-1:0] cmd_table_select[2**CMD_ADDR_WIDTH-1:0];\n        reg [KEEP_WIDTH-1:0] cmd_table_tkeep[2**CMD_ADDR_WIDTH-1:0];\n        reg [ID_WIDTH-1:0] cmd_table_tid[2**CMD_ADDR_WIDTH-1:0];\n        reg [DEST_WIDTH-1:0] cmd_table_tdest[2**CMD_ADDR_WIDTH-1:0];\n        reg [USER_WIDTH-1:0] cmd_table_tuser[2**CMD_ADDR_WIDTH-1:0];\n\n        reg [CMD_ADDR_WIDTH+1-1:0] cmd_table_start_ptr_reg = 0;\n        reg [RAM_ADDR_WIDTH+1-1:0] cmd_table_start_addr_start;\n        reg [RAM_ADDR_WIDTH+1-1:0] cmd_table_start_addr_end;\n        reg [ADDR_WIDTH-1:0] cmd_table_start_len;\n        reg [CL_M_COUNT-1:0] cmd_table_start_select;\n        reg [KEEP_WIDTH-1:0] cmd_table_start_tkeep;\n        reg [ID_WIDTH-1:0] cmd_table_start_tid;\n        reg [DEST_WIDTH-1:0] cmd_table_start_tdest;\n        reg [USER_WIDTH-1:0] cmd_table_start_tuser;\n        reg cmd_table_start_en;\n        reg [CMD_ADDR_WIDTH+1-1:0] cmd_table_read_ptr_reg = 0;\n        reg cmd_table_read_en;\n        reg [CMD_ADDR_WIDTH-1:0] cmd_table_commit_ptr;\n        reg cmd_table_commit_en;\n        reg [CMD_ADDR_WIDTH+1-1:0] cmd_table_finish_ptr_reg = 0;\n        reg cmd_table_finish_en;\n\n        reg [RAM_ADDR_WIDTH-1:0] cmd_addr_reg = {RAM_ADDR_WIDTH{1'b0}}, cmd_addr_next;\n        reg [ADDR_WIDTH-1:0]     cmd_len_reg = {ADDR_WIDTH{1'b0}}, cmd_len_next;\n        reg [CMD_ADDR_WIDTH-1:0] cmd_id_reg = {CMD_ADDR_WIDTH{1'b0}}, cmd_id_next;\n        reg [KEEP_WIDTH-1:0]     cmd_tkeep_reg = {KEEP_WIDTH{1'b0}}, cmd_tkeep_next;\n        reg [ID_WIDTH-1:0]       cmd_tid_reg = {ID_WIDTH{1'b0}}, cmd_tid_next;\n        reg [DEST_WIDTH-1:0]     cmd_tdest_reg = {DEST_WIDTH{1'b0}}, cmd_tdest_next;\n        reg [USER_WIDTH-1:0]     cmd_tuser_reg = {USER_WIDTH{1'b0}}, cmd_tuser_next;\n        reg [M_COUNT-1:0]        cmd_valid_reg = 0, cmd_valid_next;\n\n        reg cmd_status_ready_reg = 1'b0, cmd_status_ready_next;\n\n        wire [M_COUNT-1:0] port_cmd_ready;\n        for (n = 0; n < M_COUNT; n = n + 1) begin\n            assign port_cmd_ready[n] = int_cmd_ready[m+n*S_COUNT];\n        end\n\n        assign port_axis_tready = (select_valid_reg && (!ram_wr_en_reg || ram_wr_ack) && (!full || full_wr || DROP_WHEN_FULL) && ($unsigned(cmd_table_start_ptr_reg - cmd_table_finish_ptr_reg) < 2**CMD_ADDR_WIDTH)) || drop_reg;\n\n        assign port_ram_wr_data[m*DATA_WIDTH +: DATA_WIDTH] = ram_wr_data_reg;\n        assign port_ram_wr_addr[m*RAM_ADDR_WIDTH +: RAM_ADDR_WIDTH] = ram_wr_addr_reg[ADDR_WIDTH-1:0] | (m << ADDR_WIDTH);\n        assign port_ram_wr_en[m] = ram_wr_en_reg;\n        assign ram_wr_ack = port_ram_wr_ack[m];\n\n        assign int_cmd_addr[m*RAM_ADDR_WIDTH +: RAM_ADDR_WIDTH] = cmd_addr_reg[ADDR_WIDTH-1:0] | (m << ADDR_WIDTH);\n        assign int_cmd_len[m*ADDR_WIDTH +: ADDR_WIDTH] = cmd_len_reg;\n        assign int_cmd_id[m*CMD_ADDR_WIDTH +: CMD_ADDR_WIDTH] = cmd_id_reg;\n        assign int_cmd_tkeep[m*KEEP_WIDTH +: KEEP_WIDTH] = cmd_tkeep_reg;\n        assign int_cmd_tid[m*ID_WIDTH +: ID_WIDTH] = cmd_tid_reg;\n        assign int_cmd_tdest[m*DEST_WIDTH +: DEST_WIDTH] = cmd_tdest_reg;\n        assign int_cmd_tuser[m*USER_WIDTH +: USER_WIDTH] = cmd_tuser_reg;\n        assign int_cmd_valid[m*M_COUNT +: M_COUNT] = cmd_valid_reg;\n\n        assign cmd_status_ready_mux = cmd_status_ready_reg;\n\n        assign status_overflow[m] = overflow_reg;\n        assign status_bad_frame[m] = bad_frame_reg;\n        assign status_good_frame[m] = good_frame_reg;\n\n        always @* begin\n            wr_ptr_next = wr_ptr_reg;\n            wr_ptr_cur_next = wr_ptr_cur_reg;\n            rd_ptr_next = rd_ptr_reg;\n\n            len_next = len_reg;\n\n            drop_frame_next = drop_frame_reg;\n            overflow_next = 1'b0;\n            bad_frame_next = 1'b0;\n            good_frame_next = 1'b0;\n\n            ram_wr_data_next = ram_wr_data_reg;\n            ram_wr_addr_next = ram_wr_addr_reg;\n            ram_wr_en_next = ram_wr_en_reg && !ram_wr_ack;\n\n            cmd_table_start_addr_start = wr_ptr_reg;\n            cmd_table_start_addr_end = wr_ptr_cur_reg + 1;\n            cmd_table_start_len = len_reg;\n            cmd_table_start_select = select_reg;\n            cmd_table_start_tkeep = S_KEEP_ENABLE ? port_axis_tkeep : 1'b1;\n            cmd_table_start_tid = port_axis_tid;\n            cmd_table_start_tdest = port_axis_tdest;\n            cmd_table_start_tuser = port_axis_tuser;\n            cmd_table_start_en = 1'b0;\n\n            cmd_table_read_en = 1'b0;\n\n            cmd_table_commit_ptr = 0;\n            cmd_table_commit_en = 1'b0;\n\n            cmd_table_finish_en = 1'b0;\n\n            cmd_addr_next = cmd_addr_reg;\n            cmd_len_next = cmd_len_reg;\n            cmd_id_next = cmd_id_reg;\n            cmd_tkeep_next = cmd_tkeep_reg;\n            cmd_tid_next = cmd_tid_reg;\n            cmd_tdest_next = cmd_tdest_reg;\n            cmd_tuser_next = cmd_tuser_reg;\n            cmd_valid_next = cmd_valid_reg;\n\n            cmd_status_ready_next = 1'b0;\n\n            // issue memory writes and commands\n            if (port_axis_tready && port_axis_tvalid && select_valid_reg && !drop_reg) begin\n                if (full || full_wr || drop_frame_reg) begin\n                    // full, packet overflow, or currently dropping frame\n                    // drop frame\n                    drop_frame_next = 1'b1;\n                    if (port_axis_tlast) begin\n                        // end of frame, reset write pointer\n                        wr_ptr_cur_next = wr_ptr_reg;\n                        drop_frame_next = 1'b0;\n                        overflow_next = 1'b1;\n                    end\n                end else begin\n                    wr_ptr_cur_next = wr_ptr_cur_reg + 1;\n                    len_next = len_reg + 1;\n\n                    // issue write operation\n                    ram_wr_data_next = port_axis_tdata;\n                    ram_wr_addr_next = wr_ptr_cur_reg;\n                    ram_wr_en_next = 1'b1;\n\n                    if (port_axis_tlast) begin\n                        // end of frame\n                        len_next = 0;\n                        if (DROP_BAD_FRAME && USER_BAD_FRAME_MASK & ~(port_axis_tuser ^ USER_BAD_FRAME_VALUE)) begin\n                            // bad packet, reset write pointer\n                            wr_ptr_cur_next = wr_ptr_reg;\n                            bad_frame_next = 1'b1;\n                        end else begin\n                            // good packet, update write pointer\n                            wr_ptr_next = wr_ptr_cur_reg + 1;\n                            good_frame_next = 1'b1;\n\n                            cmd_table_start_addr_start = wr_ptr_reg;\n                            cmd_table_start_addr_end = wr_ptr_cur_reg + 1;\n                            cmd_table_start_len = len_reg;\n                            cmd_table_start_select = select_reg;\n                            cmd_table_start_tkeep = S_KEEP_ENABLE ? port_axis_tkeep : 1'b1;\n                            cmd_table_start_tid = port_axis_tid;\n                            cmd_table_start_tdest = port_axis_tdest;\n                            cmd_table_start_tuser = port_axis_tuser;\n                            cmd_table_start_en = 1'b1;\n                        end\n                    end\n                end\n            end\n\n            // read\n            cmd_valid_next = cmd_valid_reg & ~port_cmd_ready;\n            if (!cmd_valid_reg && cmd_table_active[cmd_table_read_ptr_reg[CMD_ADDR_WIDTH-1:0]] && cmd_table_read_ptr_reg != cmd_table_start_ptr_reg) begin\n                cmd_table_read_en = 1'b1;\n                cmd_addr_next = cmd_table_addr_start[cmd_table_read_ptr_reg[CMD_ADDR_WIDTH-1:0]];\n                cmd_len_next = cmd_table_len[cmd_table_read_ptr_reg[CMD_ADDR_WIDTH-1:0]];\n                cmd_id_next = cmd_table_read_ptr_reg;\n                cmd_tkeep_next = cmd_table_tkeep[cmd_table_read_ptr_reg[CMD_ADDR_WIDTH-1:0]];\n                cmd_tid_next = cmd_table_tid[cmd_table_read_ptr_reg[CMD_ADDR_WIDTH-1:0]];\n                cmd_tdest_next = cmd_table_tdest[cmd_table_read_ptr_reg[CMD_ADDR_WIDTH-1:0]];\n                cmd_tuser_next = cmd_table_tuser[cmd_table_read_ptr_reg[CMD_ADDR_WIDTH-1:0]];\n                cmd_valid_next = 1 << cmd_table_select[cmd_table_read_ptr_reg[CMD_ADDR_WIDTH-1:0]];\n            end\n\n            // commit\n            if (cmd_status_valid_mux) begin\n                cmd_status_ready_next = 1'b1;\n                cmd_table_commit_ptr = cmd_status_id_mux;\n                cmd_table_commit_en = 1'b1;\n            end\n\n            // clean-up\n            if (cmd_table_active[cmd_table_finish_ptr_reg[CMD_ADDR_WIDTH-1:0]] && cmd_table_commit[cmd_table_finish_ptr_reg[CMD_ADDR_WIDTH-1:0]] && cmd_table_finish_ptr_reg != cmd_table_start_ptr_reg) begin\n                // update read pointer\n                rd_ptr_next = cmd_table_addr_end[cmd_table_finish_ptr_reg[CMD_ADDR_WIDTH-1:0]];\n                cmd_table_finish_en = 1'b1;\n            end\n        end\n\n        always @(posedge clk) begin\n            wr_ptr_reg <= wr_ptr_next;\n            wr_ptr_cur_reg <= wr_ptr_cur_next;\n            rd_ptr_reg <= rd_ptr_next;\n\n            len_reg <= len_next;\n\n            drop_frame_reg <= drop_frame_next;\n            overflow_reg <= overflow_next;\n            bad_frame_reg <= bad_frame_next;\n            good_frame_reg <= good_frame_next;\n\n            ram_wr_data_reg <= ram_wr_data_next;\n            ram_wr_addr_reg <= ram_wr_addr_next;\n            ram_wr_en_reg <= ram_wr_en_next;\n\n            cmd_addr_reg <= cmd_addr_next;\n            cmd_len_reg <= cmd_len_next;\n            cmd_id_reg <= cmd_id_next;\n            cmd_tkeep_reg <= cmd_tkeep_next;\n            cmd_tid_reg <= cmd_tid_next;\n            cmd_tdest_reg <= cmd_tdest_next;\n            cmd_tuser_reg <= cmd_tuser_next;\n            cmd_valid_reg <= cmd_valid_next;\n\n            cmd_status_ready_reg <= cmd_status_ready_next;\n\n            if (cmd_table_start_en) begin\n                cmd_table_start_ptr_reg <= cmd_table_start_ptr_reg + 1;\n                cmd_table_active[cmd_table_start_ptr_reg[CMD_ADDR_WIDTH-1:0]] <= 1'b1;\n                cmd_table_commit[cmd_table_start_ptr_reg[CMD_ADDR_WIDTH-1:0]] <= 1'b0;\n                cmd_table_addr_start[cmd_table_start_ptr_reg[CMD_ADDR_WIDTH-1:0]] <= cmd_table_start_addr_start;\n                cmd_table_addr_end[cmd_table_start_ptr_reg[CMD_ADDR_WIDTH-1:0]] <= cmd_table_start_addr_end;\n                cmd_table_len[cmd_table_start_ptr_reg[CMD_ADDR_WIDTH-1:0]] <= cmd_table_start_len;\n                cmd_table_select[cmd_table_start_ptr_reg[CMD_ADDR_WIDTH-1:0]] <= cmd_table_start_select;\n                cmd_table_tkeep[cmd_table_start_ptr_reg[CMD_ADDR_WIDTH-1:0]] <= cmd_table_start_tkeep;\n                cmd_table_tid[cmd_table_start_ptr_reg[CMD_ADDR_WIDTH-1:0]] <= cmd_table_start_tid;\n                cmd_table_tdest[cmd_table_start_ptr_reg[CMD_ADDR_WIDTH-1:0]] <= cmd_table_start_tdest;\n                cmd_table_tuser[cmd_table_start_ptr_reg[CMD_ADDR_WIDTH-1:0]] <= cmd_table_start_tuser;\n            end\n\n            if (cmd_table_read_en) begin\n                cmd_table_read_ptr_reg <= cmd_table_read_ptr_reg + 1;\n            end\n\n            if (cmd_table_commit_en) begin\n                cmd_table_commit[cmd_table_commit_ptr] <= 1'b1;\n            end\n\n            if (cmd_table_finish_en) begin\n                cmd_table_finish_ptr_reg <= cmd_table_finish_ptr_reg + 1;\n                cmd_table_active[cmd_table_finish_ptr_reg[CMD_ADDR_WIDTH-1:0]] <= 1'b1;\n            end\n\n            if (rst) begin\n                wr_ptr_reg <= {ADDR_WIDTH+1{1'b0}};\n                wr_ptr_cur_reg <= {ADDR_WIDTH+1{1'b0}};\n                rd_ptr_reg <= {ADDR_WIDTH+1{1'b0}};\n                len_reg <= {ADDR_WIDTH{1'b0}};\n                drop_frame_reg <= 1'b0;\n                overflow_reg <= 1'b0;\n                bad_frame_reg <= 1'b0;\n                good_frame_reg <= 1'b0;\n                ram_wr_en_reg <= 1'b0;\n                cmd_valid_reg <= 1'b0;\n                cmd_status_ready_reg <= 1'b0;\n                cmd_table_start_ptr_reg <= 0;\n                cmd_table_read_ptr_reg <= 0;\n                cmd_table_finish_ptr_reg <= 0;\n            end\n        end\n    end // s_ifaces\n\n    for (n = 0; n < M_COUNT; n = n + 1) begin : m_ifaces\n\n        // command arbitration\n        wire [S_COUNT-1:0] request;\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[416, "                select_next = 1'b0;\n"], [422, "                        if (port_axis_tdest[DEST_WIDTH-CL_M_COUNT +: CL_M_COUNT] == k && (M_CONNECT & (1 << (m+k*S_COUNT)))) begin\n"], [423, "                            select_next = k;\n"]], "Add": [[416, "                select_next = 0;\n"], [423, "                        if (M_COUNT == 1) begin\n"], [423, "                            select_next = 0;\n"], [425, "                        end else begin\n"], [425, "                            if (port_axis_tdest[DEST_WIDTH-CL_M_COUNT +: CL_M_COUNT] == k && (M_CONNECT & (1 << (m+k*S_COUNT)))) begin\n"], [425, "                                select_next = k;\n"], [425, "                                select_valid_next = 1'b1;\n"], [425, "                                drop_next = 1'b0;\n"], [425, "                            end\n"]]}}