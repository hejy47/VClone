{"Source Block": ["verilog-ethernet/rtl/ip_eth_tx.v@177:367@HdlStmProcess", "        t = a+b;\n        add1c16b = t[15:0] + t[16];\n    end\nendfunction\n\nalways @* begin\n    state_next = 2'bz;\n\n    input_ip_hdr_ready_next = 0;\n    input_ip_payload_tready_next = 0;\n\n    store_ip_hdr = 0;\n\n    store_last_word = 0;\n\n    frame_ptr_next = frame_ptr_reg;\n\n    hdr_sum_next = hdr_sum_reg;\n\n    output_eth_hdr_valid_next = output_eth_hdr_valid_reg & ~output_eth_hdr_ready;\n\n    error_payload_early_termination_next = 0;\n\n    output_eth_payload_tdata_int = 0;\n    output_eth_payload_tvalid_int = 0;\n    output_eth_payload_tlast_int = 0;\n    output_eth_payload_tuser_int = 0;\n\n    case (state_reg)\n        STATE_IDLE: begin\n            // idle state - wait for data\n            frame_ptr_next = 0;\n            input_ip_hdr_ready_next = ~output_eth_hdr_valid_reg;\n\n            if (input_ip_hdr_ready & input_ip_hdr_valid) begin\n                store_ip_hdr = 1;\n                input_ip_hdr_ready_next = 0;\n                output_eth_hdr_valid_next = 1;\n                if (output_eth_payload_tready_int) begin\n                    output_eth_payload_tvalid_int = 1;\n                    output_eth_payload_tdata_int = {4'd4, 4'd5}; // ip_version, ip_ihl\n                    frame_ptr_next = 1;\n                end\n                state_next = STATE_WRITE_HEADER;\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_WRITE_HEADER: begin\n            // write header\n            if (output_eth_payload_tready_int) begin\n                frame_ptr_next = frame_ptr_reg+1;\n                output_eth_payload_tvalid_int = 1;\n                state_next = STATE_WRITE_HEADER;\n                case (frame_ptr_reg)\n                    8'h00: begin\n                        output_eth_payload_tdata_int = {4'd4, 4'd5}; // ip_version, ip_ihl\n                    end\n                    8'h01: begin\n                        output_eth_payload_tdata_int = {ip_dscp_reg, ip_ecn_reg};\n                        hdr_sum_next = {4'd4, 4'd5, ip_dscp_reg, ip_ecn_reg};\n                    end\n                    8'h02: begin\n                        output_eth_payload_tdata_int = ip_length_reg[15: 8];\n                        hdr_sum_next = add1c16b(hdr_sum_reg, ip_length_reg);\n                    end\n                    8'h03: begin\n                        output_eth_payload_tdata_int = ip_length_reg[ 7: 0];\n                        hdr_sum_next = add1c16b(hdr_sum_reg, ip_identification_reg);\n                    end\n                    8'h04: begin\n                        output_eth_payload_tdata_int = ip_identification_reg[15: 8];\n                        hdr_sum_next = add1c16b(hdr_sum_reg, {ip_flags_reg, ip_fragment_offset_reg});\n                    end\n                    8'h05: begin\n                        output_eth_payload_tdata_int = ip_identification_reg[ 7: 0];\n                        hdr_sum_next = add1c16b(hdr_sum_reg, {ip_ttl_reg, ip_protocol_reg});\n                    end\n                    8'h06: begin\n                        output_eth_payload_tdata_int = {ip_flags_reg, ip_fragment_offset_reg[12:8]};\n                        hdr_sum_next = add1c16b(hdr_sum_reg, ip_source_ip_reg[31:16]);\n                    end\n                    8'h07: begin\n                        output_eth_payload_tdata_int = ip_fragment_offset_reg[ 7: 0];\n                        hdr_sum_next = add1c16b(hdr_sum_reg, ip_source_ip_reg[15:0]);\n                    end\n                    8'h08: begin\n                        output_eth_payload_tdata_int = ip_ttl_reg;\n                        hdr_sum_next = add1c16b(hdr_sum_reg, ip_dest_ip_reg[31:16]);\n                    end\n                    8'h09: begin\n                        output_eth_payload_tdata_int = ip_protocol_reg;\n                        hdr_sum_next = add1c16b(hdr_sum_reg, ip_dest_ip_reg[15:0]);\n                    end\n                    8'h0A: output_eth_payload_tdata_int = ~hdr_sum_reg[15: 8];\n                    8'h0B: output_eth_payload_tdata_int = ~hdr_sum_reg[ 7: 0];\n                    8'h0C: output_eth_payload_tdata_int = ip_source_ip_reg[31:24];\n                    8'h0D: output_eth_payload_tdata_int = ip_source_ip_reg[23:16];\n                    8'h0E: output_eth_payload_tdata_int = ip_source_ip_reg[15: 8];\n                    8'h0F: output_eth_payload_tdata_int = ip_source_ip_reg[ 7: 0];\n                    8'h10: output_eth_payload_tdata_int = ip_dest_ip_reg[31:24];\n                    8'h11: output_eth_payload_tdata_int = ip_dest_ip_reg[23:16];\n                    8'h12: output_eth_payload_tdata_int = ip_dest_ip_reg[15: 8];\n                    8'h13: begin\n                        output_eth_payload_tdata_int = ip_dest_ip_reg[ 7: 0];\n                        input_ip_payload_tready_next = output_eth_payload_tready_int_early;\n                        state_next = STATE_WRITE_PAYLOAD;\n                    end\n                endcase\n            end else begin\n                state_next = STATE_WRITE_HEADER;\n            end\n        end\n        STATE_WRITE_PAYLOAD: begin\n            // write payload\n            input_ip_payload_tready_next = output_eth_payload_tready_int_early;\n\n            output_eth_payload_tdata_int = input_ip_payload_tdata;\n            output_eth_payload_tvalid_int = input_ip_payload_tvalid;\n            output_eth_payload_tlast_int = input_ip_payload_tlast;\n            output_eth_payload_tuser_int = input_ip_payload_tuser;\n\n            if (input_ip_payload_tready & input_ip_payload_tvalid) begin\n                // word transfer through\n                frame_ptr_next = frame_ptr_reg+1;\n                if (input_ip_payload_tlast) begin\n                    if (frame_ptr_next != ip_length_reg) begin\n                        // end of frame, but length does not match\n                        output_eth_payload_tuser_int = 1;\n                        error_payload_early_termination_next = 1;\n                    end\n                    input_ip_hdr_ready_next = ~output_eth_hdr_valid_reg;\n                    input_ip_payload_tready_next = 0;\n                    state_next = STATE_IDLE;\n                end else begin\n                    if (frame_ptr_next == ip_length_reg) begin\n                        store_last_word = 1;\n                        output_eth_payload_tvalid_int = 0;\n                        state_next = STATE_WRITE_PAYLOAD_LAST;\n                    end else begin\n                        state_next = STATE_WRITE_PAYLOAD;\n                    end\n                end\n            end else begin\n                state_next = STATE_WRITE_PAYLOAD;\n            end\n        end\n        STATE_WRITE_PAYLOAD_LAST: begin\n            // read and discard until end of frame\n            input_ip_payload_tready_next = output_eth_payload_tready_int_early;\n\n            output_eth_payload_tdata_int = last_word_data_reg;\n            output_eth_payload_tvalid_int = input_ip_payload_tvalid & input_ip_payload_tlast;\n            output_eth_payload_tlast_int = input_ip_payload_tlast;\n            output_eth_payload_tuser_int = input_ip_payload_tuser;\n\n            if (input_ip_payload_tready & input_ip_payload_tvalid) begin\n                if (input_ip_payload_tlast) begin\n                    input_ip_hdr_ready_next = ~output_eth_hdr_valid_reg;\n                    input_ip_payload_tready_next = 0;\n                    state_next = STATE_IDLE;\n                end else begin\n                    state_next = STATE_WRITE_PAYLOAD_LAST;\n                end\n            end else begin\n                state_next = STATE_WRITE_PAYLOAD_LAST;\n            end\n        end\n        STATE_WAIT_LAST: begin\n            // read and discard until end of frame\n            input_ip_payload_tready_next = 1;\n\n            if (input_ip_payload_tready & input_ip_payload_tvalid) begin\n                if (input_ip_payload_tlast) begin\n                    input_ip_hdr_ready_next = ~output_eth_hdr_valid_reg;\n                    input_ip_payload_tready_next = 0;\n                    state_next = STATE_IDLE;\n                end else begin\n                    state_next = STATE_WAIT_LAST;\n                end\n            end else begin\n                state_next = STATE_WAIT_LAST;\n            end\n        end\n    endcase\nend\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state_reg <= STATE_IDLE;\n        frame_ptr_reg <= 0;\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[183, "    state_next = 2'bz;\n"]], "Add": [[183, "    state_next = STATE_IDLE;\n"]]}}