{"Source Block": ["verilog-ethernet/rtl/axis_xgmii_rx_32.v@259:385@HdlStmProcess", "        tkeep_mask = 4'b1111;\n    end\n    endcase\nend\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    reset_crc = 1'b0;\n\n    last_cycle_tkeep_next = last_cycle_tkeep_reg;\n\n    m_axis_tdata_next = {DATA_WIDTH{1'b0}};\n    m_axis_tkeep_next = {KEEP_WIDTH{1'b1}};\n    m_axis_tvalid_next = 1'b0;\n    m_axis_tlast_next = 1'b0;\n    m_axis_tuser_next = m_axis_tuser_reg;\n    m_axis_tuser_next[0] = 1'b0;\n\n    start_packet_next = 1'b0;\n    error_bad_frame_next = 1'b0;\n    error_bad_fcs_next = 1'b0;\n\n    ptp_ts_next = ptp_ts_reg;\n\n    case (state_reg)\n        STATE_IDLE: begin\n            // idle state - wait for packet\n            reset_crc = 1'b1;\n\n            if (PTP_TS_ENABLE) begin\n                m_axis_tuser_next[1 +: PTP_TS_WIDTH] = ptp_ts_reg;\n            end\n\n            if (xgmii_rxc_d2[0] && xgmii_rxd_d2[7:0] == XGMII_START) begin\n                // start condition\n                if (control_masked) begin\n                    // control or error characters in first data word\n                    m_axis_tdata_next = {DATA_WIDTH{1'b0}};\n                    m_axis_tkeep_next = 4'h1;\n                    m_axis_tvalid_next = 1'b1;\n                    m_axis_tlast_next = 1'b1;\n                    m_axis_tuser_next[0] = 1'b1;\n                    error_bad_frame_next = 1'b1;\n                    state_next = STATE_IDLE;\n                end else begin\n                    reset_crc = 1'b0;\n                    state_next = STATE_PREAMBLE;\n                end\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_PREAMBLE: begin\n            // drop preamble\n            ptp_ts_next = ptp_ts;\n            start_packet_next = 1'b1;\n            state_next = STATE_PAYLOAD;\n        end\n        STATE_PAYLOAD: begin\n            // read payload\n            m_axis_tdata_next = xgmii_rxd_d2;\n            m_axis_tkeep_next = {KEEP_WIDTH{1'b1}};\n            m_axis_tvalid_next = 1'b1;\n            m_axis_tlast_next = 1'b0;\n            m_axis_tuser_next[0] = 1'b0;\n\n            last_cycle_tkeep_next = tkeep_mask;\n\n            if (control_masked) begin\n                // control or error characters in packet\n                m_axis_tlast_next = 1'b1;\n                m_axis_tuser_next[0] = 1'b1;\n                error_bad_frame_next = 1'b1;\n                reset_crc = 1'b1;\n                state_next = STATE_IDLE;\n            end else if (detect_term) begin\n                if (detect_term[0]) begin\n                    // end this cycle\n                    reset_crc = 1'b1;\n                    m_axis_tkeep_next = 4'b1111;\n                    m_axis_tlast_next = 1'b1;\n                    if (detect_term[0] && crc_valid3_save) begin\n                        // CRC valid\n                    end else begin\n                        m_axis_tuser_next[0] = 1'b1;\n                        error_bad_frame_next = 1'b1;\n                        error_bad_fcs_next = 1'b1;\n                    end\n                    state_next = STATE_IDLE;\n                end else begin\n                    // need extra cycle\n                    state_next = STATE_LAST;\n                end\n            end else begin\n                state_next = STATE_PAYLOAD;\n            end\n        end\n        STATE_LAST: begin\n            // last cycle of packet\n            m_axis_tdata_next = xgmii_rxd_d2;\n            m_axis_tkeep_next = last_cycle_tkeep_reg;\n            m_axis_tvalid_next = 1'b1;\n            m_axis_tlast_next = 1'b1;\n            m_axis_tuser_next[0] = 1'b0;\n\n            reset_crc = 1'b1;\n\n            if ((detect_term_save[1] && crc_valid0_save) ||\n                (detect_term_save[2] && crc_valid1_save) ||\n                (detect_term_save[3] && crc_valid2_save)) begin\n                // CRC valid\n            end else begin\n                m_axis_tuser_next[0] = 1'b1;\n                error_bad_frame_next = 1'b1;\n                error_bad_fcs_next = 1'b1;\n            end\n\n            state_next = STATE_IDLE;\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    state_reg <= state_next;\n\n    m_axis_tdata_reg <= m_axis_tdata_next;\n"], "Clone Blocks": [["verilog-ethernet/rtl/axis_baser_rx_64.v@297:418", "    .state_in(crc_state),\n    .data_out(),\n    .state_out(crc_next7)\n);\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    reset_crc = 1'b0;\n    update_crc_last = 1'b0;\n\n    m_axis_tdata_next = input_data_d1;\n    m_axis_tkeep_next = 8'd0;\n    m_axis_tvalid_next = 1'b0;\n    m_axis_tlast_next = 1'b0;\n    m_axis_tuser_next = m_axis_tuser_reg;\n    m_axis_tuser_next[0] = 1'b0;\n\n    error_bad_frame_next = 1'b0;\n    error_bad_fcs_next = 1'b0;\n\n    case (state_reg)\n        STATE_IDLE: begin\n            // idle state - wait for packet\n            reset_crc = 1'b1;\n\n            if (PTP_TS_ENABLE) begin\n                m_axis_tuser_next[1 +: PTP_TS_WIDTH] = ptp_ts_reg;\n            end\n\n            if (input_type_d1 == INPUT_TYPE_START_0) begin\n                // start condition\n                reset_crc = 1'b0;\n                state_next = STATE_PAYLOAD;\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_PAYLOAD: begin\n            // read payload\n            m_axis_tdata_next = input_data_d1;\n            m_axis_tkeep_next = 8'hff;\n            m_axis_tvalid_next = 1'b1;\n            m_axis_tlast_next = 1'b0;\n            m_axis_tuser_next[0] = 1'b0;\n\n            if (input_type_d0 == INPUT_TYPE_DATA) begin\n                state_next = STATE_PAYLOAD;\n            end else if (input_type_d0[3]) begin\n                // INPUT_TYPE_TERM_*\n                if (input_type_d0 <= INPUT_TYPE_TERM_4) begin\n                    // end this cycle\n                    reset_crc = 1'b1;\n                    case (input_type_d0)\n                        INPUT_TYPE_TERM_0: m_axis_tkeep_next = 8'b00001111;\n                        INPUT_TYPE_TERM_1: m_axis_tkeep_next = 8'b00011111;\n                        INPUT_TYPE_TERM_2: m_axis_tkeep_next = 8'b00111111;\n                        INPUT_TYPE_TERM_3: m_axis_tkeep_next = 8'b01111111;\n                        INPUT_TYPE_TERM_4: m_axis_tkeep_next = 8'b11111111;\n                    endcase\n                    m_axis_tlast_next = 1'b1;\n                    if ((input_type_d0 == INPUT_TYPE_TERM_0 && crc_valid7_save) ||\n                        (input_type_d0 == INPUT_TYPE_TERM_1 && crc_valid0) ||\n                        (input_type_d0 == INPUT_TYPE_TERM_2 && crc_valid1) ||\n                        (input_type_d0 == INPUT_TYPE_TERM_3 && crc_valid2) ||\n                        (input_type_d0 == INPUT_TYPE_TERM_4 && crc_valid3)) begin\n                        // CRC valid\n                    end else begin\n                        m_axis_tuser_next[0] = 1'b1;\n                        error_bad_frame_next = 1'b1;\n                        error_bad_fcs_next = 1'b1;\n                    end\n                    state_next = STATE_IDLE;\n                end else begin\n                    // need extra cycle\n                    update_crc_last = 1'b1;\n                    state_next = STATE_LAST;\n                end\n            end else begin\n                // control or error characters in packet\n                m_axis_tlast_next = 1'b1;\n                m_axis_tuser_next[0] = 1'b1;\n                error_bad_frame_next = 1'b1;\n                reset_crc = 1'b1;\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_LAST: begin\n            // last cycle of packet\n            m_axis_tdata_next = input_data_d1;\n            m_axis_tkeep_next = 8'hff;\n            m_axis_tvalid_next = 1'b1;\n            m_axis_tlast_next = 1'b1;\n            m_axis_tuser_next[0] = 1'b0;\n\n            reset_crc = 1'b1;\n\n            case (input_type_d1)\n                INPUT_TYPE_TERM_5: m_axis_tkeep_next = 8'b00000001;\n                INPUT_TYPE_TERM_6: m_axis_tkeep_next = 8'b00000011;\n                INPUT_TYPE_TERM_7: m_axis_tkeep_next = 8'b00000111;\n            endcase\n\n            if ((input_type_d1 == INPUT_TYPE_TERM_5 && crc_valid0) ||\n                (input_type_d1 == INPUT_TYPE_TERM_6 && crc_valid1) ||\n                (input_type_d1 == INPUT_TYPE_TERM_7 && crc_valid2)) begin\n                // CRC valid\n            end else begin\n                m_axis_tuser_next[0] = 1'b1;\n                error_bad_frame_next = 1'b1;\n                error_bad_fcs_next = 1'b1;\n            end\n\n            state_next = STATE_IDLE;\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    state_reg <= state_next;\n\n    m_axis_tdata_reg <= m_axis_tdata_next;\n"], ["verilog-ethernet/rtl/axis_xgmii_rx_64.v@294:435", "        tkeep_mask = 8'b11111111;\n    end\n    endcase\nend\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    reset_crc = 1'b0;\n    update_crc_last = 1'b0;\n\n    last_cycle_tkeep_next = last_cycle_tkeep_reg;\n\n    m_axis_tdata_next = {DATA_WIDTH{1'b0}};\n    m_axis_tkeep_next = {KEEP_WIDTH{1'b1}};\n    m_axis_tvalid_next = 1'b0;\n    m_axis_tlast_next = 1'b0;\n    m_axis_tuser_next = m_axis_tuser_reg;\n    m_axis_tuser_next[0] = 1'b0;\n\n    error_bad_frame_next = 1'b0;\n    error_bad_fcs_next = 1'b0;\n\n    case (state_reg)\n        STATE_IDLE: begin\n            // idle state - wait for packet\n            reset_crc = 1'b1;\n\n            if (xgmii_rxc_d1[0] && xgmii_rxd_d1[7:0] == XGMII_START) begin\n                // start condition\n\n                if (PTP_TS_ENABLE) begin\n                    m_axis_tuser_next[1 +: PTP_TS_WIDTH] = ptp_ts_reg;\n                end\n\n                if (control_masked) begin\n                    // control or error characters in first data word\n                    m_axis_tdata_next = {DATA_WIDTH{1'b0}};\n                    m_axis_tkeep_next = 8'h01;\n                    m_axis_tvalid_next = 1'b1;\n                    m_axis_tlast_next = 1'b1;\n                    m_axis_tuser_next[0] = 1'b1;\n                    error_bad_frame_next = 1'b1;\n                    state_next = STATE_IDLE;\n                end else begin\n                    reset_crc = 1'b0;\n                    state_next = STATE_PAYLOAD;\n                end\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_PAYLOAD: begin\n            // read payload\n            m_axis_tdata_next = xgmii_rxd_d1;\n            m_axis_tkeep_next = {KEEP_WIDTH{1'b1}};\n            m_axis_tvalid_next = 1'b1;\n            m_axis_tlast_next = 1'b0;\n            m_axis_tuser_next[0] = 1'b0;\n\n            last_cycle_tkeep_next = {4'b0000, tkeep_mask[7:4]};\n\n            if (control_masked) begin\n                // control or error characters in packet\n                m_axis_tlast_next = 1'b1;\n                m_axis_tuser_next[0] = 1'b1;\n                error_bad_frame_next = 1'b1;\n                reset_crc = 1'b1;\n                state_next = STATE_IDLE;\n            end else if (detect_term) begin\n                if (detect_term[4:0]) begin\n                    // end this cycle\n                    reset_crc = 1'b1;\n                    m_axis_tkeep_next = {tkeep_mask[3:0], 4'b1111};\n                    m_axis_tlast_next = 1'b1;\n                    if ((detect_term[0] && crc_valid7_save) ||\n                        (detect_term[1] && crc_valid0) ||\n                        (detect_term[2] && crc_valid1) ||\n                        (detect_term[3] && crc_valid2) ||\n                        (detect_term[4] && crc_valid3)) begin\n                        // CRC valid\n                    end else begin\n                        m_axis_tuser_next[0] = 1'b1;\n                        error_bad_frame_next = 1'b1;\n                        error_bad_fcs_next = 1'b1;\n                    end\n                    state_next = STATE_IDLE;\n                end else begin\n                    // need extra cycle\n                    update_crc_last = 1'b1;\n                    state_next = STATE_LAST;\n                end\n            end else begin\n                state_next = STATE_PAYLOAD;\n            end\n        end\n        STATE_LAST: begin\n            // last cycle of packet\n            m_axis_tdata_next = xgmii_rxd_d1;\n            m_axis_tkeep_next = last_cycle_tkeep_reg;\n            m_axis_tvalid_next = 1'b1;\n            m_axis_tlast_next = 1'b1;\n            m_axis_tuser_next[0] = 1'b0;\n\n            reset_crc = 1'b1;\n\n            if ((detect_term_save[5] && crc_valid0) ||\n                (detect_term_save[6] && crc_valid1) ||\n                (detect_term_save[7] && crc_valid2)) begin\n                // CRC valid\n            end else begin\n                m_axis_tuser_next[0] = 1'b1;\n                error_bad_frame_next = 1'b1;\n                error_bad_fcs_next = 1'b1;\n            end\n\n            if (xgmii_rxc_d1[0] && xgmii_rxd_d1[7:0] == XGMII_START) begin\n                // start condition\n                if (control_masked) begin\n                    // control or error characters in first data word\n                    m_axis_tdata_next = {DATA_WIDTH{1'b0}};\n                    m_axis_tkeep_next = 8'h01;\n                    m_axis_tvalid_next = 1'b1;\n                    m_axis_tlast_next = 1'b1;\n                    m_axis_tuser_next[0] = 1'b1;\n                    error_bad_frame_next = 1'b1;\n                    state_next = STATE_IDLE;\n                end else begin\n                    reset_crc = 1'b0;\n                    state_next = STATE_PAYLOAD;\n                end\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    state_reg <= state_next;\n\n    m_axis_tdata_reg <= m_axis_tdata_next;\n"]], "Diff Content": {"Delete": [[282, "    ptp_ts_next = ptp_ts_reg;\n"], [289, "            if (PTP_TS_ENABLE) begin\n"], [290, "                m_axis_tuser_next[1 +: PTP_TS_WIDTH] = ptp_ts_reg;\n"], [291, "            end\n"], [314, "            ptp_ts_next = ptp_ts;\n"]], "Add": [[308, "                if (PTP_TS_ENABLE) begin\n"], [308, "                    m_axis_tuser_next[1 +: PTP_TS_WIDTH] = ptp_ts;\n"], [308, "                end\n"]]}}