{"Source Block": ["verilog-ethernet/rtl/axis_ram_switch.v@755:1068@HdlStmFor", "                cmd_table_finish_ptr_reg <= 0;\n            end\n        end\n    end // s_ifaces\n\n    for (n = 0; n < M_COUNT; n = n + 1) begin : m_ifaces\n\n        // command arbitration\n        wire [S_COUNT-1:0] request;\n        wire [S_COUNT-1:0] acknowledge;\n        wire [S_COUNT-1:0] grant;\n        wire grant_valid;\n        wire [CL_S_COUNT-1:0] grant_encoded;\n\n        arbiter #(\n            .PORTS(S_COUNT),\n            .TYPE(ARB_TYPE),\n            .BLOCK(\"ACKNOWLEDGE\"),\n            .LSB_PRIORITY(LSB_PRIORITY)\n        )\n        cmd_arb_inst (\n            .clk(clk),\n            .rst(rst),\n            .request(request),\n            .acknowledge(acknowledge),\n            .grant(grant),\n            .grant_valid(grant_valid),\n            .grant_encoded(grant_encoded)\n        );\n\n        // mux\n        wire [RAM_ADDR_WIDTH-1:0] cmd_addr_mux  = int_cmd_addr[grant_encoded*RAM_ADDR_WIDTH +: RAM_ADDR_WIDTH];\n        wire [ADDR_WIDTH-1:0]     cmd_len_mux   = int_cmd_len[grant_encoded*ADDR_WIDTH +: ADDR_WIDTH];\n        wire [CMD_ADDR_WIDTH-1:0] cmd_id_mux    = int_cmd_id[grant_encoded*CMD_ADDR_WIDTH +: CMD_ADDR_WIDTH];\n        wire [KEEP_WIDTH-1:0]     cmd_tkeep_mux = int_cmd_tkeep[grant_encoded*KEEP_WIDTH +: KEEP_WIDTH];\n        wire [ID_WIDTH-1:0]       cmd_tid_mux   = int_cmd_tid[grant_encoded*ID_WIDTH +: ID_WIDTH];\n        wire [DEST_WIDTH-1:0]     cmd_tdest_mux = int_cmd_tdest[grant_encoded*DEST_WIDTH +: DEST_WIDTH];\n        wire [USER_WIDTH-1:0]     cmd_tuser_mux = int_cmd_tuser[grant_encoded*USER_WIDTH +: USER_WIDTH];\n        wire                      cmd_valid_mux = int_cmd_valid[grant_encoded*M_COUNT+n] && grant_valid;\n        wire                      cmd_ready_mux;\n\n        assign int_cmd_ready[n*S_COUNT +: S_COUNT] = (grant_valid && cmd_ready_mux) << grant_encoded;\n\n        for (m = 0; m < S_COUNT; m = m + 1) begin\n            assign request[m] = int_cmd_valid[m*M_COUNT+n] && !grant[m];\n            assign acknowledge[m] = grant[m] && int_cmd_valid[m*M_COUNT+n] && cmd_ready_mux;\n        end\n\n        reg [RAM_ADDR_WIDTH-1:0] rd_ptr_reg = {RAM_ADDR_WIDTH-1{1'b0}}, rd_ptr_next;\n\n        reg [ADDR_WIDTH-1:0] len_reg = {ADDR_WIDTH{1'b0}}, len_next;\n\n        reg [CL_S_COUNT-1:0] src_reg = 0, src_next;\n        reg [CMD_ADDR_WIDTH-1:0] id_reg = 0, id_next;\n\n        reg [KEEP_WIDTH-1:0] last_cycle_tkeep_reg = {KEEP_WIDTH{1'b0}}, last_cycle_tkeep_next;\n        reg [ID_WIDTH-1:0] tid_reg = {ID_WIDTH{1'b0}}, tid_next;\n        reg [DEST_WIDTH-1:0] tdest_reg = {DEST_WIDTH{1'b0}}, tdest_next;\n        reg [USER_WIDTH-1:0] tuser_reg = {USER_WIDTH{1'b0}}, tuser_next;\n\n        reg [DATA_WIDTH-1:0] out_axis_tdata_reg = {DATA_WIDTH{1'b0}}, out_axis_tdata_next;\n        reg [KEEP_WIDTH-1:0] out_axis_tkeep_reg = {KEEP_WIDTH{1'b0}}, out_axis_tkeep_next;\n        reg                  out_axis_tvalid_reg = 1'b0, out_axis_tvalid_next;\n        wire                 out_axis_tready;\n        reg                  out_axis_tlast_reg = 1'b0, out_axis_tlast_next;\n        reg [ID_WIDTH-1:0]   out_axis_tid_reg   = {ID_WIDTH{1'b0}}, out_axis_tid_next;\n        reg [DEST_WIDTH-1:0] out_axis_tdest_reg = {DEST_WIDTH{1'b0}}, out_axis_tdest_next;\n        reg [USER_WIDTH-1:0] out_axis_tuser_reg = {USER_WIDTH{1'b0}}, out_axis_tuser_next;\n\n        reg  [RAM_ADDR_WIDTH-1:0] ram_rd_addr_reg = {RAM_ADDR_WIDTH{1'b0}}, ram_rd_addr_next;\n        reg                       ram_rd_en_reg = 1'b0, ram_rd_en_next;\n        wire                      ram_rd_ack;\n        wire [DATA_WIDTH-1:0]     ram_rd_data;\n        wire                      ram_rd_data_valid;\n\n        reg cmd_valid_reg = 1'b0, cmd_valid_next;\n\n        reg [CMD_ADDR_WIDTH-1:0] cmd_status_id_reg = {CMD_ADDR_WIDTH{1'b0}}, cmd_status_id_next;\n        reg [S_COUNT-1:0]        cmd_status_valid_reg = 0, cmd_status_valid_next;\n\n        wire [S_COUNT-1:0] port_cmd_status_ready;\n        for (m = 0; m < S_COUNT; m = m + 1) begin\n            assign port_cmd_status_ready[m] = int_cmd_status_ready[m*M_COUNT+n];\n        end\n\n        reg [DATA_WIDTH-1:0] out_fifo_tdata[31:0];\n        reg [KEEP_WIDTH-1:0] out_fifo_tkeep[31:0];\n        reg out_fifo_tlast[31:0];\n        reg [ID_WIDTH-1:0] out_fifo_tid[31:0];\n        reg [DEST_WIDTH-1:0] out_fifo_tdest[31:0];\n        reg [USER_WIDTH-1:0] out_fifo_tuser[31:0];\n\n        reg [5:0] out_fifo_data_wr_ptr_reg = 0;\n        reg [DATA_WIDTH-1:0] out_fifo_data_wr_tdata;\n        reg out_fifo_data_wr_en;\n        reg [5:0] out_fifo_ctrl_wr_ptr_reg = 0;\n        reg [KEEP_WIDTH-1:0] out_fifo_ctrl_wr_tkeep;\n        reg out_fifo_ctrl_wr_tlast;\n        reg [ID_WIDTH-1:0] out_fifo_ctrl_wr_tid;\n        reg [DEST_WIDTH-1:0] out_fifo_ctrl_wr_tdest;\n        reg [USER_WIDTH-1:0] out_fifo_ctrl_wr_tuser;\n        reg out_fifo_ctrl_wr_en;\n        reg [5:0] out_fifo_rd_ptr_reg = 0;\n        reg out_fifo_rd_en;\n\n        assign port_ram_rd_addr[n*RAM_ADDR_WIDTH +: RAM_ADDR_WIDTH] = ram_rd_addr_reg;\n        assign port_ram_rd_en[n] = ram_rd_en_reg;\n        assign ram_rd_ack = port_ram_rd_ack[n];\n        assign ram_rd_data = port_ram_rd_data[n*DATA_WIDTH +: DATA_WIDTH];\n        assign ram_rd_data_valid = port_ram_rd_data_valid[n];\n\n        assign cmd_ready_mux = !cmd_valid_reg;\n\n        assign int_cmd_status_id[n*CMD_ADDR_WIDTH +: CMD_ADDR_WIDTH] = cmd_status_id_reg;\n        assign int_cmd_status_valid[n*S_COUNT +: S_COUNT] = cmd_status_valid_reg;\n\n        always @* begin\n            rd_ptr_next = rd_ptr_reg;\n\n            len_next = len_reg;\n\n            src_next = src_reg;\n            id_next = id_reg;\n\n            last_cycle_tkeep_next = last_cycle_tkeep_reg;\n            tid_next = tid_reg;\n            tdest_next = tdest_reg;\n            tuser_next = tuser_reg;\n\n            out_axis_tdata_next  = out_axis_tdata_reg;\n            out_axis_tkeep_next  = out_axis_tkeep_reg;\n            out_axis_tvalid_next = out_axis_tvalid_reg && !out_axis_tready;\n            out_axis_tlast_next  = out_axis_tlast_reg;\n            out_axis_tid_next    = out_axis_tid_reg;\n            out_axis_tdest_next  = out_axis_tdest_reg;\n            out_axis_tuser_next  = out_axis_tuser_reg;\n\n            ram_rd_addr_next = ram_rd_addr_reg;\n            ram_rd_en_next = ram_rd_en_reg && !ram_rd_ack;\n\n            cmd_valid_next = cmd_valid_reg;\n\n            cmd_status_id_next = cmd_status_id_reg;\n            cmd_status_valid_next = cmd_status_valid_reg & ~port_cmd_status_ready;\n\n            out_fifo_data_wr_tdata = ram_rd_data;\n            out_fifo_data_wr_en = 1'b0;\n            out_fifo_ctrl_wr_tkeep = len_reg == 0 ? last_cycle_tkeep_reg : {KEEP_WIDTH{1'b1}};\n            out_fifo_ctrl_wr_tlast = len_reg == 0;\n            out_fifo_ctrl_wr_tid = tid_reg;\n            out_fifo_ctrl_wr_tdest = tdest_reg;\n            out_fifo_ctrl_wr_tuser = tuser_reg;\n            out_fifo_ctrl_wr_en = 1'b0;\n            out_fifo_rd_en = 1'b0;\n\n            // receive commands\n            if (!cmd_valid_reg && cmd_valid_mux) begin\n                cmd_valid_next = 1'b1;\n                rd_ptr_next = cmd_addr_mux;\n                len_next = cmd_len_mux;\n                last_cycle_tkeep_next = cmd_tkeep_mux;\n                id_next = cmd_id_mux;\n                tid_next = cmd_tid_mux;\n                tdest_next = cmd_tdest_mux;\n                tuser_next = cmd_tuser_mux;\n\n                src_next = grant_encoded;\n            end\n\n            // process commands and issue memory reads\n            if (cmd_valid_reg && (!ram_rd_en_reg || ram_rd_ack) && ($unsigned(out_fifo_ctrl_wr_ptr_reg - out_fifo_rd_ptr_reg) < 32)) begin\n                // update counters\n                rd_ptr_next[ADDR_WIDTH-1:0] = rd_ptr_reg[ADDR_WIDTH-1:0] + 1;\n                len_next = len_reg - 1;\n\n                // issue memory read\n                ram_rd_addr_next = rd_ptr_reg;\n                ram_rd_en_next = 1'b1;\n\n                // write output control FIFO\n                out_fifo_ctrl_wr_tkeep = len_reg == 0 ? last_cycle_tkeep_reg : {KEEP_WIDTH{1'b1}};\n                out_fifo_ctrl_wr_tlast = len_reg == 0;\n                out_fifo_ctrl_wr_tid = tid_reg;\n                out_fifo_ctrl_wr_tdest = tdest_reg;\n                out_fifo_ctrl_wr_tuser = tuser_reg;\n                out_fifo_ctrl_wr_en = 1'b1;\n\n                if (len_reg == 0) begin\n                    // indicate operation complete\n                    cmd_status_id_next = id_reg;\n                    cmd_status_valid_next = 1 << src_reg;\n                    cmd_valid_next = 1'b0;\n                end\n            end\n\n            // write RAM read data to output data FIFO\n            if (ram_rd_data_valid) begin\n                out_fifo_data_wr_tdata = ram_rd_data;\n                out_fifo_data_wr_en = 1'b1;\n            end\n\n            // generate output AXI stream data from control and data FIFOs\n            if ((out_axis_tready || !out_axis_tvalid_reg) && (out_fifo_rd_ptr_reg != out_fifo_ctrl_wr_ptr_reg) && (out_fifo_rd_ptr_reg != out_fifo_data_wr_ptr_reg)) begin\n                out_fifo_rd_en = 1'b1;\n                out_axis_tdata_next = out_fifo_tdata[out_fifo_rd_ptr_reg[4:0]];\n                out_axis_tkeep_next = out_fifo_tkeep[out_fifo_rd_ptr_reg[4:0]];\n                out_axis_tvalid_next = 1'b1;\n                out_axis_tlast_next = out_fifo_tlast[out_fifo_rd_ptr_reg[4:0]];\n                out_axis_tid_next   = out_fifo_tid[out_fifo_rd_ptr_reg[4:0]];\n                out_axis_tdest_next = out_fifo_tdest[out_fifo_rd_ptr_reg[4:0]];\n                out_axis_tuser_next = out_fifo_tuser[out_fifo_rd_ptr_reg[4:0]];\n            end\n        end\n\n        always @(posedge clk) begin\n            rd_ptr_reg <= rd_ptr_next;\n\n            len_reg <= len_next;\n\n            src_reg <= src_next;\n            id_reg <= id_next;\n\n            last_cycle_tkeep_reg <= last_cycle_tkeep_next;\n            tid_reg <= tid_next;\n            tdest_reg <= tdest_next;\n            tuser_reg <= tuser_next;\n\n            out_axis_tdata_reg <= out_axis_tdata_next;\n            out_axis_tkeep_reg <= out_axis_tkeep_next;\n            out_axis_tvalid_reg <= out_axis_tvalid_next;\n            out_axis_tlast_reg <= out_axis_tlast_next;\n            out_axis_tid_reg   <= out_axis_tid_next;\n            out_axis_tdest_reg <= out_axis_tdest_next;\n            out_axis_tuser_reg <= out_axis_tuser_next;\n\n            ram_rd_addr_reg <= ram_rd_addr_next;\n            ram_rd_en_reg <= ram_rd_en_next;\n\n            cmd_valid_reg <= cmd_valid_next;\n\n            cmd_status_id_reg <= cmd_status_id_next;\n            cmd_status_valid_reg <= cmd_status_valid_next;\n\n            if (out_fifo_data_wr_en) begin\n                out_fifo_data_wr_ptr_reg <= out_fifo_data_wr_ptr_reg + 1;\n                out_fifo_tdata[out_fifo_data_wr_ptr_reg[4:0]] <= out_fifo_data_wr_tdata;\n            end\n\n            if (out_fifo_ctrl_wr_en) begin\n                out_fifo_ctrl_wr_ptr_reg <= out_fifo_ctrl_wr_ptr_reg + 1;\n                out_fifo_tkeep[out_fifo_ctrl_wr_ptr_reg[4:0]] <= out_fifo_ctrl_wr_tkeep;\n                out_fifo_tlast[out_fifo_ctrl_wr_ptr_reg[4:0]] <= out_fifo_ctrl_wr_tlast;\n                out_fifo_tid[out_fifo_ctrl_wr_ptr_reg[4:0]] <= out_fifo_ctrl_wr_tid;\n                out_fifo_tdest[out_fifo_ctrl_wr_ptr_reg[4:0]] <= out_fifo_ctrl_wr_tdest;\n                out_fifo_tuser[out_fifo_ctrl_wr_ptr_reg[4:0]] <= out_fifo_ctrl_wr_tuser;\n            end\n\n            if (out_fifo_rd_en) begin\n                out_fifo_rd_ptr_reg <= out_fifo_rd_ptr_reg + 1;\n            end\n\n            if (rst) begin\n                len_reg <= 0;\n                out_axis_tvalid_reg <= 1'b0;\n                ram_rd_en_reg <= 1'b0;\n                cmd_valid_reg <= 1'b0;\n                cmd_status_valid_reg <= 0;\n                out_fifo_data_wr_ptr_reg <= 0;\n                out_fifo_ctrl_wr_ptr_reg <= 0;\n                out_fifo_rd_ptr_reg <= 0;\n            end\n        end\n\n        axis_adapter #(\n            .S_DATA_WIDTH(DATA_WIDTH),\n            .S_KEEP_ENABLE(1),\n            .S_KEEP_WIDTH(KEEP_WIDTH),\n            .M_DATA_WIDTH(M_DATA_WIDTH),\n            .M_KEEP_ENABLE(M_KEEP_ENABLE),\n            .M_KEEP_WIDTH(M_KEEP_WIDTH),\n            .ID_ENABLE(ID_ENABLE),\n            .ID_WIDTH(ID_WIDTH),\n            .DEST_ENABLE(1),\n            .DEST_WIDTH(DEST_WIDTH),\n            .USER_ENABLE(USER_ENABLE),\n            .USER_WIDTH(USER_WIDTH)\n        )\n        adapter_inst (\n            .clk(clk),\n            .rst(rst),\n            // AXI input\n            .s_axis_tdata(out_axis_tdata_reg),\n            .s_axis_tkeep(out_axis_tkeep_reg),\n            .s_axis_tvalid(out_axis_tvalid_reg),\n            .s_axis_tready(out_axis_tready),\n            .s_axis_tlast(out_axis_tlast_reg),\n            .s_axis_tid(out_axis_tid_reg),\n            .s_axis_tdest(out_axis_tdest_reg),\n            .s_axis_tuser(out_axis_tuser_reg),\n            // AXI output\n            .m_axis_tdata(m_axis_tdata[M_DATA_WIDTH*n +: M_DATA_WIDTH]),\n            .m_axis_tkeep(m_axis_tkeep[M_KEEP_WIDTH*n +: M_KEEP_WIDTH]),\n            .m_axis_tvalid(m_axis_tvalid[n]),\n            .m_axis_tready(m_axis_tready[n]),\n            .m_axis_tlast(m_axis_tlast[n]),\n            .m_axis_tid(m_axis_tid[ID_WIDTH*n +: ID_WIDTH]),\n            .m_axis_tdest(m_axis_tdest[DEST_WIDTH*n +: DEST_WIDTH]),\n            .m_axis_tuser(m_axis_tuser[USER_WIDTH*n +: USER_WIDTH])\n        );\n    end // m_ifaces\n\nendgenerate\n\nendmodule\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[925, "            if (cmd_valid_reg && (!ram_rd_en_reg || ram_rd_ack) && ($unsigned(out_fifo_ctrl_wr_ptr_reg - out_fifo_rd_ptr_reg) < 32)) begin\n"]], "Add": [[925, "            if (cmd_valid_reg && !cmd_status_valid_next && (!ram_rd_en_reg || ram_rd_ack) && ($unsigned(out_fifo_ctrl_wr_ptr_reg - out_fifo_rd_ptr_reg) < 32)) begin\n"]]}}