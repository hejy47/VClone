{"Source Block": ["verilog-ethernet/rtl/eth_mac_phy_10g_fifo.v@259:447@HdlStmIf", "end\n\n// PTP timestamping\ngenerate\n\nif (TX_PTP_TS_ENABLE) begin\n    \n    ptp_clock_cdc #(\n        .TS_WIDTH(PTP_TS_WIDTH),\n        .NS_WIDTH(4),\n        .FNS_WIDTH(16),\n        .INPUT_PERIOD_NS(LOGIC_PTP_PERIOD_NS),\n        .INPUT_PERIOD_FNS(LOGIC_PTP_PERIOD_FNS),\n        .OUTPUT_PERIOD_NS(PTP_PERIOD_NS),\n        .OUTPUT_PERIOD_FNS(PTP_PERIOD_FNS),\n        .USE_SAMPLE_CLOCK(PTP_USE_SAMPLE_CLOCK)\n    )\n    tx_ptp_cdc (\n        .input_clk(logic_clk),\n        .input_rst(logic_rst),\n        .output_clk(tx_clk),\n        .output_rst(tx_rst),\n        .sample_clk(ptp_sample_clk),\n        .input_ts(ptp_ts_96),\n        .output_ts(tx_ptp_ts_96),\n        .output_ts_step(),\n        .output_pps()\n    );\n\n    if (TX_PTP_TAG_ENABLE) begin\n\n        ptp_tag_insert #(\n            .DATA_WIDTH(DATA_WIDTH),\n            .KEEP_WIDTH(KEEP_WIDTH),\n            .TAG_WIDTH(PTP_TAG_WIDTH),\n            .TAG_OFFSET(1),\n            .USER_WIDTH(TX_USER_WIDTH)\n        )\n        tx_ptp_tag_insert (\n            .clk(logic_clk),\n            .rst(logic_rst),\n\n            // AXI stream input\n            .s_axis_tdata(tx_axis_tdata),\n            .s_axis_tkeep(tx_axis_tkeep),\n            .s_axis_tvalid(tx_axis_tvalid),\n            .s_axis_tready(tx_axis_tready),\n            .s_axis_tlast(tx_axis_tlast),\n            .s_axis_tuser(tx_axis_tuser),\n\n            // AXI stream input\n            .m_axis_tdata(tx_axis_tdata_int),\n            .m_axis_tkeep(tx_axis_tkeep_int),\n            .m_axis_tvalid(tx_axis_tvalid_int),\n            .m_axis_tready(tx_axis_tready_int),\n            .m_axis_tlast(tx_axis_tlast_int),\n            .m_axis_tuser(tx_axis_tuser_int),\n\n            // Tag input\n            .s_axis_tag(s_axis_tx_ptp_ts_tag),\n            .s_axis_tag_valid(s_axis_tx_ptp_ts_valid),\n            .s_axis_tag_ready(s_axis_tx_ptp_ts_ready)\n        );\n\n        axis_async_fifo #(\n            .DEPTH(TX_PTP_TS_FIFO_DEPTH),\n            .DATA_WIDTH(PTP_TAG_WIDTH+PTP_TS_WIDTH),\n            .KEEP_ENABLE(0),\n            .LAST_ENABLE(0),\n            .ID_ENABLE(0),\n            .DEST_ENABLE(0),\n            .USER_ENABLE(0),\n            .FRAME_FIFO(0)\n        )\n        tx_ptp_ts_fifo (\n            .async_rst(logic_rst | tx_rst),\n\n            // AXI input\n            .s_clk(tx_clk),\n            .s_axis_tdata({tx_axis_ptp_ts_tag, tx_axis_ptp_ts_96}),\n            .s_axis_tkeep(0),\n            .s_axis_tvalid(tx_axis_ptp_ts_valid),\n            .s_axis_tready(),\n            .s_axis_tlast(0),\n            .s_axis_tid(0),\n            .s_axis_tdest(0),\n            .s_axis_tuser(0),\n\n            // AXI output\n            .m_clk(logic_clk),\n            .m_axis_tdata({m_axis_tx_ptp_ts_tag, m_axis_tx_ptp_ts_96}),\n            .m_axis_tkeep(),\n            .m_axis_tvalid(m_axis_tx_ptp_ts_valid),\n            .m_axis_tready(m_axis_tx_ptp_ts_ready),\n            .m_axis_tlast(),\n            .m_axis_tid(),\n            .m_axis_tdest(),\n            .m_axis_tuser(),\n\n            // Status\n            .s_status_overflow(),\n            .s_status_bad_frame(),\n            .s_status_good_frame(),\n            .m_status_overflow(),\n            .m_status_bad_frame(),\n            .m_status_good_frame()\n        );\n        \n    end else begin\n\n        assign tx_axis_tdata_int = tx_axis_tdata;\n        assign tx_axis_tkeep_int = tx_axis_tkeep;\n        assign tx_axis_tvalid_int = tx_axis_tvalid;\n        assign tx_axis_tready = tx_axis_tready_int;\n        assign tx_axis_tlast_int = tx_axis_tlast;\n        assign tx_axis_tuser_int = tx_axis_tuser;\n\n        axis_async_fifo #(\n            .DEPTH(TX_PTP_TS_FIFO_DEPTH),\n            .DATA_WIDTH(PTP_TS_WIDTH),\n            .KEEP_ENABLE(0),\n            .LAST_ENABLE(0),\n            .ID_ENABLE(0),\n            .DEST_ENABLE(0),\n            .USER_ENABLE(0),\n            .FRAME_FIFO(0)\n        )\n        tx_ptp_ts_fifo (\n            .async_rst(logic_rst | tx_rst),\n\n            // AXI input\n            .s_clk(tx_clk),\n            .s_axis_tdata(tx_axis_ptp_ts_96),\n            .s_axis_tkeep(0),\n            .s_axis_tvalid(tx_axis_ptp_ts_valid),\n            .s_axis_tready(),\n            .s_axis_tlast(0),\n            .s_axis_tid(0),\n            .s_axis_tdest(0),\n            .s_axis_tuser(0),\n\n            // AXI output\n            .m_clk(logic_clk),\n            .m_axis_tdata(m_axis_tx_ptp_ts_96),\n            .m_axis_tkeep(),\n            .m_axis_tvalid(m_axis_tx_ptp_ts_valid),\n            .m_axis_tready(m_axis_tx_ptp_ts_ready),\n            .m_axis_tlast(),\n            .m_axis_tid(),\n            .m_axis_tdest(),\n            .m_axis_tuser(),\n\n            // Status\n            .s_status_overflow(),\n            .s_status_bad_frame(),\n            .s_status_good_frame(),\n            .m_status_overflow(),\n            .m_status_bad_frame(),\n            .m_status_good_frame()\n        );\n\n        assign s_axis_tx_ptp_ts_ready = 1'b0;\n        assign m_axis_tx_ptp_ts_tag = {PTP_TAG_WIDTH{1'b0}};\n\n    end\n\nend else begin\n    \n    assign s_axis_tx_ptp_ts_ready = 1'b0;\n\n    assign m_axis_tx_ptp_ts_96 = {PTP_TS_WIDTH{1'b0}};\n    assign m_axis_tx_ptp_ts_tag = {PTP_TAG_WIDTH{1'b0}};\n    assign m_axis_tx_ptp_ts_valid = 1'b0;\n\n    assign tx_ptp_ts_96 = {PTP_TS_WIDTH{1'b0}};\n\n    assign tx_axis_tdata_int = tx_axis_tdata;\n    assign tx_axis_tkeep_int = tx_axis_tkeep;\n    assign tx_axis_tvalid_int = tx_axis_tvalid;\n    assign tx_axis_tready = tx_axis_tready_int;\n    assign tx_axis_tlast_int = tx_axis_tlast;\n    assign tx_axis_tuser_int = tx_axis_tuser;\n\nend\n\nif (RX_PTP_TS_ENABLE) begin\n\n    ptp_clock_cdc #(\n        .TS_WIDTH(PTP_TS_WIDTH),\n"], "Clone Blocks": [["verilog-ethernet/rtl/eth_mac_10g_fifo.v@242:430", "end\n\n// PTP timestamping\ngenerate\n\nif (TX_PTP_TS_ENABLE) begin\n    \n    ptp_clock_cdc #(\n        .TS_WIDTH(PTP_TS_WIDTH),\n        .NS_WIDTH(4),\n        .FNS_WIDTH(16),\n        .INPUT_PERIOD_NS(LOGIC_PTP_PERIOD_NS),\n        .INPUT_PERIOD_FNS(LOGIC_PTP_PERIOD_FNS),\n        .OUTPUT_PERIOD_NS(PTP_PERIOD_NS),\n        .OUTPUT_PERIOD_FNS(PTP_PERIOD_FNS),\n        .USE_SAMPLE_CLOCK(PTP_USE_SAMPLE_CLOCK)\n    )\n    tx_ptp_cdc (\n        .input_clk(logic_clk),\n        .input_rst(logic_rst),\n        .output_clk(tx_clk),\n        .output_rst(tx_rst),\n        .sample_clk(ptp_sample_clk),\n        .input_ts(ptp_ts_96),\n        .output_ts(tx_ptp_ts_96),\n        .output_ts_step(),\n        .output_pps()\n    );\n\n    if (TX_PTP_TAG_ENABLE) begin\n\n        ptp_tag_insert #(\n            .DATA_WIDTH(DATA_WIDTH),\n            .KEEP_WIDTH(KEEP_WIDTH),\n            .TAG_WIDTH(PTP_TAG_WIDTH),\n            .TAG_OFFSET(1),\n            .USER_WIDTH(TX_USER_WIDTH)\n        )\n        tx_ptp_tag_insert (\n            .clk(logic_clk),\n            .rst(logic_rst),\n\n            // AXI stream input\n            .s_axis_tdata(tx_axis_tdata),\n            .s_axis_tkeep(tx_axis_tkeep),\n            .s_axis_tvalid(tx_axis_tvalid),\n            .s_axis_tready(tx_axis_tready),\n            .s_axis_tlast(tx_axis_tlast),\n            .s_axis_tuser(tx_axis_tuser),\n\n            // AXI stream input\n            .m_axis_tdata(tx_axis_tdata_int),\n            .m_axis_tkeep(tx_axis_tkeep_int),\n            .m_axis_tvalid(tx_axis_tvalid_int),\n            .m_axis_tready(tx_axis_tready_int),\n            .m_axis_tlast(tx_axis_tlast_int),\n            .m_axis_tuser(tx_axis_tuser_int),\n\n            // Tag input\n            .s_axis_tag(s_axis_tx_ptp_ts_tag),\n            .s_axis_tag_valid(s_axis_tx_ptp_ts_valid),\n            .s_axis_tag_ready(s_axis_tx_ptp_ts_ready)\n        );\n\n        axis_async_fifo #(\n            .DEPTH(TX_PTP_TS_FIFO_DEPTH),\n            .DATA_WIDTH(PTP_TAG_WIDTH+PTP_TS_WIDTH),\n            .KEEP_ENABLE(0),\n            .LAST_ENABLE(0),\n            .ID_ENABLE(0),\n            .DEST_ENABLE(0),\n            .USER_ENABLE(0),\n            .FRAME_FIFO(0)\n        )\n        tx_ptp_ts_fifo (\n            .async_rst(logic_rst | tx_rst),\n\n            // AXI input\n            .s_clk(tx_clk),\n            .s_axis_tdata({tx_axis_ptp_ts_tag, tx_axis_ptp_ts_96}),\n            .s_axis_tkeep(0),\n            .s_axis_tvalid(tx_axis_ptp_ts_valid),\n            .s_axis_tready(),\n            .s_axis_tlast(0),\n            .s_axis_tid(0),\n            .s_axis_tdest(0),\n            .s_axis_tuser(0),\n\n            // AXI output\n            .m_clk(logic_clk),\n            .m_axis_tdata({m_axis_tx_ptp_ts_tag, m_axis_tx_ptp_ts_96}),\n            .m_axis_tkeep(),\n            .m_axis_tvalid(m_axis_tx_ptp_ts_valid),\n            .m_axis_tready(m_axis_tx_ptp_ts_ready),\n            .m_axis_tlast(),\n            .m_axis_tid(),\n            .m_axis_tdest(),\n            .m_axis_tuser(),\n\n            // Status\n            .s_status_overflow(),\n            .s_status_bad_frame(),\n            .s_status_good_frame(),\n            .m_status_overflow(),\n            .m_status_bad_frame(),\n            .m_status_good_frame()\n        );\n        \n    end else begin\n\n        assign tx_axis_tdata_int = tx_axis_tdata;\n        assign tx_axis_tkeep_int = tx_axis_tkeep;\n        assign tx_axis_tvalid_int = tx_axis_tvalid;\n        assign tx_axis_tready = tx_axis_tready_int;\n        assign tx_axis_tlast_int = tx_axis_tlast;\n        assign tx_axis_tuser_int = tx_axis_tuser;\n\n        axis_async_fifo #(\n            .DEPTH(TX_PTP_TS_FIFO_DEPTH),\n            .DATA_WIDTH(PTP_TS_WIDTH),\n            .KEEP_ENABLE(0),\n            .LAST_ENABLE(0),\n            .ID_ENABLE(0),\n            .DEST_ENABLE(0),\n            .USER_ENABLE(0),\n            .FRAME_FIFO(0)\n        )\n        tx_ptp_ts_fifo (\n            .async_rst(logic_rst | tx_rst),\n\n            // AXI input\n            .s_clk(tx_clk),\n            .s_axis_tdata(tx_axis_ptp_ts_96),\n            .s_axis_tkeep(0),\n            .s_axis_tvalid(tx_axis_ptp_ts_valid),\n            .s_axis_tready(),\n            .s_axis_tlast(0),\n            .s_axis_tid(0),\n            .s_axis_tdest(0),\n            .s_axis_tuser(0),\n\n            // AXI output\n            .m_clk(logic_clk),\n            .m_axis_tdata(m_axis_tx_ptp_ts_96),\n            .m_axis_tkeep(),\n            .m_axis_tvalid(m_axis_tx_ptp_ts_valid),\n            .m_axis_tready(m_axis_tx_ptp_ts_ready),\n            .m_axis_tlast(),\n            .m_axis_tid(),\n            .m_axis_tdest(),\n            .m_axis_tuser(),\n\n            // Status\n            .s_status_overflow(),\n            .s_status_bad_frame(),\n            .s_status_good_frame(),\n            .m_status_overflow(),\n            .m_status_bad_frame(),\n            .m_status_good_frame()\n        );\n\n        assign s_axis_tx_ptp_ts_ready = 1'b0;\n        assign m_axis_tx_ptp_ts_tag = {PTP_TAG_WIDTH{1'b0}};\n\n    end\n\nend else begin\n    \n    assign s_axis_tx_ptp_ts_ready = 1'b0;\n\n    assign m_axis_tx_ptp_ts_96 = {PTP_TS_WIDTH{1'b0}};\n    assign m_axis_tx_ptp_ts_tag = {PTP_TAG_WIDTH{1'b0}};\n    assign m_axis_tx_ptp_ts_valid = 1'b0;\n\n    assign tx_ptp_ts_96 = {PTP_TS_WIDTH{1'b0}};\n\n    assign tx_axis_tdata_int = tx_axis_tdata;\n    assign tx_axis_tkeep_int = tx_axis_tkeep;\n    assign tx_axis_tvalid_int = tx_axis_tvalid;\n    assign tx_axis_tready = tx_axis_tready_int;\n    assign tx_axis_tlast_int = tx_axis_tlast;\n    assign tx_axis_tuser_int = tx_axis_tuser;\n\nend\n\nif (RX_PTP_TS_ENABLE) begin\n\n    ptp_clock_cdc #(\n        .TS_WIDTH(PTP_TS_WIDTH),\n"]], "Diff Content": {"Delete": [[291, "            .DATA_WIDTH(DATA_WIDTH),\n"], [292, "            .KEEP_WIDTH(KEEP_WIDTH),\n"]], "Add": [[292, "            .DATA_WIDTH(AXIS_DATA_WIDTH),\n"], [292, "            .KEEP_WIDTH(AXIS_KEEP_WIDTH),\n"]]}}