{"Source Block": ["verilog-ethernet/rtl/udp_arb_mux.v@218:300@HdlStmProcess", ");\n\nassign request = s_udp_hdr_valid & ~grant;\nassign acknowledge = grant & s_udp_payload_axis_tvalid & s_udp_payload_axis_tready & s_udp_payload_axis_tlast;\n\nalways @* begin\n    frame_next = frame_reg;\n\n    s_udp_hdr_ready_mask_next = s_udp_hdr_ready_mask_reg;\n\n    m_udp_hdr_valid_next = m_udp_hdr_valid_reg && !m_udp_hdr_ready;\n    m_eth_dest_mac_next = m_eth_dest_mac_reg;\n    m_eth_src_mac_next = m_eth_src_mac_reg;\n    m_eth_type_next = m_eth_type_reg;\n    m_ip_version_next = m_ip_version_reg;\n    m_ip_ihl_next = m_ip_ihl_reg;\n    m_ip_dscp_next = m_ip_dscp_reg;\n    m_ip_ecn_next = m_ip_ecn_reg;\n    m_ip_length_next = m_ip_length_reg;\n    m_ip_identification_next = m_ip_identification_reg;\n    m_ip_flags_next = m_ip_flags_reg;\n    m_ip_fragment_offset_next = m_ip_fragment_offset_reg;\n    m_ip_ttl_next = m_ip_ttl_reg;\n    m_ip_protocol_next = m_ip_protocol_reg;\n    m_ip_header_checksum_next = m_ip_header_checksum_reg;\n    m_ip_source_ip_next = m_ip_source_ip_reg;\n    m_ip_dest_ip_next = m_ip_dest_ip_reg;\n    m_udp_source_port_next = m_udp_source_port_reg;\n    m_udp_dest_port_next = m_udp_dest_port_reg;\n    m_udp_length_next = m_udp_length_reg;\n    m_udp_checksum_next = m_udp_checksum_reg;\n\n    if (s_udp_payload_axis_tvalid[grant_encoded] && s_udp_payload_axis_tready[grant_encoded]) begin\n        // end of frame detection\n        if (s_udp_payload_axis_tlast[grant_encoded]) begin\n            frame_next = 1'b0;\n            s_udp_hdr_ready_mask_next = 1'b0;\n        end\n    end\n\n    if (!frame_reg && grant_valid) begin\n        // start of frame\n        frame_next = 1'b1;\n\n        s_udp_hdr_ready_mask_next = 1'b1;\n\n        m_udp_hdr_valid_next = 1'b1;\n        m_eth_dest_mac_next = s_eth_dest_mac[grant_encoded*48 +: 48];\n        m_eth_src_mac_next = s_eth_src_mac[grant_encoded*48 +: 48];\n        m_eth_type_next = s_eth_type[grant_encoded*16 +: 16];\n        m_ip_version_next = s_ip_version[grant_encoded*4 +: 4];\n        m_ip_ihl_next = s_ip_ihl[grant_encoded*4 +: 4];\n        m_ip_dscp_next = s_ip_dscp[grant_encoded*6 +: 6];\n        m_ip_ecn_next = s_ip_ecn[grant_encoded*2 +: 2];\n        m_ip_length_next = s_ip_length[grant_encoded*16 +: 16];\n        m_ip_identification_next = s_ip_identification[grant_encoded*16 +: 16];\n        m_ip_flags_next = s_ip_flags[grant_encoded*3 +: 3];\n        m_ip_fragment_offset_next = s_ip_fragment_offset[grant_encoded*13 +: 13];\n        m_ip_ttl_next = s_ip_ttl[grant_encoded*8 +: 8];\n        m_ip_protocol_next = s_ip_protocol[grant_encoded*8 +: 8];\n        m_ip_header_checksum_next = s_ip_header_checksum[grant_encoded*16 +: 16];\n        m_ip_source_ip_next = s_ip_source_ip[grant_encoded*32 +: 32];\n        m_ip_dest_ip_next = s_ip_dest_ip[grant_encoded*32 +: 32];\n        m_udp_source_port_next = s_udp_source_port[grant_encoded*16 +: 16];\n        m_udp_dest_port_next = s_udp_dest_port[grant_encoded*16 +: 16];\n        m_udp_length_next = s_udp_length[grant_encoded*16 +: 16];\n        m_udp_checksum_next = s_udp_checksum[grant_encoded*16 +: 16];\n    end\n\n    // pass through selected packet data\n    m_udp_payload_axis_tdata_int  = current_s_tdata;\n    m_udp_payload_axis_tkeep_int  = current_s_tkeep;\n    m_udp_payload_axis_tvalid_int = current_s_tvalid && m_udp_payload_axis_tready_int_reg && grant_valid;\n    m_udp_payload_axis_tlast_int  = current_s_tlast;\n    m_udp_payload_axis_tid_int    = current_s_tid;\n    m_udp_payload_axis_tdest_int  = current_s_tdest;\n    m_udp_payload_axis_tuser_int  = current_s_tuser;\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        frame_reg <= 1'b0;\n        s_udp_hdr_ready_mask_reg <= 1'b0;\n"], "Clone Blocks": [["verilog-ethernet/rtl/ip_mux.v@181:261", "wire                  current_s_tlast  = s_ip_payload_axis_tlast[select_reg];\nwire [ID_WIDTH-1:0]   current_s_tid    = s_ip_payload_axis_tid[select_reg*ID_WIDTH +: ID_WIDTH];\nwire [DEST_WIDTH-1:0] current_s_tdest  = s_ip_payload_axis_tdest[select_reg*DEST_WIDTH +: DEST_WIDTH];\nwire [USER_WIDTH-1:0] current_s_tuser  = s_ip_payload_axis_tuser[select_reg*USER_WIDTH +: USER_WIDTH];\n\nalways @* begin\n    select_next = select_reg;\n    frame_next = frame_reg;\n\n    s_ip_hdr_ready_next = 0;\n\n    s_ip_payload_axis_tready_next = 0;\n\n    m_ip_hdr_valid_next = m_ip_hdr_valid_reg && !m_ip_hdr_ready;\n    m_eth_dest_mac_next = m_eth_dest_mac_reg;\n    m_eth_src_mac_next = m_eth_src_mac_reg;\n    m_eth_type_next = m_eth_type_reg;\n    m_ip_version_next = m_ip_version_reg;\n    m_ip_ihl_next = m_ip_ihl_reg;\n    m_ip_dscp_next = m_ip_dscp_reg;\n    m_ip_ecn_next = m_ip_ecn_reg;\n    m_ip_length_next = m_ip_length_reg;\n    m_ip_identification_next = m_ip_identification_reg;\n    m_ip_flags_next = m_ip_flags_reg;\n    m_ip_fragment_offset_next = m_ip_fragment_offset_reg;\n    m_ip_ttl_next = m_ip_ttl_reg;\n    m_ip_protocol_next = m_ip_protocol_reg;\n    m_ip_header_checksum_next = m_ip_header_checksum_reg;\n    m_ip_source_ip_next = m_ip_source_ip_reg;\n    m_ip_dest_ip_next = m_ip_dest_ip_reg;\n\n    if (current_s_tvalid & current_s_tready) begin\n        // end of frame detection\n        if (current_s_tlast) begin\n            frame_next = 1'b0;\n        end\n    end\n\n    if (!frame_reg && enable && !m_ip_hdr_valid && (s_ip_hdr_valid & (1 << select))) begin\n        // start of frame, grab select value\n        frame_next = 1'b1;\n        select_next = select;\n\n        s_ip_hdr_ready_next = (1 << select);\n\n        m_ip_hdr_valid_next = 1'b1;\n        m_eth_dest_mac_next = s_eth_dest_mac[select*48 +: 48];\n        m_eth_src_mac_next = s_eth_src_mac[select*48 +: 48];\n        m_eth_type_next = s_eth_type[select*16 +: 16];\n        m_ip_version_next = s_ip_version[select*4 +: 4];\n        m_ip_ihl_next = s_ip_ihl[select*4 +: 4];\n        m_ip_dscp_next = s_ip_dscp[select*6 +: 6];\n        m_ip_ecn_next = s_ip_ecn[select*2 +: 2];\n        m_ip_length_next = s_ip_length[select*16 +: 16];\n        m_ip_identification_next = s_ip_identification[select*16 +: 16];\n        m_ip_flags_next = s_ip_flags[select*3 +: 3];\n        m_ip_fragment_offset_next = s_ip_fragment_offset[select*13 +: 13];\n        m_ip_ttl_next = s_ip_ttl[select*8 +: 8];\n        m_ip_protocol_next = s_ip_protocol[select*8 +: 8];\n        m_ip_header_checksum_next = s_ip_header_checksum[select*16 +: 16];\n        m_ip_source_ip_next = s_ip_source_ip[select*32 +: 32];\n        m_ip_dest_ip_next = s_ip_dest_ip[select*32 +: 32];\n    end\n\n    // generate ready signal on selected port\n    s_ip_payload_axis_tready_next = (m_ip_payload_axis_tready_int_early && frame_next) << select_next;\n\n    // pass through selected packet data\n    m_ip_payload_axis_tdata_int  = current_s_tdata;\n    m_ip_payload_axis_tkeep_int  = current_s_tkeep;\n    m_ip_payload_axis_tvalid_int = current_s_tvalid && current_s_tready && frame_reg;\n    m_ip_payload_axis_tlast_int  = current_s_tlast;\n    m_ip_payload_axis_tid_int    = current_s_tid;\n    m_ip_payload_axis_tdest_int  = current_s_tdest;\n    m_ip_payload_axis_tuser_int  = current_s_tuser;\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        select_reg <= 0;\n        frame_reg <= 1'b0;\n"], ["verilog-ethernet/rtl/udp_mux.v@197:285", "wire                  current_s_tlast  = s_udp_payload_axis_tlast[select_reg];\nwire [ID_WIDTH-1:0]   current_s_tid    = s_udp_payload_axis_tid[select_reg*ID_WIDTH +: ID_WIDTH];\nwire [DEST_WIDTH-1:0] current_s_tdest  = s_udp_payload_axis_tdest[select_reg*DEST_WIDTH +: DEST_WIDTH];\nwire [USER_WIDTH-1:0] current_s_tuser  = s_udp_payload_axis_tuser[select_reg*USER_WIDTH +: USER_WIDTH];\n\nalways @* begin\n    select_next = select_reg;\n    frame_next = frame_reg;\n\n    s_udp_hdr_ready_next = 0;\n\n    s_udp_payload_axis_tready_next = 0;\n\n    m_udp_hdr_valid_next = m_udp_hdr_valid_reg && !m_udp_hdr_ready;\n    m_eth_dest_mac_next = m_eth_dest_mac_reg;\n    m_eth_src_mac_next = m_eth_src_mac_reg;\n    m_eth_type_next = m_eth_type_reg;\n    m_ip_version_next = m_ip_version_reg;\n    m_ip_ihl_next = m_ip_ihl_reg;\n    m_ip_dscp_next = m_ip_dscp_reg;\n    m_ip_ecn_next = m_ip_ecn_reg;\n    m_ip_length_next = m_ip_length_reg;\n    m_ip_identification_next = m_ip_identification_reg;\n    m_ip_flags_next = m_ip_flags_reg;\n    m_ip_fragment_offset_next = m_ip_fragment_offset_reg;\n    m_ip_ttl_next = m_ip_ttl_reg;\n    m_ip_protocol_next = m_ip_protocol_reg;\n    m_ip_header_checksum_next = m_ip_header_checksum_reg;\n    m_ip_source_ip_next = m_ip_source_ip_reg;\n    m_ip_dest_ip_next = m_ip_dest_ip_reg;\n    m_udp_source_port_next = m_udp_source_port_reg;\n    m_udp_dest_port_next = m_udp_dest_port_reg;\n    m_udp_length_next = m_udp_length_reg;\n    m_udp_checksum_next = m_udp_checksum_reg;\n\n    if (current_s_tvalid & current_s_tready) begin\n        // end of frame detection\n        if (current_s_tlast) begin\n            frame_next = 1'b0;\n        end\n    end\n\n    if (!frame_reg && enable && !m_udp_hdr_valid && (s_udp_hdr_valid & (1 << select))) begin\n        // start of frame, grab select value\n        frame_next = 1'b1;\n        select_next = select;\n\n        s_udp_hdr_ready_next = (1 << select);\n\n        m_udp_hdr_valid_next = 1'b1;\n        m_eth_dest_mac_next = s_eth_dest_mac[select*48 +: 48];\n        m_eth_src_mac_next = s_eth_src_mac[select*48 +: 48];\n        m_eth_type_next = s_eth_type[select*16 +: 16];\n        m_ip_version_next = s_ip_version[select*4 +: 4];\n        m_ip_ihl_next = s_ip_ihl[select*4 +: 4];\n        m_ip_dscp_next = s_ip_dscp[select*6 +: 6];\n        m_ip_ecn_next = s_ip_ecn[select*2 +: 2];\n        m_ip_length_next = s_ip_length[select*16 +: 16];\n        m_ip_identification_next = s_ip_identification[select*16 +: 16];\n        m_ip_flags_next = s_ip_flags[select*3 +: 3];\n        m_ip_fragment_offset_next = s_ip_fragment_offset[select*13 +: 13];\n        m_ip_ttl_next = s_ip_ttl[select*8 +: 8];\n        m_ip_protocol_next = s_ip_protocol[select*8 +: 8];\n        m_ip_header_checksum_next = s_ip_header_checksum[select*16 +: 16];\n        m_ip_source_ip_next = s_ip_source_ip[select*32 +: 32];\n        m_ip_dest_ip_next = s_ip_dest_ip[select*32 +: 32];\n        m_udp_source_port_next = s_udp_source_port[select*16 +: 16];\n        m_udp_dest_port_next = s_udp_dest_port[select*16 +: 16];\n        m_udp_length_next = s_udp_length[select*16 +: 16];\n        m_udp_checksum_next = s_udp_checksum[select*16 +: 16];\n    end\n\n    // generate ready signal on selected port\n    s_udp_payload_axis_tready_next = (m_udp_payload_axis_tready_int_early && frame_next) << select_next;\n\n    // pass through selected packet data\n    m_udp_payload_axis_tdata_int  = current_s_tdata;\n    m_udp_payload_axis_tkeep_int  = current_s_tkeep;\n    m_udp_payload_axis_tvalid_int = current_s_tvalid && current_s_tready && frame_reg;\n    m_udp_payload_axis_tlast_int  = current_s_tlast;\n    m_udp_payload_axis_tid_int    = current_s_tid;\n    m_udp_payload_axis_tdest_int  = current_s_tdest;\n    m_udp_payload_axis_tuser_int  = current_s_tuser;\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        select_reg <= 0;\n        frame_reg <= 1'b0;\n"], ["verilog-ethernet/rtl/udp_demux.v@191:289", "assign m_udp_length = {M_COUNT{m_udp_length_reg}};\nassign m_udp_checksum = {M_COUNT{m_udp_checksum_reg}};\n\ninteger i;\n\nalways @* begin\n    select_next = select_reg;\n    select_ctl = select_reg;\n    drop_next = drop_reg;\n    drop_ctl = drop_reg;\n    frame_next = frame_reg;\n    frame_ctl = frame_reg;\n\n    s_udp_hdr_ready_next = 1'b0;\n\n    s_udp_payload_axis_tready_next = 1'b0;\n\n    m_udp_hdr_valid_next = m_udp_hdr_valid_reg & ~m_udp_hdr_ready;\n    m_eth_dest_mac_next = m_eth_dest_mac_reg;\n    m_eth_src_mac_next = m_eth_src_mac_reg;\n    m_eth_type_next = m_eth_type_reg;\n    m_ip_version_next = m_ip_version_reg;\n    m_ip_ihl_next = m_ip_ihl_reg;\n    m_ip_dscp_next = m_ip_dscp_reg;\n    m_ip_ecn_next = m_ip_ecn_reg;\n    m_ip_length_next = m_ip_length_reg;\n    m_ip_identification_next = m_ip_identification_reg;\n    m_ip_flags_next = m_ip_flags_reg;\n    m_ip_fragment_offset_next = m_ip_fragment_offset_reg;\n    m_ip_ttl_next = m_ip_ttl_reg;\n    m_ip_protocol_next = m_ip_protocol_reg;\n    m_ip_header_checksum_next = m_ip_header_checksum_reg;\n    m_ip_source_ip_next = m_ip_source_ip_reg;\n    m_ip_dest_ip_next = m_ip_dest_ip_reg;\n    m_udp_source_port_next = m_udp_source_port_reg;\n    m_udp_dest_port_next = m_udp_dest_port_reg;\n    m_udp_length_next = m_udp_length_reg;\n    m_udp_checksum_next = m_udp_checksum_reg;\n\n    if (s_udp_payload_axis_tvalid && s_udp_payload_axis_tready) begin\n        // end of frame detection\n        if (s_udp_payload_axis_tlast) begin\n            frame_next = 1'b0;\n            drop_next = 1'b0;\n        end\n    end\n\n    if (!frame_reg && s_udp_hdr_valid && s_udp_hdr_ready) begin\n        // start of frame, grab select value\n        select_ctl = select;\n        drop_ctl = drop;\n        frame_ctl = 1'b1;\n\n        select_next = select_ctl;\n        drop_next = drop_ctl;\n        frame_next = frame_ctl;\n\n        s_udp_hdr_ready_next = 1'b0;\n\n        m_udp_hdr_valid_next = (!drop_ctl) << select_ctl;\n        m_eth_dest_mac_next = s_eth_dest_mac;\n        m_eth_src_mac_next = s_eth_src_mac;\n        m_eth_type_next = s_eth_type;\n        m_ip_version_next = s_ip_version;\n        m_ip_ihl_next = s_ip_ihl;\n        m_ip_dscp_next = s_ip_dscp;\n        m_ip_ecn_next = s_ip_ecn;\n        m_ip_length_next = s_ip_length;\n        m_ip_identification_next = s_ip_identification;\n        m_ip_flags_next = s_ip_flags;\n        m_ip_fragment_offset_next = s_ip_fragment_offset;\n        m_ip_ttl_next = s_ip_ttl;\n        m_ip_protocol_next = s_ip_protocol;\n        m_ip_header_checksum_next = s_ip_header_checksum;\n        m_ip_source_ip_next = s_ip_source_ip;\n        m_ip_dest_ip_next = s_ip_dest_ip;\n        m_udp_source_port_next = s_udp_source_port;\n        m_udp_dest_port_next = s_udp_dest_port;\n        m_udp_length_next = s_udp_length;\n        m_udp_checksum_next = s_udp_checksum;\n    end\n\n    s_udp_hdr_ready_next = !frame_next && !m_udp_hdr_valid_next;\n\n    s_udp_payload_axis_tready_next = (m_udp_payload_axis_tready_int_early || drop_ctl) && frame_ctl;\n\n    m_udp_payload_axis_tdata_int  = s_udp_payload_axis_tdata;\n    m_udp_payload_axis_tkeep_int  = s_udp_payload_axis_tkeep;\n    m_udp_payload_axis_tvalid_int = (s_udp_payload_axis_tvalid && s_udp_payload_axis_tready && !drop_ctl) << select_ctl;\n    m_udp_payload_axis_tlast_int  = s_udp_payload_axis_tlast;\n    m_udp_payload_axis_tid_int    = s_udp_payload_axis_tid;\n    m_udp_payload_axis_tdest_int  = s_udp_payload_axis_tdest;\n    m_udp_payload_axis_tuser_int  = s_udp_payload_axis_tuser; \nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        select_reg <= 2'd0;\n        drop_reg <= 1'b0;\n"], ["verilog-ethernet/rtl/ip_arb_mux.v@202:276", ");\n\nassign request = s_ip_hdr_valid & ~grant;\nassign acknowledge = grant & s_ip_payload_axis_tvalid & s_ip_payload_axis_tready & s_ip_payload_axis_tlast;\n\nalways @* begin\n    frame_next = frame_reg;\n\n    s_ip_hdr_ready_mask_next = s_ip_hdr_ready_mask_reg;\n\n    m_ip_hdr_valid_next = m_ip_hdr_valid_reg && !m_ip_hdr_ready;\n    m_eth_dest_mac_next = m_eth_dest_mac_reg;\n    m_eth_src_mac_next = m_eth_src_mac_reg;\n    m_eth_type_next = m_eth_type_reg;\n    m_ip_version_next = m_ip_version_reg;\n    m_ip_ihl_next = m_ip_ihl_reg;\n    m_ip_dscp_next = m_ip_dscp_reg;\n    m_ip_ecn_next = m_ip_ecn_reg;\n    m_ip_length_next = m_ip_length_reg;\n    m_ip_identification_next = m_ip_identification_reg;\n    m_ip_flags_next = m_ip_flags_reg;\n    m_ip_fragment_offset_next = m_ip_fragment_offset_reg;\n    m_ip_ttl_next = m_ip_ttl_reg;\n    m_ip_protocol_next = m_ip_protocol_reg;\n    m_ip_header_checksum_next = m_ip_header_checksum_reg;\n    m_ip_source_ip_next = m_ip_source_ip_reg;\n    m_ip_dest_ip_next = m_ip_dest_ip_reg;\n\n    if (s_ip_payload_axis_tvalid[grant_encoded] && s_ip_payload_axis_tready[grant_encoded]) begin\n        // end of frame detection\n        if (s_ip_payload_axis_tlast[grant_encoded]) begin\n            frame_next = 1'b0;\n            s_ip_hdr_ready_mask_next = 1'b0;\n        end\n    end\n\n    if (!frame_reg && grant_valid) begin\n        // start of frame\n        frame_next = 1'b1;\n\n        s_ip_hdr_ready_mask_next = 1'b1;\n\n        m_ip_hdr_valid_next = 1'b1;\n        m_eth_dest_mac_next = s_eth_dest_mac[grant_encoded*48 +: 48];\n        m_eth_src_mac_next = s_eth_src_mac[grant_encoded*48 +: 48];\n        m_eth_type_next = s_eth_type[grant_encoded*16 +: 16];\n        m_ip_version_next = s_ip_version[grant_encoded*4 +: 4];\n        m_ip_ihl_next = s_ip_ihl[grant_encoded*4 +: 4];\n        m_ip_dscp_next = s_ip_dscp[grant_encoded*6 +: 6];\n        m_ip_ecn_next = s_ip_ecn[grant_encoded*2 +: 2];\n        m_ip_length_next = s_ip_length[grant_encoded*16 +: 16];\n        m_ip_identification_next = s_ip_identification[grant_encoded*16 +: 16];\n        m_ip_flags_next = s_ip_flags[grant_encoded*3 +: 3];\n        m_ip_fragment_offset_next = s_ip_fragment_offset[grant_encoded*13 +: 13];\n        m_ip_ttl_next = s_ip_ttl[grant_encoded*8 +: 8];\n        m_ip_protocol_next = s_ip_protocol[grant_encoded*8 +: 8];\n        m_ip_header_checksum_next = s_ip_header_checksum[grant_encoded*16 +: 16];\n        m_ip_source_ip_next = s_ip_source_ip[grant_encoded*32 +: 32];\n        m_ip_dest_ip_next = s_ip_dest_ip[grant_encoded*32 +: 32];\n    end\n\n    // pass through selected packet data\n    m_ip_payload_axis_tdata_int  = current_s_tdata;\n    m_ip_payload_axis_tkeep_int  = current_s_tkeep;\n    m_ip_payload_axis_tvalid_int = current_s_tvalid && m_ip_payload_axis_tready_int_reg && grant_valid;\n    m_ip_payload_axis_tlast_int  = current_s_tlast;\n    m_ip_payload_axis_tid_int    = current_s_tid;\n    m_ip_payload_axis_tdest_int  = current_s_tdest;\n    m_ip_payload_axis_tuser_int  = current_s_tuser;\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        frame_reg <= 1'b0;\n        s_ip_hdr_ready_mask_reg <= 1'b0;\n"]], "Diff Content": {"Delete": [[226, "    s_udp_hdr_ready_mask_next = s_udp_hdr_ready_mask_reg;\n"], [254, "            s_udp_hdr_ready_mask_next = 1'b0;\n"], [258, "    if (!frame_reg && grant_valid) begin\n"], [262, "        s_udp_hdr_ready_mask_next = 1'b1;\n"]], "Add": [[226, "    s_udp_hdr_ready_next = {S_COUNT{1'b0}};\n"], [258, "    if (!frame_reg && grant_valid && (m_udp_hdr_ready || !m_udp_hdr_valid)) begin\n"], [262, "        s_udp_hdr_ready_next = grant;\n"]]}}