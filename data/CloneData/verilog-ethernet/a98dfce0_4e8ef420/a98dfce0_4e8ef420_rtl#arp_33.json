{"Source Block": ["verilog-ethernet/rtl/arp.v@263:392@HdlStmProcess", "\nassign arp_response_valid = arp_response_error_reg | (cache_query_response_valid & ~cache_query_response_error & ~arp_request_operation_reg) | arp_response_broadcast_reg;\nassign arp_response_error = arp_response_error_reg;\nassign arp_response_mac = arp_response_broadcast_reg ? 48'hffffffffffff : cache_query_response_mac;\n\nalways @* begin\n    outgoing_frame_valid_next = outgoing_frame_valid_reg & ~outgoing_frame_ready;\n    outgoing_eth_dest_mac_next = outgoing_eth_dest_mac_reg;\n    outgoing_arp_oper_next = outgoing_arp_oper_reg;\n    outgoing_arp_tha_next = outgoing_arp_tha_reg;\n    outgoing_arp_tpa_next = outgoing_arp_tpa_reg;\n\n    cache_write_request_valid_next = 0;\n    cache_write_request_mac_next = 0;\n    cache_write_request_ip_next = 0;\n\n    arp_request_valid_next = 0;\n    arp_request_ip_next = arp_request_ip_reg;\n    arp_request_operation_next = arp_request_operation_reg;\n    arp_request_retry_cnt_next = arp_request_retry_cnt_reg;\n    arp_request_timer_next = arp_request_timer_reg;\n    arp_response_error_next = 0;\n    arp_response_broadcast_next = 0;\n    \n    drop_incoming_frame_next = 0;\n\n    // manage incoming frames\n    if (filtered_incoming_frame_valid & ~(outgoing_frame_valid_reg & ~outgoing_frame_ready)) begin\n        // store sender addresses in cache\n        cache_write_request_valid_next = 1;\n        cache_write_request_ip_next = incoming_arp_spa;\n        cache_write_request_mac_next = incoming_arp_sha;\n        if (incoming_arp_oper_arp_request) begin\n            if (incoming_arp_tpa == local_ip) begin\n                // send reply frame to valid incoming request\n                outgoing_frame_valid_next = 1;\n                outgoing_eth_dest_mac_next = incoming_eth_src_mac;\n                outgoing_arp_oper_next = ARP_OPER_ARP_REPLY;\n                outgoing_arp_tha_next = incoming_arp_sha;\n                outgoing_arp_tpa_next = incoming_arp_spa;\n            end else begin\n                // does not match -> drop it\n                drop_incoming_frame_next = 1;\n            end\n        end else if (incoming_arp_oper_inarp_request) begin\n            if (incoming_arp_tha == local_mac) begin\n                // send reply frame to valid incoming request\n                outgoing_frame_valid_next = 1;\n                outgoing_eth_dest_mac_next = incoming_eth_src_mac;\n                outgoing_arp_oper_next = ARP_OPER_INARP_REPLY;\n                outgoing_arp_tha_next = incoming_arp_sha;\n                outgoing_arp_tpa_next = incoming_arp_spa;\n            end else begin\n                // does not match -> drop it\n                drop_incoming_frame_next = 1;\n            end\n        end else begin\n            // does not match -> drop it\n            drop_incoming_frame_next = 1;\n        end\n    end else if (incoming_frame_valid & ~filtered_incoming_frame_valid) begin\n        // incoming invalid frame -> drop it\n        drop_incoming_frame_next = 1;\n    end\n\n    // manage ARP lookup requests\n    if (~arp_request_operation_reg & ~arp_response_valid) begin\n        if (arp_request_valid) begin\n            if (~(arp_request_ip | subnet_mask) == 0) begin\n                // broadcast address\n                // (all bits in request IP set where subnet mask is clear)\n                arp_request_valid_next = 0;\n                arp_response_broadcast_next = 1;\n            end else if (((arp_request_ip ^ gateway_ip) & subnet_mask) == 0) begin\n                // within subnet, look up IP directly\n                // (no bits differ between request IP and gateway IP where subnet mask is set)\n                arp_request_valid_next = 1;\n                arp_request_ip_next = arp_request_ip;\n            end else begin\n                // outside of subnet, so look up gateway address\n                arp_request_valid_next = 1;\n                arp_request_ip_next = gateway_ip;\n            end\n        end\n        if (cache_query_response_error & ~arp_response_error) begin\n            arp_request_operation_next = 1;\n            // send ARP request frame\n            outgoing_frame_valid_next = 1;\n            outgoing_eth_dest_mac_next = 48'hFF_FF_FF_FF_FF_FF;\n            outgoing_arp_oper_next = ARP_OPER_ARP_REQUEST;\n            outgoing_arp_tha_next = 48'h00_00_00_00_00_00;\n            outgoing_arp_tpa_next = arp_request_ip_reg;\n            arp_request_retry_cnt_next = REQUEST_RETRY_COUNT-1;\n            arp_request_timer_next = REQUEST_RETRY_INTERVAL;\n        end\n    end else if (arp_request_operation_reg) begin\n        arp_request_timer_next = arp_request_timer_reg - 1;\n        // if we got a response, it will go in the cache, so when the query succeds, we're done\n        if (cache_query_response_valid  & ~cache_query_response_error) begin\n            arp_request_operation_next = 0;\n        end\n        // timer timeout\n        if (arp_request_timer_reg == 0) begin\n            if (arp_request_retry_cnt_reg > 0) begin\n                // have more retries\n                // send ARP request frame\n                outgoing_frame_valid_next = 1'b1;\n                outgoing_eth_dest_mac_next = 48'hFF_FF_FF_FF_FF_FF;\n                outgoing_arp_oper_next = ARP_OPER_ARP_REQUEST;\n                outgoing_arp_tha_next = 48'h00_00_00_00_00_00;\n                outgoing_arp_tpa_next = arp_request_ip_reg;\n                arp_request_retry_cnt_next = arp_request_retry_cnt_reg - 1;\n                if (arp_request_retry_cnt_reg > 1) begin\n                    arp_request_timer_next = REQUEST_RETRY_INTERVAL;\n                end else begin\n                    arp_request_timer_next = REQUEST_TIMEOUT;\n                end\n            end else begin\n                // out of retries\n                arp_request_operation_next = 0;\n                arp_response_error_next = 1;\n            end\n        end\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        outgoing_frame_valid_reg <= 0;\n        outgoing_eth_dest_mac_reg <= 0;\n"], "Clone Blocks": [["verilog-ethernet/rtl/arp_64.v@267:396", "\nassign arp_response_valid = arp_response_error_reg | (cache_query_response_valid & ~cache_query_response_error & ~arp_request_operation_reg) | arp_response_broadcast_reg;\nassign arp_response_error = arp_response_error_reg;\nassign arp_response_mac = arp_response_broadcast_reg ? 48'hffffffffffff : cache_query_response_mac;\n\nalways @* begin\n    outgoing_frame_valid_next = outgoing_frame_valid_reg & ~outgoing_frame_ready;\n    outgoing_eth_dest_mac_next = outgoing_eth_dest_mac_reg;\n    outgoing_arp_oper_next = outgoing_arp_oper_reg;\n    outgoing_arp_tha_next = outgoing_arp_tha_reg;\n    outgoing_arp_tpa_next = outgoing_arp_tpa_reg;\n\n    cache_write_request_valid_next = 0;\n    cache_write_request_mac_next = 0;\n    cache_write_request_ip_next = 0;\n\n    arp_request_valid_next = 0;\n    arp_request_ip_next = arp_request_ip_reg;\n    arp_request_operation_next = arp_request_operation_reg;\n    arp_request_retry_cnt_next = arp_request_retry_cnt_reg;\n    arp_request_timer_next = arp_request_timer_reg;\n    arp_response_error_next = 0;\n    arp_response_broadcast_next = 0;\n    \n    drop_incoming_frame_next = 0;\n\n    // manage incoming frames\n    if (filtered_incoming_frame_valid & ~(outgoing_frame_valid_reg & ~outgoing_frame_ready)) begin\n        // store sender addresses in cache\n        cache_write_request_valid_next = 1;\n        cache_write_request_ip_next = incoming_arp_spa;\n        cache_write_request_mac_next = incoming_arp_sha;\n        if (incoming_arp_oper_arp_request) begin\n            if (incoming_arp_tpa == local_ip) begin\n                // send reply frame to valid incoming request\n                outgoing_frame_valid_next = 1;\n                outgoing_eth_dest_mac_next = incoming_eth_src_mac;\n                outgoing_arp_oper_next = ARP_OPER_ARP_REPLY;\n                outgoing_arp_tha_next = incoming_arp_sha;\n                outgoing_arp_tpa_next = incoming_arp_spa;\n            end else begin\n                // does not match -> drop it\n                drop_incoming_frame_next = 1;\n            end\n        end else if (incoming_arp_oper_inarp_request) begin\n            if (incoming_arp_tha == local_mac) begin\n                // send reply frame to valid incoming request\n                outgoing_frame_valid_next = 1;\n                outgoing_eth_dest_mac_next = incoming_eth_src_mac;\n                outgoing_arp_oper_next = ARP_OPER_INARP_REPLY;\n                outgoing_arp_tha_next = incoming_arp_sha;\n                outgoing_arp_tpa_next = incoming_arp_spa;\n            end else begin\n                // does not match -> drop it\n                drop_incoming_frame_next = 1;\n            end\n        end else begin\n            // does not match -> drop it\n            drop_incoming_frame_next = 1;\n        end\n    end else if (incoming_frame_valid & ~filtered_incoming_frame_valid) begin\n        // incoming invalid frame -> drop it\n        drop_incoming_frame_next = 1;\n    end\n\n    // manage ARP lookup requests\n    if (~arp_request_operation_reg & ~arp_response_valid) begin\n        if (arp_request_valid) begin\n            if (~(arp_request_ip | subnet_mask) == 0) begin\n                // broadcast address\n                // (all bits in request IP set where subnet mask is clear)\n                arp_request_valid_next = 0;\n                arp_response_broadcast_next = 1;\n            end else if (((arp_request_ip ^ gateway_ip) & subnet_mask) == 0) begin\n                // within subnet, look up IP directly\n                // (no bits differ between request IP and gateway IP where subnet mask is set)\n                arp_request_valid_next = 1;\n                arp_request_ip_next = arp_request_ip;\n            end else begin\n                // outside of subnet, so look up gateway address\n                arp_request_valid_next = 1;\n                arp_request_ip_next = gateway_ip;\n            end\n        end\n        if (cache_query_response_error & ~arp_response_error) begin\n            arp_request_operation_next = 1;\n            // send ARP request frame\n            outgoing_frame_valid_next = 1;\n            outgoing_eth_dest_mac_next = 48'hFF_FF_FF_FF_FF_FF;\n            outgoing_arp_oper_next = ARP_OPER_ARP_REQUEST;\n            outgoing_arp_tha_next = 48'h00_00_00_00_00_00;\n            outgoing_arp_tpa_next = arp_request_ip_reg;\n            arp_request_retry_cnt_next = REQUEST_RETRY_COUNT-1;\n            arp_request_timer_next = REQUEST_RETRY_INTERVAL;\n        end\n    end else if (arp_request_operation_reg) begin\n        arp_request_timer_next = arp_request_timer_reg - 1;\n        // if we got a response, it will go in the cache, so when the query succeds, we're done\n        if (cache_query_response_valid  & ~cache_query_response_error) begin\n            arp_request_operation_next = 0;\n        end\n        // timer timeout\n        if (arp_request_timer_reg == 0) begin\n            if (arp_request_retry_cnt_reg > 0) begin\n                // have more retries\n                // send ARP request frame\n                outgoing_frame_valid_next = 1'b1;\n                outgoing_eth_dest_mac_next = 48'hFF_FF_FF_FF_FF_FF;\n                outgoing_arp_oper_next = ARP_OPER_ARP_REQUEST;\n                outgoing_arp_tha_next = 48'h00_00_00_00_00_00;\n                outgoing_arp_tpa_next = arp_request_ip_reg;\n                arp_request_retry_cnt_next = arp_request_retry_cnt_reg - 1;\n                if (arp_request_retry_cnt_reg > 1) begin\n                    arp_request_timer_next = REQUEST_RETRY_INTERVAL;\n                end else begin\n                    arp_request_timer_next = REQUEST_TIMEOUT;\n                end\n            end else begin\n                // out of retries\n                arp_request_operation_next = 0;\n                arp_response_error_next = 1;\n            end\n        end\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        outgoing_frame_valid_reg <= 0;\n        outgoing_eth_dest_mac_reg <= 0;\n"]], "Diff Content": {"Delete": [[275, "    cache_write_request_valid_next = 0;\n"], [276, "    cache_write_request_mac_next = 0;\n"], [277, "    cache_write_request_ip_next = 0;\n"], [279, "    arp_request_valid_next = 0;\n"], [284, "    arp_response_error_next = 0;\n"], [285, "    arp_response_broadcast_next = 0;\n"], [287, "    drop_incoming_frame_next = 0;\n"], [292, "        cache_write_request_valid_next = 1;\n"], [298, "                outgoing_frame_valid_next = 1;\n"], [305, "                drop_incoming_frame_next = 1;\n"], [310, "                outgoing_frame_valid_next = 1;\n"], [317, "                drop_incoming_frame_next = 1;\n"], [321, "            drop_incoming_frame_next = 1;\n"], [325, "        drop_incoming_frame_next = 1;\n"], [334, "                arp_request_valid_next = 0;\n"], [335, "                arp_response_broadcast_next = 1;\n"], [339, "                arp_request_valid_next = 1;\n"], [343, "                arp_request_valid_next = 1;\n"], [348, "            arp_request_operation_next = 1;\n"], [350, "            outgoing_frame_valid_next = 1;\n"], [362, "            arp_request_operation_next = 0;\n"], [382, "                arp_request_operation_next = 0;\n"], [383, "                arp_response_error_next = 1;\n"]], "Add": [[277, "    cache_write_request_valid_next = 1'b0;\n"], [277, "    cache_write_request_mac_next = 48'd0;\n"], [277, "    cache_write_request_ip_next = 32'd0;\n"], [279, "    arp_request_valid_next = 1'b0;\n"], [285, "    arp_response_error_next = 1'b0;\n"], [285, "    arp_response_broadcast_next = 1'b0;\n"], [287, "    drop_incoming_frame_next = 1'b0;\n"], [292, "        cache_write_request_valid_next = 1'b1;\n"], [298, "                outgoing_frame_valid_next = 1'b1;\n"], [305, "                drop_incoming_frame_next = 1'b1;\n"], [310, "                outgoing_frame_valid_next = 1'b1;\n"], [317, "                drop_incoming_frame_next = 1'b1;\n"], [321, "            drop_incoming_frame_next = 1'b1;\n"], [325, "        drop_incoming_frame_next = 1'b1;\n"], [335, "                arp_request_valid_next = 1'b0;\n"], [335, "                arp_response_broadcast_next = 1'b1;\n"], [339, "                arp_request_valid_next = 1'b1;\n"], [343, "                arp_request_valid_next = 1'b1;\n"], [348, "            arp_request_operation_next = 1'b1;\n"], [350, "            outgoing_frame_valid_next = 1'b1;\n"], [362, "            arp_request_operation_next = 1'b0;\n"], [383, "                arp_request_operation_next = 1'b0;\n"], [383, "                arp_response_error_next = 1'b1;\n"]]}}