{"Source Block": ["verilog-ethernet/rtl/arp_eth_tx.v@281:330@HdlStmProcess", "assign output_eth_payload_tuser = output_eth_payload_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_eth_payload_tready_int_early = output_eth_payload_tready | (~temp_axis_tvalid_reg & ~output_eth_payload_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_eth_payload_tvalid_int);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        output_eth_payload_tdata_reg <= 0;\n        output_eth_payload_tvalid_reg <= 0;\n        output_eth_payload_tlast_reg <= 0;\n        output_eth_payload_tuser_reg <= 0;\n        output_eth_payload_tready_int <= 0;\n        temp_axis_tdata_reg <= 0;\n        temp_axis_tvalid_reg <= 0;\n        temp_axis_tlast_reg <= 0;\n        temp_axis_tuser_reg <= 0;\n    end else begin\n        // transfer sink ready state to source\n        output_eth_payload_tready_int <= output_eth_payload_tready_int_early;\n\n        if (output_eth_payload_tready_int) begin\n            // input is ready\n            if (output_eth_payload_tready | ~output_eth_payload_tvalid_reg) begin\n                // output is ready or currently not valid, transfer data to output\n                output_eth_payload_tdata_reg <= output_eth_payload_tdata_int;\n                output_eth_payload_tvalid_reg <= output_eth_payload_tvalid_int;\n                output_eth_payload_tlast_reg <= output_eth_payload_tlast_int;\n                output_eth_payload_tuser_reg <= output_eth_payload_tuser_int;\n            end else begin\n                // output is not ready and currently valid, store input in temp\n                temp_axis_tdata_reg <= output_eth_payload_tdata_int;\n                temp_axis_tvalid_reg <= output_eth_payload_tvalid_int;\n                temp_axis_tlast_reg <= output_eth_payload_tlast_int;\n                temp_axis_tuser_reg <= output_eth_payload_tuser_int;\n            end\n        end else if (output_eth_payload_tready) begin\n            // input is not ready, but output is ready\n            output_eth_payload_tdata_reg <= temp_axis_tdata_reg;\n            output_eth_payload_tvalid_reg <= temp_axis_tvalid_reg;\n            output_eth_payload_tlast_reg <= temp_axis_tlast_reg;\n            output_eth_payload_tuser_reg <= temp_axis_tuser_reg;\n            temp_axis_tdata_reg <= 0;\n            temp_axis_tvalid_reg <= 0;\n            temp_axis_tlast_reg <= 0;\n            temp_axis_tuser_reg <= 0;\n        end\n    end\nend\n\nendmodule\n"], "Clone Blocks": [["verilog-ethernet/rtl/ip_eth_tx.v@441:490", "assign output_eth_payload_tuser = output_eth_payload_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_eth_payload_tready_int_early = output_eth_payload_tready | (~temp_axis_tvalid_reg & ~output_eth_payload_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_eth_payload_tvalid_int);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        output_eth_payload_tdata_reg <= 0;\n        output_eth_payload_tvalid_reg <= 0;\n        output_eth_payload_tlast_reg <= 0;\n        output_eth_payload_tuser_reg <= 0;\n        output_eth_payload_tready_int <= 0;\n        temp_axis_tdata_reg <= 0;\n        temp_axis_tvalid_reg <= 0;\n        temp_axis_tlast_reg <= 0;\n        temp_axis_tuser_reg <= 0;\n    end else begin\n        // transfer sink ready state to source\n        output_eth_payload_tready_int <= output_eth_payload_tready_int_early;\n\n        if (output_eth_payload_tready_int) begin\n            // input is ready\n            if (output_eth_payload_tready | ~output_eth_payload_tvalid_reg) begin\n                // output is ready or currently not valid, transfer data to output\n                output_eth_payload_tdata_reg <= output_eth_payload_tdata_int;\n                output_eth_payload_tvalid_reg <= output_eth_payload_tvalid_int;\n                output_eth_payload_tlast_reg <= output_eth_payload_tlast_int;\n                output_eth_payload_tuser_reg <= output_eth_payload_tuser_int;\n            end else begin\n                // output is not ready and currently valid, store input in temp\n                temp_axis_tdata_reg <= output_eth_payload_tdata_int;\n                temp_axis_tvalid_reg <= output_eth_payload_tvalid_int;\n                temp_axis_tlast_reg <= output_eth_payload_tlast_int;\n                temp_axis_tuser_reg <= output_eth_payload_tuser_int;\n            end\n        end else if (output_eth_payload_tready) begin\n            // input is not ready, but output is ready\n            output_eth_payload_tdata_reg <= temp_axis_tdata_reg;\n            output_eth_payload_tvalid_reg <= temp_axis_tvalid_reg;\n            output_eth_payload_tlast_reg <= temp_axis_tlast_reg;\n            output_eth_payload_tuser_reg <= temp_axis_tuser_reg;\n            temp_axis_tdata_reg <= 0;\n            temp_axis_tvalid_reg <= 0;\n            temp_axis_tlast_reg <= 0;\n            temp_axis_tuser_reg <= 0;\n        end\n    end\nend\n\nendmodule\n"], ["verilog-ethernet/rtl/eth_mux_4.v@324:373", "assign output_eth_payload_tuser = output_eth_payload_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_eth_payload_tready_int_early = output_eth_payload_tready | (~temp_eth_payload_tvalid_reg & ~output_eth_payload_tvalid_reg) | (~temp_eth_payload_tvalid_reg & ~output_eth_payload_tvalid_int);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        output_eth_payload_tdata_reg <= 0;\n        output_eth_payload_tvalid_reg <= 0;\n        output_eth_payload_tlast_reg <= 0;\n        output_eth_payload_tuser_reg <= 0;\n        output_eth_payload_tready_int <= 0;\n        temp_eth_payload_tdata_reg <= 0;\n        temp_eth_payload_tvalid_reg <= 0;\n        temp_eth_payload_tlast_reg <= 0;\n        temp_eth_payload_tuser_reg <= 0;\n    end else begin\n        // transfer sink ready state to source\n        output_eth_payload_tready_int <= output_eth_payload_tready_int_early;\n\n        if (output_eth_payload_tready_int) begin\n            // input is ready\n            if (output_eth_payload_tready | ~output_eth_payload_tvalid_reg) begin\n                // output is ready or currently not valid, transfer data to output\n                output_eth_payload_tdata_reg <= output_eth_payload_tdata_int;\n                output_eth_payload_tvalid_reg <= output_eth_payload_tvalid_int;\n                output_eth_payload_tlast_reg <= output_eth_payload_tlast_int;\n                output_eth_payload_tuser_reg <= output_eth_payload_tuser_int;\n            end else begin\n                // output is not ready, store input in temp\n                temp_eth_payload_tdata_reg <= output_eth_payload_tdata_int;\n                temp_eth_payload_tvalid_reg <= output_eth_payload_tvalid_int;\n                temp_eth_payload_tlast_reg <= output_eth_payload_tlast_int;\n                temp_eth_payload_tuser_reg <= output_eth_payload_tuser_int;\n            end\n        end else if (output_eth_payload_tready) begin\n            // input is not ready, but output is ready\n            output_eth_payload_tdata_reg <= temp_eth_payload_tdata_reg;\n            output_eth_payload_tvalid_reg <= temp_eth_payload_tvalid_reg;\n            output_eth_payload_tlast_reg <= temp_eth_payload_tlast_reg;\n            output_eth_payload_tuser_reg <= temp_eth_payload_tuser_reg;\n            temp_eth_payload_tdata_reg <= 0;\n            temp_eth_payload_tvalid_reg <= 0;\n            temp_eth_payload_tlast_reg <= 0;\n            temp_eth_payload_tuser_reg <= 0;\n        end\n    end\nend\n\nendmodule\n"], ["verilog-ethernet/rtl/eth_mux_2.v@252:301", "assign output_eth_payload_tuser = output_eth_payload_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_eth_payload_tready_int_early = output_eth_payload_tready | (~temp_eth_payload_tvalid_reg & ~output_eth_payload_tvalid_reg) | (~temp_eth_payload_tvalid_reg & ~output_eth_payload_tvalid_int);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        output_eth_payload_tdata_reg <= 0;\n        output_eth_payload_tvalid_reg <= 0;\n        output_eth_payload_tlast_reg <= 0;\n        output_eth_payload_tuser_reg <= 0;\n        output_eth_payload_tready_int <= 0;\n        temp_eth_payload_tdata_reg <= 0;\n        temp_eth_payload_tvalid_reg <= 0;\n        temp_eth_payload_tlast_reg <= 0;\n        temp_eth_payload_tuser_reg <= 0;\n    end else begin\n        // transfer sink ready state to source\n        output_eth_payload_tready_int <= output_eth_payload_tready_int_early;\n\n        if (output_eth_payload_tready_int) begin\n            // input is ready\n            if (output_eth_payload_tready | ~output_eth_payload_tvalid_reg) begin\n                // output is ready or currently not valid, transfer data to output\n                output_eth_payload_tdata_reg <= output_eth_payload_tdata_int;\n                output_eth_payload_tvalid_reg <= output_eth_payload_tvalid_int;\n                output_eth_payload_tlast_reg <= output_eth_payload_tlast_int;\n                output_eth_payload_tuser_reg <= output_eth_payload_tuser_int;\n            end else begin\n                // output is not ready, store input in temp\n                temp_eth_payload_tdata_reg <= output_eth_payload_tdata_int;\n                temp_eth_payload_tvalid_reg <= output_eth_payload_tvalid_int;\n                temp_eth_payload_tlast_reg <= output_eth_payload_tlast_int;\n                temp_eth_payload_tuser_reg <= output_eth_payload_tuser_int;\n            end\n        end else if (output_eth_payload_tready) begin\n            // input is not ready, but output is ready\n            output_eth_payload_tdata_reg <= temp_eth_payload_tdata_reg;\n            output_eth_payload_tvalid_reg <= temp_eth_payload_tvalid_reg;\n            output_eth_payload_tlast_reg <= temp_eth_payload_tlast_reg;\n            output_eth_payload_tuser_reg <= temp_eth_payload_tuser_reg;\n            temp_eth_payload_tdata_reg <= 0;\n            temp_eth_payload_tvalid_reg <= 0;\n            temp_eth_payload_tlast_reg <= 0;\n            temp_eth_payload_tuser_reg <= 0;\n        end\n    end\nend\n\nendmodule\n"], ["verilog-ethernet/rtl/eth_axis_rx.v@306:355", "assign output_eth_payload_tdata = output_eth_payload_tdata_reg;\nassign output_eth_payload_tvalid = output_eth_payload_tvalid_reg;\nassign output_eth_payload_tlast = output_eth_payload_tlast_reg;\nassign output_eth_payload_tuser = output_eth_payload_tuser_reg;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        output_eth_payload_tdata_reg <= 0;\n        output_eth_payload_tvalid_reg <= 0;\n        output_eth_payload_tlast_reg <= 0;\n        output_eth_payload_tuser_reg <= 0;\n        output_eth_payload_tready_int <= 0;\n        temp_eth_payload_tdata_reg <= 0;\n        temp_eth_payload_tvalid_reg <= 0;\n        temp_eth_payload_tlast_reg <= 0;\n        temp_eth_payload_tuser_reg <= 0;\n    end else begin\n        // transfer sink ready state to source\n        output_eth_payload_tready_int <= output_eth_payload_tready_int_early;\n\n        if (output_eth_payload_tready_int) begin\n            // input is ready\n            if (output_eth_payload_tready | ~output_eth_payload_tvalid_reg) begin\n                // output is ready or currently not valid, transfer data to output\n                output_eth_payload_tdata_reg <= output_eth_payload_tdata_int;\n                output_eth_payload_tvalid_reg <= output_eth_payload_tvalid_int;\n                output_eth_payload_tlast_reg <= output_eth_payload_tlast_int;\n                output_eth_payload_tuser_reg <= output_eth_payload_tuser_int;\n            end else begin\n                // output is not ready and currently valid, store input in temp\n                temp_eth_payload_tdata_reg <= output_eth_payload_tdata_int;\n                temp_eth_payload_tvalid_reg <= output_eth_payload_tvalid_int;\n                temp_eth_payload_tlast_reg <= output_eth_payload_tlast_int;\n                temp_eth_payload_tuser_reg <= output_eth_payload_tuser_int;\n            end\n        end else if (output_eth_payload_tready) begin\n            // input is not ready, but output is ready\n            output_eth_payload_tdata_reg <= temp_eth_payload_tdata_reg;\n            output_eth_payload_tvalid_reg <= temp_eth_payload_tvalid_reg;\n            output_eth_payload_tlast_reg <= temp_eth_payload_tlast_reg;\n            output_eth_payload_tuser_reg <= temp_eth_payload_tuser_reg;\n            temp_eth_payload_tdata_reg <= 0;\n            temp_eth_payload_tvalid_reg <= 0;\n            temp_eth_payload_tlast_reg <= 0;\n            temp_eth_payload_tuser_reg <= 0;\n        end\n    end\nend\n\nendmodule\n"]], "Diff Content": {"Delete": [[288, "        output_eth_payload_tdata_reg <= 0;\n"], [289, "        output_eth_payload_tvalid_reg <= 0;\n"], [290, "        output_eth_payload_tlast_reg <= 0;\n"], [291, "        output_eth_payload_tuser_reg <= 0;\n"], [292, "        output_eth_payload_tready_int <= 0;\n"], [293, "        temp_axis_tdata_reg <= 0;\n"], [294, "        temp_axis_tvalid_reg <= 0;\n"], [295, "        temp_axis_tlast_reg <= 0;\n"], [296, "        temp_axis_tuser_reg <= 0;\n"], [299, "        output_eth_payload_tready_int <= output_eth_payload_tready_int_early;\n"], [301, "        if (output_eth_payload_tready_int) begin\n"], [303, "            if (output_eth_payload_tready | ~output_eth_payload_tvalid_reg) begin\n"], [305, "                output_eth_payload_tdata_reg <= output_eth_payload_tdata_int;\n"], [306, "                output_eth_payload_tvalid_reg <= output_eth_payload_tvalid_int;\n"], [307, "                output_eth_payload_tlast_reg <= output_eth_payload_tlast_int;\n"], [308, "                output_eth_payload_tuser_reg <= output_eth_payload_tuser_int;\n"], [309, "            end else begin\n"], [311, "                temp_axis_tdata_reg <= output_eth_payload_tdata_int;\n"], [312, "                temp_axis_tvalid_reg <= output_eth_payload_tvalid_int;\n"], [313, "                temp_axis_tlast_reg <= output_eth_payload_tlast_int;\n"], [314, "                temp_axis_tuser_reg <= output_eth_payload_tuser_int;\n"], [315, "            end\n"], [316, "        end else if (output_eth_payload_tready) begin\n"], [318, "            output_eth_payload_tdata_reg <= temp_axis_tdata_reg;\n"], [319, "            output_eth_payload_tvalid_reg <= temp_axis_tvalid_reg;\n"], [320, "            output_eth_payload_tlast_reg <= temp_axis_tlast_reg;\n"], [321, "            output_eth_payload_tuser_reg <= temp_axis_tuser_reg;\n"], [322, "            temp_axis_tdata_reg <= 0;\n"], [323, "            temp_axis_tvalid_reg <= 0;\n"], [324, "            temp_axis_tlast_reg <= 0;\n"], [325, "            temp_axis_tuser_reg <= 0;\n"], [326, "        end\n"]], "Add": [[296, "        output_eth_payload_tvalid_reg <= 1'b0;\n"], [296, "        output_eth_payload_tready_int_reg <= 1'b0;\n"], [296, "        temp_eth_payload_tvalid_reg <= 1'b0;\n"], [326, "        output_eth_payload_tvalid_reg <= output_eth_payload_tvalid_next;\n"], [326, "        output_eth_payload_tready_int_reg <= output_eth_payload_tready_int_early;\n"], [326, "        temp_eth_payload_tvalid_reg <= temp_eth_payload_tvalid_next;\n"], [326, "    end\n"], [326, "    if (store_eth_payload_int_to_output) begin\n"], [326, "        output_eth_payload_tdata_reg <= output_eth_payload_tdata_int;\n"], [326, "        output_eth_payload_tlast_reg <= output_eth_payload_tlast_int;\n"], [326, "        output_eth_payload_tuser_reg <= output_eth_payload_tuser_int;\n"], [326, "    end else if (store_eth_payload_temp_to_output) begin\n"], [326, "        output_eth_payload_tdata_reg <= temp_eth_payload_tdata_reg;\n"], [326, "        output_eth_payload_tlast_reg <= temp_eth_payload_tlast_reg;\n"], [326, "        output_eth_payload_tuser_reg <= temp_eth_payload_tuser_reg;\n"], [326, "    end\n"], [326, "    if (store_eth_payload_int_to_temp) begin\n"], [326, "        temp_eth_payload_tdata_reg <= output_eth_payload_tdata_int;\n"], [326, "        temp_eth_payload_tlast_reg <= output_eth_payload_tlast_int;\n"], [326, "        temp_eth_payload_tuser_reg <= output_eth_payload_tuser_int;\n"]]}}