{"Source Block": ["verilog-ethernet/rtl/eth_axis_tx.v@246:256@HdlStmAssign", "assign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        output_axis_tdata_reg <= 0;\n        output_axis_tvalid_reg <= 0;\n"], "Clone Blocks": [["verilog-ethernet/rtl/axis_eth_fcs_check.v@262:272", "reg        temp_axis_tvalid_reg = 0;\nreg        temp_axis_tlast_reg = 0;\nreg        temp_axis_tuser_reg = 0;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n"], ["verilog-ethernet/rtl/eth_axis_tx_64.v@349:359", "reg        temp_axis_tuser_reg = 0;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n"], ["verilog-ethernet/rtl/axis_eth_fcs_insert_64.v@576:586", "\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nalways @(posedge clk) begin\n"], ["verilog-ethernet/rtl/axis_eth_fcs_check_64.v@357:367", "reg        temp_axis_tuser_reg = 0;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\n"], ["verilog-ethernet/lib/axis/rtl/axis_mux_4.v@228:238", "reg store_axis_int_to_temp;\nreg store_axis_temp_to_output;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\n"], ["verilog-ethernet/lib/axis/rtl/axis_adapter.v@407:417", "reg store_axis_temp_to_output;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\n"], ["verilog-ethernet/lib/axis/rtl/axis_frame_join_4.v@337:347", "reg store_axis_temp_to_output;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\nalways @* begin\n"], ["verilog-ethernet/rtl/axis_eth_fcs_insert_64.v@574:584", "reg        temp_axis_tlast_reg = 0;\nreg        temp_axis_tuser_reg = 0;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n"], ["verilog-ethernet/lib/axis/rtl/axis_frame_join_4.v@340:350", "assign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\nalways @* begin\n    // transfer sink ready state to source\n    output_axis_tvalid_next = output_axis_tvalid_reg;\n    temp_axis_tvalid_next = temp_axis_tvalid_reg;\n"], ["verilog-ethernet/lib/axis/rtl/axis_mux_4.v@232:242", "assign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\nalways @* begin\n    // transfer sink ready state to source\n    output_axis_tvalid_next = output_axis_tvalid_reg;\n    temp_axis_tvalid_next = temp_axis_tvalid_reg;\n"], ["verilog-ethernet/rtl/axis_eth_fcs_insert.v@290:300", "assign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        output_axis_tdata_reg <= 0;\n        output_axis_tvalid_reg <= 0;\n"], ["verilog-ethernet/rtl/axis_eth_fcs_check_64.v@361:371", "assign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        output_axis_tdata_reg <= 0;\n        output_axis_tkeep_reg <= 0;\n"], ["verilog-ethernet/rtl/axis_eth_fcs_insert_64.v@575:585", "reg        temp_axis_tuser_reg = 0;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\n"], ["verilog-ethernet/rtl/eth_axis_tx_64.v@351:361", "// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\nalways @(posedge clk) begin\n    if (rst) begin\n"], ["verilog-ethernet/lib/axis/rtl/axis_stat_counter.v@282:292", "reg store_axis_int_to_temp;\nreg store_axis_temp_to_output;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\n"], ["verilog-ethernet/lib/axis/rtl/axis_tap_64.v@199:209", "assign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\nalways @* begin\n    // transfer sink ready state to source\n    output_axis_tvalid_next = output_axis_tvalid_reg;\n    temp_axis_tvalid_next = temp_axis_tvalid_reg;\n"], ["verilog-ethernet/lib/axis/rtl/axis_rate_limit.v@142:152", "assign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\nalways @* begin\n    // transfer sink ready state to source\n    output_axis_tvalid_next = output_axis_tvalid_reg;\n    temp_axis_tvalid_next = temp_axis_tvalid_reg;\n"], ["verilog-ethernet/rtl/axis_eth_fcs_check.v@263:273", "reg        temp_axis_tlast_reg = 0;\nreg        temp_axis_tuser_reg = 0;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\n"], ["verilog-ethernet/lib/axis/rtl/axis_register.v@80:90", "assign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nwire input_axis_tready_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~input_axis_tvalid));\n\nalways @* begin\n    // transfer sink ready state to source\n    output_axis_tvalid_next = output_axis_tvalid_reg;\n    temp_axis_tvalid_next = temp_axis_tvalid_reg;\n"], ["verilog-ethernet/rtl/axis_eth_fcs_insert_64.v@579:589", "assign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        output_axis_tdata_reg <= 0;\n        output_axis_tkeep_reg <= 0;\n"], ["verilog-ethernet/lib/axis/rtl/axis_tap_64.v@195:205", "reg store_axis_temp_to_output;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\n"], ["verilog-ethernet/rtl/eth_axis_tx.v@241:251", "reg        temp_axis_tvalid_reg = 0;\nreg        temp_axis_tlast_reg = 0;\nreg        temp_axis_tuser_reg = 0;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n"], ["verilog-ethernet/rtl/axis_eth_fcs_check.v@267:277", "assign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        output_axis_tdata_reg <= 0;\n        output_axis_tvalid_reg <= 0;\n"], ["verilog-ethernet/rtl/eth_axis_tx.v@243:253", "reg        temp_axis_tuser_reg = 0;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nalways @(posedge clk) begin\n"], ["verilog-ethernet/lib/axis/rtl/axis_register.v@77:87", "assign input_axis_tready = input_axis_tready_reg;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nwire input_axis_tready_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~input_axis_tvalid));\n\nalways @* begin\n"], ["verilog-ethernet/rtl/axis_eth_fcs_insert.v@285:295", "reg        temp_axis_tvalid_reg = 0;\nreg        temp_axis_tlast_reg = 0;\nreg        temp_axis_tuser_reg = 0;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n"], ["verilog-ethernet/rtl/axis_eth_fcs_check.v@264:274", "reg        temp_axis_tuser_reg = 0;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nalways @(posedge clk) begin\n"], ["verilog-ethernet/lib/axis/rtl/axis_frame_join_4.v@336:346", "reg store_axis_int_to_temp;\nreg store_axis_temp_to_output;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\n"], ["verilog-ethernet/lib/axis/rtl/axis_mux_64_4.v@249:259", "assign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\nalways @* begin\n    // transfer sink ready state to source\n    output_axis_tvalid_next = output_axis_tvalid_reg;\n    temp_axis_tvalid_next = temp_axis_tvalid_reg;\n"], ["verilog-ethernet/lib/axis/rtl/axis_rate_limit_64.v@146:156", "reg store_axis_temp_to_output;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\n"], ["verilog-ethernet/lib/axis/rtl/axis_rate_limit_64.v@150:160", "assign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\nalways @* begin\n    // transfer sink ready state to source\n    output_axis_tvalid_next = output_axis_tvalid_reg;\n    temp_axis_tvalid_next = temp_axis_tvalid_reg;\n"], ["verilog-ethernet/rtl/axis_eth_fcs_check_64.v@356:366", "reg        temp_axis_tlast_reg = 0;\nreg        temp_axis_tuser_reg = 0;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n"], ["verilog-ethernet/lib/axis/rtl/axis_tap_64.v@196:206", "\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\nalways @* begin\n"], ["verilog-ethernet/lib/axis/rtl/axis_frame_length_adjust.v@494:504", "assign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\nalways @* begin\n    // transfer sink ready state to source\n    output_axis_tvalid_next = output_axis_tvalid_reg;\n    temp_axis_tvalid_next = temp_axis_tvalid_reg;\n"], ["verilog-ethernet/lib/axis/rtl/axis_frame_length_adjust.v@490:500", "reg store_axis_temp_to_output;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\n"], ["verilog-ethernet/rtl/axis_eth_fcs_insert.v@286:296", "reg        temp_axis_tlast_reg = 0;\nreg        temp_axis_tuser_reg = 0;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\n"], ["verilog-ethernet/lib/axis/rtl/axis_tap.v@188:198", "assign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\nalways @* begin\n    // transfer sink ready state to source\n    output_axis_tvalid_next = output_axis_tvalid_reg;\n    temp_axis_tvalid_next = temp_axis_tvalid_reg;\n"], ["verilog-ethernet/rtl/eth_axis_tx_64.v@347:357", "reg        temp_axis_tvalid_reg = 0;\nreg        temp_axis_tlast_reg = 0;\nreg        temp_axis_tuser_reg = 0;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\n"], ["verilog-ethernet/lib/axis/rtl/axis_register_64.v@83:93", "\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nwire input_axis_tready_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~input_axis_tvalid));\n\nalways @* begin\n"], ["verilog-ethernet/lib/axis/rtl/axis_tap.v@184:194", "reg store_axis_int_to_temp;\nreg store_axis_temp_to_output;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\n"], ["verilog-ethernet/lib/axis/rtl/axis_frame_length_adjust.v@491:501", "\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\nalways @* begin\n"], ["verilog-ethernet/rtl/eth_axis_tx_64.v@350:360", "\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\nalways @(posedge clk) begin\n"], ["verilog-ethernet/lib/axis/rtl/axis_mux_64_4.v@246:256", "\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\nalways @* begin\n"], ["verilog-ethernet/lib/axis/rtl/axis_stat_counter.v@283:293", "reg store_axis_temp_to_output;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\nalways @* begin\n"], ["verilog-ethernet/rtl/axis_eth_fcs_insert.v@287:297", "reg        temp_axis_tuser_reg = 0;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nalways @(posedge clk) begin\n"], ["verilog-ethernet/lib/axis/rtl/axis_rate_limit.v@138:148", "reg store_axis_int_to_temp;\nreg store_axis_temp_to_output;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\n"], ["verilog-ethernet/lib/axis/rtl/axis_adapter.v@408:418", "\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\nalways @* begin\n"], ["verilog-ethernet/lib/axis/rtl/axis_stat_counter.v@286:296", "assign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\nalways @* begin\n    // transfer sink ready state to source\n    output_axis_tvalid_next = output_axis_tvalid_reg;\n    temp_axis_tvalid_next = temp_axis_tvalid_reg;\n"], ["verilog-ethernet/lib/axis/rtl/axis_adapter.v@411:421", "assign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\nalways @* begin\n    // transfer sink ready state to source\n    output_axis_tvalid_next = output_axis_tvalid_reg;\n    temp_axis_tvalid_next = temp_axis_tvalid_reg;\n"], ["verilog-ethernet/lib/axis/rtl/axis_rate_limit_64.v@147:157", "\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\nalways @* begin\n"], ["verilog-ethernet/lib/axis/rtl/axis_tap.v@185:195", "reg store_axis_temp_to_output;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\nalways @* begin\n"], ["verilog-ethernet/lib/axis/rtl/axis_rate_limit.v@139:149", "reg store_axis_temp_to_output;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\nalways @* begin\n"], ["verilog-ethernet/rtl/eth_axis_tx.v@242:252", "reg        temp_axis_tlast_reg = 0;\nreg        temp_axis_tuser_reg = 0;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\n"], ["verilog-ethernet/lib/axis/rtl/axis_register_64.v@86:96", "assign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nwire input_axis_tready_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~input_axis_tvalid));\n\nalways @* begin\n    // transfer sink ready state to source\n    output_axis_tvalid_next = output_axis_tvalid_reg;\n    temp_axis_tvalid_next = temp_axis_tvalid_reg;\n"], ["verilog-ethernet/lib/axis/rtl/axis_mux_4.v@229:239", "reg store_axis_temp_to_output;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\nalways @* begin\n"], ["verilog-ethernet/rtl/axis_eth_fcs_check_64.v@358:368", "\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or if there is space in both output registers or if there is space in the temp register that will not be filled next cycle\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nalways @(posedge clk) begin\n"], ["verilog-ethernet/lib/axis/rtl/axis_mux_64_4.v@245:255", "reg store_axis_temp_to_output;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\n// enable ready input next cycle if output is ready or the temp reg will not be filled on the next cycle (output reg empty or no input)\nassign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n\n"], ["verilog-ethernet/rtl/eth_axis_tx_64.v@352:362", "assign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tkeep = output_axis_tkeep_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        output_axis_tdata_reg <= 0;\n"]], "Diff Content": {"Delete": [[251, "assign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & ~output_axis_tvalid_reg) | (~temp_axis_tvalid_reg & ~output_axis_tvalid_int);\n"]], "Add": [[251, "assign output_axis_tready_int_early = output_axis_tready | (~temp_axis_tvalid_reg & (~output_axis_tvalid_reg | ~output_axis_tvalid_int));\n"], [251, "always @* begin\n"], [251, "    output_axis_tvalid_next = output_axis_tvalid_reg;\n"], [251, "    temp_axis_tvalid_next = temp_axis_tvalid_reg;\n"], [251, "    store_axis_int_to_output = 1'b0;\n"], [251, "    store_axis_int_to_temp = 1'b0;\n"], [251, "    store_axis_temp_to_output = 1'b0;\n"], [251, "    if (output_axis_tready_int_reg) begin\n"], [251, "        if (output_axis_tready | ~output_axis_tvalid_reg) begin\n"], [251, "            output_axis_tvalid_next = output_axis_tvalid_int;\n"], [251, "            store_axis_int_to_output = 1'b1;\n"], [251, "        end else begin\n"], [251, "            temp_axis_tvalid_next = output_axis_tvalid_int;\n"], [251, "            store_axis_int_to_temp = 1'b1;\n"], [251, "        end\n"], [251, "    end else if (output_axis_tready) begin\n"], [251, "        output_axis_tvalid_next = temp_axis_tvalid_reg;\n"], [251, "        temp_axis_tvalid_next = 1'b0;\n"], [251, "        store_axis_temp_to_output = 1'b1;\n"], [251, "    end\n"], [251, "end\n"]]}}