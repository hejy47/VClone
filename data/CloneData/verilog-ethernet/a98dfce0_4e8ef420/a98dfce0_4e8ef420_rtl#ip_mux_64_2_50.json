{"Source Block": ["verilog-ethernet/rtl/ip_mux_64_2.v@269:353@HdlStmProcess", "            current_input_tuser = input_1_ip_payload_tuser;\n        end\n    endcase\nend\n\nalways @* begin\n    select_next = select_reg;\n    frame_next = frame_reg;\n\n    input_0_ip_hdr_ready_next = input_0_ip_hdr_ready_reg & ~input_0_ip_hdr_valid;\n    input_1_ip_hdr_ready_next = input_1_ip_hdr_ready_reg & ~input_1_ip_hdr_valid;\n\n    input_0_ip_payload_tready_next = 0;\n    input_1_ip_payload_tready_next = 0;\n\n    output_ip_hdr_valid_next = output_ip_hdr_valid_reg & ~output_ip_hdr_ready;\n    output_eth_dest_mac_next = output_eth_dest_mac_reg;\n    output_eth_src_mac_next = output_eth_src_mac_reg;\n    output_eth_type_next = output_eth_type_reg;\n    output_ip_version_next = output_ip_version_reg;\n    output_ip_ihl_next = output_ip_ihl_reg;\n    output_ip_dscp_next = output_ip_dscp_reg;\n    output_ip_ecn_next = output_ip_ecn_reg;\n    output_ip_length_next = output_ip_length_reg;\n    output_ip_identification_next = output_ip_identification_reg;\n    output_ip_flags_next = output_ip_flags_reg;\n    output_ip_fragment_offset_next = output_ip_fragment_offset_reg;\n    output_ip_ttl_next = output_ip_ttl_reg;\n    output_ip_protocol_next = output_ip_protocol_reg;\n    output_ip_header_checksum_next = output_ip_header_checksum_reg;\n    output_ip_source_ip_next = output_ip_source_ip_reg;\n    output_ip_dest_ip_next = output_ip_dest_ip_reg;\n\n    if (frame_reg) begin\n        if (current_input_tvalid & current_input_tready) begin\n            // end of frame detection\n            frame_next = ~current_input_tlast;\n        end\n    end else if (enable & ~output_ip_hdr_valid & selected_input_ip_hdr_valid) begin\n        // start of frame, grab select value\n        frame_next = 1;\n        select_next = select;\n\n        case (select_next)\n            1'd0: input_0_ip_hdr_ready_next = 1;\n            1'd1: input_1_ip_hdr_ready_next = 1;\n        endcase\n\n        output_ip_hdr_valid_next = 1;\n        output_eth_dest_mac_next = selected_input_eth_dest_mac;\n        output_eth_src_mac_next = selected_input_eth_src_mac;\n        output_eth_type_next = selected_input_eth_type;\n        output_ip_version_next = selected_input_ip_version;\n        output_ip_ihl_next = selected_input_ip_ihl;\n        output_ip_dscp_next = selected_input_ip_dscp;\n        output_ip_ecn_next = selected_input_ip_ecn;\n        output_ip_length_next = selected_input_ip_length;\n        output_ip_identification_next = selected_input_ip_identification;\n        output_ip_flags_next = selected_input_ip_flags;\n        output_ip_fragment_offset_next = selected_input_ip_fragment_offset;\n        output_ip_ttl_next = selected_input_ip_ttl;\n        output_ip_protocol_next = selected_input_ip_protocol;\n        output_ip_header_checksum_next = selected_input_ip_header_checksum;\n        output_ip_source_ip_next = selected_input_ip_source_ip;\n        output_ip_dest_ip_next = selected_input_ip_dest_ip;\n    end\n\n    // generate ready signal on selected port\n    case (select_next)\n        1'd0: input_0_ip_payload_tready_next = output_ip_payload_tready_int_early & frame_next;\n        1'd1: input_1_ip_payload_tready_next = output_ip_payload_tready_int_early & frame_next;\n    endcase\n\n    // pass through selected packet data\n    output_ip_payload_tdata_int = current_input_tdata;\n    output_ip_payload_tkeep_int = current_input_tkeep;\n    output_ip_payload_tvalid_int = current_input_tvalid & current_input_tready & frame_reg;\n    output_ip_payload_tlast_int = current_input_tlast;\n    output_ip_payload_tuser_int = current_input_tuser;\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        select_reg <= 0;\n        frame_reg <= 0;\n"], "Clone Blocks": [["verilog-ethernet/rtl/udp_demux_4.v@349:436", "            current_output_tready = output_3_udp_payload_tready;\n        end\n    endcase\nend\n\nalways @* begin\n    select_next = select_reg;\n    frame_next = frame_reg;\n\n    input_udp_hdr_ready_next = input_udp_hdr_ready_reg & ~input_udp_hdr_valid;\n    input_udp_payload_tready_next = 0;\n    output_0_udp_hdr_valid_next = output_0_udp_hdr_valid_reg & ~output_0_udp_hdr_ready;\n    output_1_udp_hdr_valid_next = output_1_udp_hdr_valid_reg & ~output_1_udp_hdr_ready;\n    output_2_udp_hdr_valid_next = output_2_udp_hdr_valid_reg & ~output_2_udp_hdr_ready;\n    output_3_udp_hdr_valid_next = output_3_udp_hdr_valid_reg & ~output_3_udp_hdr_ready;\n    output_eth_dest_mac_next = output_eth_dest_mac_reg;\n    output_eth_src_mac_next = output_eth_src_mac_reg;\n    output_eth_type_next = output_eth_type_reg;\n    output_ip_version_next = output_ip_version_reg;\n    output_ip_ihl_next = output_ip_ihl_reg;\n    output_ip_dscp_next = output_ip_dscp_reg;\n    output_ip_ecn_next = output_ip_ecn_reg;\n    output_ip_length_next = output_ip_length_reg;\n    output_ip_identification_next = output_ip_identification_reg;\n    output_ip_flags_next = output_ip_flags_reg;\n    output_ip_fragment_offset_next = output_ip_fragment_offset_reg;\n    output_ip_ttl_next = output_ip_ttl_reg;\n    output_ip_protocol_next = output_ip_protocol_reg;\n    output_ip_header_checksum_next = output_ip_header_checksum_reg;\n    output_ip_source_ip_next = output_ip_source_ip_reg;\n    output_ip_dest_ip_next = output_ip_dest_ip_reg;\n    output_udp_source_port_next = output_udp_source_port_reg;\n    output_udp_dest_port_next = output_udp_dest_port_reg;\n    output_udp_length_next = output_udp_length_reg;\n    output_udp_checksum_next = output_udp_checksum_reg;\n\n    if (frame_reg) begin\n        if (input_udp_payload_tvalid & input_udp_payload_tready) begin\n            // end of frame detection\n            frame_next = ~input_udp_payload_tlast;\n        end\n    end else if (enable & input_udp_hdr_valid & ~current_output_udp_hdr_valid & ~current_output_tvalid) begin\n        // start of frame, grab select value\n        frame_next = 1;\n        select_next = select;\n\n        input_udp_hdr_ready_next = 1;\n\n        case (select)\n            2'd0: output_0_udp_hdr_valid_next = 1;\n            2'd1: output_1_udp_hdr_valid_next = 1;\n            2'd2: output_2_udp_hdr_valid_next = 1;\n            2'd3: output_3_udp_hdr_valid_next = 1;\n        endcase\n        output_eth_dest_mac_next = input_eth_dest_mac;\n        output_eth_src_mac_next = input_eth_src_mac;\n        output_eth_type_next = input_eth_type;\n        output_ip_version_next = input_ip_version;\n        output_ip_ihl_next = input_ip_ihl;\n        output_ip_dscp_next = input_ip_dscp;\n        output_ip_ecn_next = input_ip_ecn;\n        output_ip_length_next = input_ip_length;\n        output_ip_identification_next = input_ip_identification;\n        output_ip_flags_next = input_ip_flags;\n        output_ip_fragment_offset_next = input_ip_fragment_offset;\n        output_ip_ttl_next = input_ip_ttl;\n        output_ip_protocol_next = input_ip_protocol;\n        output_ip_header_checksum_next = input_ip_header_checksum;\n        output_ip_source_ip_next = input_ip_source_ip;\n        output_ip_dest_ip_next = input_ip_dest_ip;\n        output_udp_source_port_next = input_udp_source_port;\n        output_udp_dest_port_next = input_udp_dest_port;\n        output_udp_length_next = input_udp_length;\n        output_udp_checksum_next = input_udp_checksum;\n    end\n\n    input_udp_payload_tready_next = output_udp_payload_tready_int_early & frame_next;\n\n    output_udp_payload_tdata_int = input_udp_payload_tdata;\n    output_udp_payload_tvalid_int = input_udp_payload_tvalid & input_udp_payload_tready;\n    output_udp_payload_tlast_int = input_udp_payload_tlast;\n    output_udp_payload_tuser_int = input_udp_payload_tuser;\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        select_reg <= 0;\n        frame_reg <= 0;\n"], ["verilog-ethernet/rtl/udp_mux_4.v@418:517", "            current_input_tuser = input_3_udp_payload_tuser;\n        end\n    endcase\nend\n\nalways @* begin\n    select_next = select_reg;\n    frame_next = frame_reg;\n\n    input_0_udp_hdr_ready_next = input_0_udp_hdr_ready_reg & ~input_0_udp_hdr_valid;\n    input_1_udp_hdr_ready_next = input_1_udp_hdr_ready_reg & ~input_1_udp_hdr_valid;\n    input_2_udp_hdr_ready_next = input_2_udp_hdr_ready_reg & ~input_2_udp_hdr_valid;\n    input_3_udp_hdr_ready_next = input_3_udp_hdr_ready_reg & ~input_3_udp_hdr_valid;\n\n    input_0_udp_payload_tready_next = 0;\n    input_1_udp_payload_tready_next = 0;\n    input_2_udp_payload_tready_next = 0;\n    input_3_udp_payload_tready_next = 0;\n\n    output_udp_hdr_valid_next = output_udp_hdr_valid_reg & ~output_udp_hdr_ready;\n    output_eth_dest_mac_next = output_eth_dest_mac_reg;\n    output_eth_src_mac_next = output_eth_src_mac_reg;\n    output_eth_type_next = output_eth_type_reg;\n    output_ip_version_next = output_ip_version_reg;\n    output_ip_ihl_next = output_ip_ihl_reg;\n    output_ip_dscp_next = output_ip_dscp_reg;\n    output_ip_ecn_next = output_ip_ecn_reg;\n    output_ip_length_next = output_ip_length_reg;\n    output_ip_identification_next = output_ip_identification_reg;\n    output_ip_flags_next = output_ip_flags_reg;\n    output_ip_fragment_offset_next = output_ip_fragment_offset_reg;\n    output_ip_ttl_next = output_ip_ttl_reg;\n    output_ip_protocol_next = output_ip_protocol_reg;\n    output_ip_header_checksum_next = output_ip_header_checksum_reg;\n    output_ip_source_ip_next = output_ip_source_ip_reg;\n    output_ip_dest_ip_next = output_ip_dest_ip_reg;\n    output_udp_source_port_next = output_udp_source_port_reg;\n    output_udp_dest_port_next = output_udp_dest_port_reg;\n    output_udp_length_next = output_udp_length_reg;\n    output_udp_checksum_next = output_udp_checksum_reg;\n\n    if (frame_reg) begin\n        if (current_input_tvalid & current_input_tready) begin\n            // end of frame detection\n            frame_next = ~current_input_tlast;\n        end\n    end else if (enable & ~output_udp_hdr_valid & selected_input_udp_hdr_valid) begin\n        // start of frame, grab select value\n        frame_next = 1;\n        select_next = select;\n\n        case (select_next)\n            2'd0: input_0_udp_hdr_ready_next = 1;\n            2'd1: input_1_udp_hdr_ready_next = 1;\n            2'd2: input_2_udp_hdr_ready_next = 1;\n            2'd3: input_3_udp_hdr_ready_next = 1;\n        endcase\n\n        output_udp_hdr_valid_next = 1;\n        output_eth_dest_mac_next = selected_input_eth_dest_mac;\n        output_eth_src_mac_next = selected_input_eth_src_mac;\n        output_eth_type_next = selected_input_eth_type;\n        output_ip_version_next = selected_input_ip_version;\n        output_ip_ihl_next = selected_input_ip_ihl;\n        output_ip_dscp_next = selected_input_ip_dscp;\n        output_ip_ecn_next = selected_input_ip_ecn;\n        output_ip_length_next = selected_input_ip_length;\n        output_ip_identification_next = selected_input_ip_identification;\n        output_ip_flags_next = selected_input_ip_flags;\n        output_ip_fragment_offset_next = selected_input_ip_fragment_offset;\n        output_ip_ttl_next = selected_input_ip_ttl;\n        output_ip_protocol_next = selected_input_ip_protocol;\n        output_ip_header_checksum_next = selected_input_ip_header_checksum;\n        output_ip_source_ip_next = selected_input_ip_source_ip;\n        output_ip_dest_ip_next = selected_input_ip_dest_ip;\n        output_udp_source_port_next = selected_input_udp_source_port;\n        output_udp_dest_port_next = selected_input_udp_dest_port;\n        output_udp_length_next = selected_input_udp_length;\n        output_udp_checksum_next = selected_input_udp_checksum;\n    end\n\n    // generate ready signal on selected port\n    case (select_next)\n        2'd0: input_0_udp_payload_tready_next = output_udp_payload_tready_int_early & frame_next;\n        2'd1: input_1_udp_payload_tready_next = output_udp_payload_tready_int_early & frame_next;\n        2'd2: input_2_udp_payload_tready_next = output_udp_payload_tready_int_early & frame_next;\n        2'd3: input_3_udp_payload_tready_next = output_udp_payload_tready_int_early & frame_next;\n    endcase\n\n    // pass through selected packet data\n    output_udp_payload_tdata_int = current_input_tdata;\n    output_udp_payload_tvalid_int = current_input_tvalid & current_input_tready & frame_reg;\n    output_udp_payload_tlast_int = current_input_tlast;\n    output_udp_payload_tuser_int = current_input_tuser;\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        select_reg <= 0;\n        frame_reg <= 0;\n"], ["verilog-ethernet/rtl/udp_demux_64_4.v@355:443", "            current_output_tready = output_3_udp_payload_tready;\n        end\n    endcase\nend\n\nalways @* begin\n    select_next = select_reg;\n    frame_next = frame_reg;\n\n    input_udp_hdr_ready_next = input_udp_hdr_ready_reg & ~input_udp_hdr_valid;\n    input_udp_payload_tready_next = 0;\n    output_0_udp_hdr_valid_next = output_0_udp_hdr_valid_reg & ~output_0_udp_hdr_ready;\n    output_1_udp_hdr_valid_next = output_1_udp_hdr_valid_reg & ~output_1_udp_hdr_ready;\n    output_2_udp_hdr_valid_next = output_2_udp_hdr_valid_reg & ~output_2_udp_hdr_ready;\n    output_3_udp_hdr_valid_next = output_3_udp_hdr_valid_reg & ~output_3_udp_hdr_ready;\n    output_eth_dest_mac_next = output_eth_dest_mac_reg;\n    output_eth_src_mac_next = output_eth_src_mac_reg;\n    output_eth_type_next = output_eth_type_reg;\n    output_ip_version_next = output_ip_version_reg;\n    output_ip_ihl_next = output_ip_ihl_reg;\n    output_ip_dscp_next = output_ip_dscp_reg;\n    output_ip_ecn_next = output_ip_ecn_reg;\n    output_ip_length_next = output_ip_length_reg;\n    output_ip_identification_next = output_ip_identification_reg;\n    output_ip_flags_next = output_ip_flags_reg;\n    output_ip_fragment_offset_next = output_ip_fragment_offset_reg;\n    output_ip_ttl_next = output_ip_ttl_reg;\n    output_ip_protocol_next = output_ip_protocol_reg;\n    output_ip_header_checksum_next = output_ip_header_checksum_reg;\n    output_ip_source_ip_next = output_ip_source_ip_reg;\n    output_ip_dest_ip_next = output_ip_dest_ip_reg;\n    output_udp_source_port_next = output_udp_source_port_reg;\n    output_udp_dest_port_next = output_udp_dest_port_reg;\n    output_udp_length_next = output_udp_length_reg;\n    output_udp_checksum_next = output_udp_checksum_reg;\n\n    if (frame_reg) begin\n        if (input_udp_payload_tvalid & input_udp_payload_tready) begin\n            // end of frame detection\n            frame_next = ~input_udp_payload_tlast;\n        end\n    end else if (enable & input_udp_hdr_valid & ~current_output_udp_hdr_valid & ~current_output_tvalid) begin\n        // start of frame, grab select value\n        frame_next = 1;\n        select_next = select;\n\n        input_udp_hdr_ready_next = 1;\n\n        case (select)\n            2'd0: output_0_udp_hdr_valid_next = 1;\n            2'd1: output_1_udp_hdr_valid_next = 1;\n            2'd2: output_2_udp_hdr_valid_next = 1;\n            2'd3: output_3_udp_hdr_valid_next = 1;\n        endcase\n        output_eth_dest_mac_next = input_eth_dest_mac;\n        output_eth_src_mac_next = input_eth_src_mac;\n        output_eth_type_next = input_eth_type;\n        output_ip_version_next = input_ip_version;\n        output_ip_ihl_next = input_ip_ihl;\n        output_ip_dscp_next = input_ip_dscp;\n        output_ip_ecn_next = input_ip_ecn;\n        output_ip_length_next = input_ip_length;\n        output_ip_identification_next = input_ip_identification;\n        output_ip_flags_next = input_ip_flags;\n        output_ip_fragment_offset_next = input_ip_fragment_offset;\n        output_ip_ttl_next = input_ip_ttl;\n        output_ip_protocol_next = input_ip_protocol;\n        output_ip_header_checksum_next = input_ip_header_checksum;\n        output_ip_source_ip_next = input_ip_source_ip;\n        output_ip_dest_ip_next = input_ip_dest_ip;\n        output_udp_source_port_next = input_udp_source_port;\n        output_udp_dest_port_next = input_udp_dest_port;\n        output_udp_length_next = input_udp_length;\n        output_udp_checksum_next = input_udp_checksum;\n    end\n\n    input_udp_payload_tready_next = output_udp_payload_tready_int_early & frame_next;\n\n    output_udp_payload_tdata_int = input_udp_payload_tdata;\n    output_udp_payload_tkeep_int = input_udp_payload_tkeep;\n    output_udp_payload_tvalid_int = input_udp_payload_tvalid & input_udp_payload_tready;\n    output_udp_payload_tlast_int = input_udp_payload_tlast;\n    output_udp_payload_tuser_int = input_udp_payload_tuser;\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        select_reg <= 0;\n        frame_reg <= 0;\n"], ["verilog-ethernet/rtl/ip_mux_64_4.v@381:473", "            current_input_tuser = input_3_ip_payload_tuser;\n        end\n    endcase\nend\n\nalways @* begin\n    select_next = select_reg;\n    frame_next = frame_reg;\n\n    input_0_ip_hdr_ready_next = input_0_ip_hdr_ready_reg & ~input_0_ip_hdr_valid;\n    input_1_ip_hdr_ready_next = input_1_ip_hdr_ready_reg & ~input_1_ip_hdr_valid;\n    input_2_ip_hdr_ready_next = input_2_ip_hdr_ready_reg & ~input_2_ip_hdr_valid;\n    input_3_ip_hdr_ready_next = input_3_ip_hdr_ready_reg & ~input_3_ip_hdr_valid;\n\n    input_0_ip_payload_tready_next = 0;\n    input_1_ip_payload_tready_next = 0;\n    input_2_ip_payload_tready_next = 0;\n    input_3_ip_payload_tready_next = 0;\n\n    output_ip_hdr_valid_next = output_ip_hdr_valid_reg & ~output_ip_hdr_ready;\n    output_eth_dest_mac_next = output_eth_dest_mac_reg;\n    output_eth_src_mac_next = output_eth_src_mac_reg;\n    output_eth_type_next = output_eth_type_reg;\n    output_ip_version_next = output_ip_version_reg;\n    output_ip_ihl_next = output_ip_ihl_reg;\n    output_ip_dscp_next = output_ip_dscp_reg;\n    output_ip_ecn_next = output_ip_ecn_reg;\n    output_ip_length_next = output_ip_length_reg;\n    output_ip_identification_next = output_ip_identification_reg;\n    output_ip_flags_next = output_ip_flags_reg;\n    output_ip_fragment_offset_next = output_ip_fragment_offset_reg;\n    output_ip_ttl_next = output_ip_ttl_reg;\n    output_ip_protocol_next = output_ip_protocol_reg;\n    output_ip_header_checksum_next = output_ip_header_checksum_reg;\n    output_ip_source_ip_next = output_ip_source_ip_reg;\n    output_ip_dest_ip_next = output_ip_dest_ip_reg;\n\n    if (frame_reg) begin\n        if (current_input_tvalid & current_input_tready) begin\n            // end of frame detection\n            frame_next = ~current_input_tlast;\n        end\n    end else if (enable & ~output_ip_hdr_valid & selected_input_ip_hdr_valid) begin\n        // start of frame, grab select value\n        frame_next = 1;\n        select_next = select;\n\n        case (select_next)\n            2'd0: input_0_ip_hdr_ready_next = 1;\n            2'd1: input_1_ip_hdr_ready_next = 1;\n            2'd2: input_2_ip_hdr_ready_next = 1;\n            2'd3: input_3_ip_hdr_ready_next = 1;\n        endcase\n\n        output_ip_hdr_valid_next = 1;\n        output_eth_dest_mac_next = selected_input_eth_dest_mac;\n        output_eth_src_mac_next = selected_input_eth_src_mac;\n        output_eth_type_next = selected_input_eth_type;\n        output_ip_version_next = selected_input_ip_version;\n        output_ip_ihl_next = selected_input_ip_ihl;\n        output_ip_dscp_next = selected_input_ip_dscp;\n        output_ip_ecn_next = selected_input_ip_ecn;\n        output_ip_length_next = selected_input_ip_length;\n        output_ip_identification_next = selected_input_ip_identification;\n        output_ip_flags_next = selected_input_ip_flags;\n        output_ip_fragment_offset_next = selected_input_ip_fragment_offset;\n        output_ip_ttl_next = selected_input_ip_ttl;\n        output_ip_protocol_next = selected_input_ip_protocol;\n        output_ip_header_checksum_next = selected_input_ip_header_checksum;\n        output_ip_source_ip_next = selected_input_ip_source_ip;\n        output_ip_dest_ip_next = selected_input_ip_dest_ip;\n    end\n\n    // generate ready signal on selected port\n    case (select_next)\n        2'd0: input_0_ip_payload_tready_next = output_ip_payload_tready_int_early & frame_next;\n        2'd1: input_1_ip_payload_tready_next = output_ip_payload_tready_int_early & frame_next;\n        2'd2: input_2_ip_payload_tready_next = output_ip_payload_tready_int_early & frame_next;\n        2'd3: input_3_ip_payload_tready_next = output_ip_payload_tready_int_early & frame_next;\n    endcase\n\n    // pass through selected packet data\n    output_ip_payload_tdata_int = current_input_tdata;\n    output_ip_payload_tkeep_int = current_input_tkeep;\n    output_ip_payload_tvalid_int = current_input_tvalid & current_input_tready & frame_reg;\n    output_ip_payload_tlast_int = current_input_tlast;\n    output_ip_payload_tuser_int = current_input_tuser;\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        select_reg <= 0;\n        frame_reg <= 0;\n"], ["verilog-ethernet/rtl/ip_demux_4.v@309:388", "            current_output_tready = output_3_ip_payload_tready;\n        end\n    endcase\nend\n\nalways @* begin\n    select_next = select_reg;\n    frame_next = frame_reg;\n\n    input_ip_hdr_ready_next = input_ip_hdr_ready_reg & ~input_ip_hdr_valid;\n    input_ip_payload_tready_next = 0;\n    output_0_ip_hdr_valid_next = output_0_ip_hdr_valid_reg & ~output_0_ip_hdr_ready;\n    output_1_ip_hdr_valid_next = output_1_ip_hdr_valid_reg & ~output_1_ip_hdr_ready;\n    output_2_ip_hdr_valid_next = output_2_ip_hdr_valid_reg & ~output_2_ip_hdr_ready;\n    output_3_ip_hdr_valid_next = output_3_ip_hdr_valid_reg & ~output_3_ip_hdr_ready;\n    output_eth_dest_mac_next = output_eth_dest_mac_reg;\n    output_eth_src_mac_next = output_eth_src_mac_reg;\n    output_eth_type_next = output_eth_type_reg;\n    output_ip_version_next = output_ip_version_reg;\n    output_ip_ihl_next = output_ip_ihl_reg;\n    output_ip_dscp_next = output_ip_dscp_reg;\n    output_ip_ecn_next = output_ip_ecn_reg;\n    output_ip_length_next = output_ip_length_reg;\n    output_ip_identification_next = output_ip_identification_reg;\n    output_ip_flags_next = output_ip_flags_reg;\n    output_ip_fragment_offset_next = output_ip_fragment_offset_reg;\n    output_ip_ttl_next = output_ip_ttl_reg;\n    output_ip_protocol_next = output_ip_protocol_reg;\n    output_ip_header_checksum_next = output_ip_header_checksum_reg;\n    output_ip_source_ip_next = output_ip_source_ip_reg;\n    output_ip_dest_ip_next = output_ip_dest_ip_reg;\n\n    if (frame_reg) begin\n        if (input_ip_payload_tvalid & input_ip_payload_tready) begin\n            // end of frame detection\n            frame_next = ~input_ip_payload_tlast;\n        end\n    end else if (enable & input_ip_hdr_valid & ~current_output_ip_hdr_valid & ~current_output_tvalid) begin\n        // start of frame, grab select value\n        frame_next = 1;\n        select_next = select;\n\n        input_ip_hdr_ready_next = 1;\n\n        case (select)\n            2'd0: output_0_ip_hdr_valid_next = 1;\n            2'd1: output_1_ip_hdr_valid_next = 1;\n            2'd2: output_2_ip_hdr_valid_next = 1;\n            2'd3: output_3_ip_hdr_valid_next = 1;\n        endcase\n        output_eth_dest_mac_next = input_eth_dest_mac;\n        output_eth_src_mac_next = input_eth_src_mac;\n        output_eth_type_next = input_eth_type;\n        output_ip_version_next = input_ip_version;\n        output_ip_ihl_next = input_ip_ihl;\n        output_ip_dscp_next = input_ip_dscp;\n        output_ip_ecn_next = input_ip_ecn;\n        output_ip_length_next = input_ip_length;\n        output_ip_identification_next = input_ip_identification;\n        output_ip_flags_next = input_ip_flags;\n        output_ip_fragment_offset_next = input_ip_fragment_offset;\n        output_ip_ttl_next = input_ip_ttl;\n        output_ip_protocol_next = input_ip_protocol;\n        output_ip_header_checksum_next = input_ip_header_checksum;\n        output_ip_source_ip_next = input_ip_source_ip;\n        output_ip_dest_ip_next = input_ip_dest_ip;\n    end\n\n    input_ip_payload_tready_next = output_ip_payload_tready_int_early & frame_next;\n\n    output_ip_payload_tdata_int = input_ip_payload_tdata;\n    output_ip_payload_tvalid_int = input_ip_payload_tvalid & input_ip_payload_tready;\n    output_ip_payload_tlast_int = input_ip_payload_tlast;\n    output_ip_payload_tuser_int = input_ip_payload_tuser;\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        select_reg <= 0;\n        frame_reg <= 0;\n"], ["verilog-ethernet/rtl/ip_mux_2.v@262:345", "            current_input_tuser = input_1_ip_payload_tuser;\n        end\n    endcase\nend\n\nalways @* begin\n    select_next = select_reg;\n    frame_next = frame_reg;\n\n    input_0_ip_hdr_ready_next = input_0_ip_hdr_ready_reg & ~input_0_ip_hdr_valid;\n    input_1_ip_hdr_ready_next = input_1_ip_hdr_ready_reg & ~input_1_ip_hdr_valid;\n\n    input_0_ip_payload_tready_next = 0;\n    input_1_ip_payload_tready_next = 0;\n\n    output_ip_hdr_valid_next = output_ip_hdr_valid_reg & ~output_ip_hdr_ready;\n    output_eth_dest_mac_next = output_eth_dest_mac_reg;\n    output_eth_src_mac_next = output_eth_src_mac_reg;\n    output_eth_type_next = output_eth_type_reg;\n    output_ip_version_next = output_ip_version_reg;\n    output_ip_ihl_next = output_ip_ihl_reg;\n    output_ip_dscp_next = output_ip_dscp_reg;\n    output_ip_ecn_next = output_ip_ecn_reg;\n    output_ip_length_next = output_ip_length_reg;\n    output_ip_identification_next = output_ip_identification_reg;\n    output_ip_flags_next = output_ip_flags_reg;\n    output_ip_fragment_offset_next = output_ip_fragment_offset_reg;\n    output_ip_ttl_next = output_ip_ttl_reg;\n    output_ip_protocol_next = output_ip_protocol_reg;\n    output_ip_header_checksum_next = output_ip_header_checksum_reg;\n    output_ip_source_ip_next = output_ip_source_ip_reg;\n    output_ip_dest_ip_next = output_ip_dest_ip_reg;\n\n    if (frame_reg) begin\n        if (current_input_tvalid & current_input_tready) begin\n            // end of frame detection\n            frame_next = ~current_input_tlast;\n        end\n    end else if (enable & ~output_ip_hdr_valid & selected_input_ip_hdr_valid) begin\n        // start of frame, grab select value\n        frame_next = 1;\n        select_next = select;\n\n        case (select_next)\n            1'd0: input_0_ip_hdr_ready_next = 1;\n            1'd1: input_1_ip_hdr_ready_next = 1;\n        endcase\n\n        output_ip_hdr_valid_next = 1;\n        output_eth_dest_mac_next = selected_input_eth_dest_mac;\n        output_eth_src_mac_next = selected_input_eth_src_mac;\n        output_eth_type_next = selected_input_eth_type;\n        output_ip_version_next = selected_input_ip_version;\n        output_ip_ihl_next = selected_input_ip_ihl;\n        output_ip_dscp_next = selected_input_ip_dscp;\n        output_ip_ecn_next = selected_input_ip_ecn;\n        output_ip_length_next = selected_input_ip_length;\n        output_ip_identification_next = selected_input_ip_identification;\n        output_ip_flags_next = selected_input_ip_flags;\n        output_ip_fragment_offset_next = selected_input_ip_fragment_offset;\n        output_ip_ttl_next = selected_input_ip_ttl;\n        output_ip_protocol_next = selected_input_ip_protocol;\n        output_ip_header_checksum_next = selected_input_ip_header_checksum;\n        output_ip_source_ip_next = selected_input_ip_source_ip;\n        output_ip_dest_ip_next = selected_input_ip_dest_ip;\n    end\n\n    // generate ready signal on selected port\n    case (select_next)\n        1'd0: input_0_ip_payload_tready_next = output_ip_payload_tready_int_early & frame_next;\n        1'd1: input_1_ip_payload_tready_next = output_ip_payload_tready_int_early & frame_next;\n    endcase\n\n    // pass through selected packet data\n    output_ip_payload_tdata_int = current_input_tdata;\n    output_ip_payload_tvalid_int = current_input_tvalid & current_input_tready & frame_reg;\n    output_ip_payload_tlast_int = current_input_tlast;\n    output_ip_payload_tuser_int = current_input_tuser;\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        select_reg <= 0;\n        frame_reg <= 0;\n"], ["verilog-ethernet/rtl/udp_mux_64_4.v@429:529", "            current_input_tuser = input_3_udp_payload_tuser;\n        end\n    endcase\nend\n\nalways @* begin\n    select_next = select_reg;\n    frame_next = frame_reg;\n\n    input_0_udp_hdr_ready_next = input_0_udp_hdr_ready_reg & ~input_0_udp_hdr_valid;\n    input_1_udp_hdr_ready_next = input_1_udp_hdr_ready_reg & ~input_1_udp_hdr_valid;\n    input_2_udp_hdr_ready_next = input_2_udp_hdr_ready_reg & ~input_2_udp_hdr_valid;\n    input_3_udp_hdr_ready_next = input_3_udp_hdr_ready_reg & ~input_3_udp_hdr_valid;\n\n    input_0_udp_payload_tready_next = 0;\n    input_1_udp_payload_tready_next = 0;\n    input_2_udp_payload_tready_next = 0;\n    input_3_udp_payload_tready_next = 0;\n\n    output_udp_hdr_valid_next = output_udp_hdr_valid_reg & ~output_udp_hdr_ready;\n    output_eth_dest_mac_next = output_eth_dest_mac_reg;\n    output_eth_src_mac_next = output_eth_src_mac_reg;\n    output_eth_type_next = output_eth_type_reg;\n    output_ip_version_next = output_ip_version_reg;\n    output_ip_ihl_next = output_ip_ihl_reg;\n    output_ip_dscp_next = output_ip_dscp_reg;\n    output_ip_ecn_next = output_ip_ecn_reg;\n    output_ip_length_next = output_ip_length_reg;\n    output_ip_identification_next = output_ip_identification_reg;\n    output_ip_flags_next = output_ip_flags_reg;\n    output_ip_fragment_offset_next = output_ip_fragment_offset_reg;\n    output_ip_ttl_next = output_ip_ttl_reg;\n    output_ip_protocol_next = output_ip_protocol_reg;\n    output_ip_header_checksum_next = output_ip_header_checksum_reg;\n    output_ip_source_ip_next = output_ip_source_ip_reg;\n    output_ip_dest_ip_next = output_ip_dest_ip_reg;\n    output_udp_source_port_next = output_udp_source_port_reg;\n    output_udp_dest_port_next = output_udp_dest_port_reg;\n    output_udp_length_next = output_udp_length_reg;\n    output_udp_checksum_next = output_udp_checksum_reg;\n\n    if (frame_reg) begin\n        if (current_input_tvalid & current_input_tready) begin\n            // end of frame detection\n            frame_next = ~current_input_tlast;\n        end\n    end else if (enable & ~output_udp_hdr_valid & selected_input_udp_hdr_valid) begin\n        // start of frame, grab select value\n        frame_next = 1;\n        select_next = select;\n\n        case (select_next)\n            2'd0: input_0_udp_hdr_ready_next = 1;\n            2'd1: input_1_udp_hdr_ready_next = 1;\n            2'd2: input_2_udp_hdr_ready_next = 1;\n            2'd3: input_3_udp_hdr_ready_next = 1;\n        endcase\n\n        output_udp_hdr_valid_next = 1;\n        output_eth_dest_mac_next = selected_input_eth_dest_mac;\n        output_eth_src_mac_next = selected_input_eth_src_mac;\n        output_eth_type_next = selected_input_eth_type;\n        output_ip_version_next = selected_input_ip_version;\n        output_ip_ihl_next = selected_input_ip_ihl;\n        output_ip_dscp_next = selected_input_ip_dscp;\n        output_ip_ecn_next = selected_input_ip_ecn;\n        output_ip_length_next = selected_input_ip_length;\n        output_ip_identification_next = selected_input_ip_identification;\n        output_ip_flags_next = selected_input_ip_flags;\n        output_ip_fragment_offset_next = selected_input_ip_fragment_offset;\n        output_ip_ttl_next = selected_input_ip_ttl;\n        output_ip_protocol_next = selected_input_ip_protocol;\n        output_ip_header_checksum_next = selected_input_ip_header_checksum;\n        output_ip_source_ip_next = selected_input_ip_source_ip;\n        output_ip_dest_ip_next = selected_input_ip_dest_ip;\n        output_udp_source_port_next = selected_input_udp_source_port;\n        output_udp_dest_port_next = selected_input_udp_dest_port;\n        output_udp_length_next = selected_input_udp_length;\n        output_udp_checksum_next = selected_input_udp_checksum;\n    end\n\n    // generate ready signal on selected port\n    case (select_next)\n        2'd0: input_0_udp_payload_tready_next = output_udp_payload_tready_int_early & frame_next;\n        2'd1: input_1_udp_payload_tready_next = output_udp_payload_tready_int_early & frame_next;\n        2'd2: input_2_udp_payload_tready_next = output_udp_payload_tready_int_early & frame_next;\n        2'd3: input_3_udp_payload_tready_next = output_udp_payload_tready_int_early & frame_next;\n    endcase\n\n    // pass through selected packet data\n    output_udp_payload_tdata_int = current_input_tdata;\n    output_udp_payload_tkeep_int = current_input_tkeep;\n    output_udp_payload_tvalid_int = current_input_tvalid & current_input_tready & frame_reg;\n    output_udp_payload_tlast_int = current_input_tlast;\n    output_udp_payload_tuser_int = current_input_tuser;\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        select_reg <= 0;\n        frame_reg <= 0;\n"], ["verilog-ethernet/rtl/ip_demux_64_4.v@315:395", "            current_output_tready = output_3_ip_payload_tready;\n        end\n    endcase\nend\n\nalways @* begin\n    select_next = select_reg;\n    frame_next = frame_reg;\n\n    input_ip_hdr_ready_next = input_ip_hdr_ready_reg & ~input_ip_hdr_valid;\n    input_ip_payload_tready_next = 0;\n    output_0_ip_hdr_valid_next = output_0_ip_hdr_valid_reg & ~output_0_ip_hdr_ready;\n    output_1_ip_hdr_valid_next = output_1_ip_hdr_valid_reg & ~output_1_ip_hdr_ready;\n    output_2_ip_hdr_valid_next = output_2_ip_hdr_valid_reg & ~output_2_ip_hdr_ready;\n    output_3_ip_hdr_valid_next = output_3_ip_hdr_valid_reg & ~output_3_ip_hdr_ready;\n    output_eth_dest_mac_next = output_eth_dest_mac_reg;\n    output_eth_src_mac_next = output_eth_src_mac_reg;\n    output_eth_type_next = output_eth_type_reg;\n    output_ip_version_next = output_ip_version_reg;\n    output_ip_ihl_next = output_ip_ihl_reg;\n    output_ip_dscp_next = output_ip_dscp_reg;\n    output_ip_ecn_next = output_ip_ecn_reg;\n    output_ip_length_next = output_ip_length_reg;\n    output_ip_identification_next = output_ip_identification_reg;\n    output_ip_flags_next = output_ip_flags_reg;\n    output_ip_fragment_offset_next = output_ip_fragment_offset_reg;\n    output_ip_ttl_next = output_ip_ttl_reg;\n    output_ip_protocol_next = output_ip_protocol_reg;\n    output_ip_header_checksum_next = output_ip_header_checksum_reg;\n    output_ip_source_ip_next = output_ip_source_ip_reg;\n    output_ip_dest_ip_next = output_ip_dest_ip_reg;\n\n    if (frame_reg) begin\n        if (input_ip_payload_tvalid & input_ip_payload_tready) begin\n            // end of frame detection\n            frame_next = ~input_ip_payload_tlast;\n        end\n    end else if (enable & input_ip_hdr_valid & ~current_output_ip_hdr_valid & ~current_output_tvalid) begin\n        // start of frame, grab select value\n        frame_next = 1;\n        select_next = select;\n\n        input_ip_hdr_ready_next = 1;\n\n        case (select)\n            2'd0: output_0_ip_hdr_valid_next = 1;\n            2'd1: output_1_ip_hdr_valid_next = 1;\n            2'd2: output_2_ip_hdr_valid_next = 1;\n            2'd3: output_3_ip_hdr_valid_next = 1;\n        endcase\n        output_eth_dest_mac_next = input_eth_dest_mac;\n        output_eth_src_mac_next = input_eth_src_mac;\n        output_eth_type_next = input_eth_type;\n        output_ip_version_next = input_ip_version;\n        output_ip_ihl_next = input_ip_ihl;\n        output_ip_dscp_next = input_ip_dscp;\n        output_ip_ecn_next = input_ip_ecn;\n        output_ip_length_next = input_ip_length;\n        output_ip_identification_next = input_ip_identification;\n        output_ip_flags_next = input_ip_flags;\n        output_ip_fragment_offset_next = input_ip_fragment_offset;\n        output_ip_ttl_next = input_ip_ttl;\n        output_ip_protocol_next = input_ip_protocol;\n        output_ip_header_checksum_next = input_ip_header_checksum;\n        output_ip_source_ip_next = input_ip_source_ip;\n        output_ip_dest_ip_next = input_ip_dest_ip;\n    end\n\n    input_ip_payload_tready_next = output_ip_payload_tready_int_early & frame_next;\n\n    output_ip_payload_tdata_int = input_ip_payload_tdata;\n    output_ip_payload_tkeep_int = input_ip_payload_tkeep;\n    output_ip_payload_tvalid_int = input_ip_payload_tvalid & input_ip_payload_tready;\n    output_ip_payload_tlast_int = input_ip_payload_tlast;\n    output_ip_payload_tuser_int = input_ip_payload_tuser;\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        select_reg <= 0;\n        frame_reg <= 0;\n"], ["verilog-ethernet/rtl/ip_mux_4.v@370:461", "            current_input_tuser = input_3_ip_payload_tuser;\n        end\n    endcase\nend\n\nalways @* begin\n    select_next = select_reg;\n    frame_next = frame_reg;\n\n    input_0_ip_hdr_ready_next = input_0_ip_hdr_ready_reg & ~input_0_ip_hdr_valid;\n    input_1_ip_hdr_ready_next = input_1_ip_hdr_ready_reg & ~input_1_ip_hdr_valid;\n    input_2_ip_hdr_ready_next = input_2_ip_hdr_ready_reg & ~input_2_ip_hdr_valid;\n    input_3_ip_hdr_ready_next = input_3_ip_hdr_ready_reg & ~input_3_ip_hdr_valid;\n\n    input_0_ip_payload_tready_next = 0;\n    input_1_ip_payload_tready_next = 0;\n    input_2_ip_payload_tready_next = 0;\n    input_3_ip_payload_tready_next = 0;\n\n    output_ip_hdr_valid_next = output_ip_hdr_valid_reg & ~output_ip_hdr_ready;\n    output_eth_dest_mac_next = output_eth_dest_mac_reg;\n    output_eth_src_mac_next = output_eth_src_mac_reg;\n    output_eth_type_next = output_eth_type_reg;\n    output_ip_version_next = output_ip_version_reg;\n    output_ip_ihl_next = output_ip_ihl_reg;\n    output_ip_dscp_next = output_ip_dscp_reg;\n    output_ip_ecn_next = output_ip_ecn_reg;\n    output_ip_length_next = output_ip_length_reg;\n    output_ip_identification_next = output_ip_identification_reg;\n    output_ip_flags_next = output_ip_flags_reg;\n    output_ip_fragment_offset_next = output_ip_fragment_offset_reg;\n    output_ip_ttl_next = output_ip_ttl_reg;\n    output_ip_protocol_next = output_ip_protocol_reg;\n    output_ip_header_checksum_next = output_ip_header_checksum_reg;\n    output_ip_source_ip_next = output_ip_source_ip_reg;\n    output_ip_dest_ip_next = output_ip_dest_ip_reg;\n\n    if (frame_reg) begin\n        if (current_input_tvalid & current_input_tready) begin\n            // end of frame detection\n            frame_next = ~current_input_tlast;\n        end\n    end else if (enable & ~output_ip_hdr_valid & selected_input_ip_hdr_valid) begin\n        // start of frame, grab select value\n        frame_next = 1;\n        select_next = select;\n\n        case (select_next)\n            2'd0: input_0_ip_hdr_ready_next = 1;\n            2'd1: input_1_ip_hdr_ready_next = 1;\n            2'd2: input_2_ip_hdr_ready_next = 1;\n            2'd3: input_3_ip_hdr_ready_next = 1;\n        endcase\n\n        output_ip_hdr_valid_next = 1;\n        output_eth_dest_mac_next = selected_input_eth_dest_mac;\n        output_eth_src_mac_next = selected_input_eth_src_mac;\n        output_eth_type_next = selected_input_eth_type;\n        output_ip_version_next = selected_input_ip_version;\n        output_ip_ihl_next = selected_input_ip_ihl;\n        output_ip_dscp_next = selected_input_ip_dscp;\n        output_ip_ecn_next = selected_input_ip_ecn;\n        output_ip_length_next = selected_input_ip_length;\n        output_ip_identification_next = selected_input_ip_identification;\n        output_ip_flags_next = selected_input_ip_flags;\n        output_ip_fragment_offset_next = selected_input_ip_fragment_offset;\n        output_ip_ttl_next = selected_input_ip_ttl;\n        output_ip_protocol_next = selected_input_ip_protocol;\n        output_ip_header_checksum_next = selected_input_ip_header_checksum;\n        output_ip_source_ip_next = selected_input_ip_source_ip;\n        output_ip_dest_ip_next = selected_input_ip_dest_ip;\n    end\n\n    // generate ready signal on selected port\n    case (select_next)\n        2'd0: input_0_ip_payload_tready_next = output_ip_payload_tready_int_early & frame_next;\n        2'd1: input_1_ip_payload_tready_next = output_ip_payload_tready_int_early & frame_next;\n        2'd2: input_2_ip_payload_tready_next = output_ip_payload_tready_int_early & frame_next;\n        2'd3: input_3_ip_payload_tready_next = output_ip_payload_tready_int_early & frame_next;\n    endcase\n\n    // pass through selected packet data\n    output_ip_payload_tdata_int = current_input_tdata;\n    output_ip_payload_tvalid_int = current_input_tvalid & current_input_tready & frame_reg;\n    output_ip_payload_tlast_int = current_input_tlast;\n    output_ip_payload_tuser_int = current_input_tuser;\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        select_reg <= 0;\n        frame_reg <= 0;\n"]], "Diff Content": {"Delete": [[281, "    input_0_ip_payload_tready_next = 0;\n"], [282, "    input_1_ip_payload_tready_next = 0;\n"], [309, "        frame_next = 1;\n"], [313, "            1'd0: input_0_ip_hdr_ready_next = 1;\n"], [314, "            1'd1: input_1_ip_hdr_ready_next = 1;\n"], [317, "        output_ip_hdr_valid_next = 1;\n"]], "Add": [[282, "    input_0_ip_payload_tready_next = 1'b0;\n"], [282, "    input_1_ip_payload_tready_next = 1'b0;\n"], [309, "        frame_next = 1'b1;\n"], [314, "            1'd0: input_0_ip_hdr_ready_next = 1'b1;\n"], [314, "            1'd1: input_1_ip_hdr_ready_next = 1'b1;\n"], [317, "        output_ip_hdr_valid_next = 1'b1;\n"]]}}