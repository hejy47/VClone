{"Source Block": ["verilog-ethernet/rtl/axis_eth_fcs_insert.v@100:231@HdlStmProcess", "    .data_in(output_axis_tdata_int),\n    .crc_state(crc_state),\n    .crc_next(crc_next)\n);\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    reset_crc = 0;\n    update_crc = 0;\n\n    frame_ptr_next = frame_ptr_reg;\n\n    input_axis_tready_next = 0;\n\n    output_axis_tdata_int = 0;\n    output_axis_tvalid_int = 0;\n    output_axis_tlast_int = 0;\n    output_axis_tuser_int = 0;\n\n    case (state_reg)\n        STATE_IDLE: begin\n            // idle state - wait for data\n            input_axis_tready_next = output_axis_tready_int_early;\n            frame_ptr_next = 0;\n            reset_crc = 1;\n\n            output_axis_tdata_int = input_axis_tdata;\n            output_axis_tvalid_int = input_axis_tvalid;\n            output_axis_tlast_int = 0;\n            output_axis_tuser_int = 0;\n\n            if (input_axis_tready & input_axis_tvalid) begin\n                frame_ptr_next = 1;\n                reset_crc = 0;\n                update_crc = 1;\n                state_next = STATE_PAYLOAD;\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_PAYLOAD: begin\n            // transfer payload\n            input_axis_tready_next = output_axis_tready_int_early;\n\n            output_axis_tdata_int = input_axis_tdata;\n            output_axis_tvalid_int = input_axis_tvalid;\n            output_axis_tlast_int = 0;\n            output_axis_tuser_int = 0;\n\n            if (input_axis_tready & input_axis_tvalid) begin\n                frame_ptr_next = frame_ptr_reg + 1;\n                update_crc = 1;\n                if (input_axis_tlast) begin\n                    if (input_axis_tuser) begin\n                        output_axis_tlast_int = 1;\n                        output_axis_tuser_int = 1;\n                        reset_crc = 1;\n                        state_next = STATE_IDLE;\n                    end else begin\n                        input_axis_tready_next = 0;\n                        if (ENABLE_PADDING && frame_ptr_next < MIN_FRAME_LENGTH-5) begin\n                            state_next = STATE_PAD;\n                        end else begin\n                            frame_ptr_next = 0;\n                            state_next = STATE_FCS;\n                        end\n                    end\n                end else begin\n                    state_next = STATE_PAYLOAD;\n                end\n            end else begin\n                state_next = STATE_PAYLOAD;\n            end\n        end\n        STATE_PAD: begin\n            // insert padding\n            input_axis_tready_next = 0;\n\n            output_axis_tdata_int = 0;\n            output_axis_tvalid_int = 1;\n            output_axis_tlast_int = 0;\n            output_axis_tuser_int = 0;\n\n            if (output_axis_tready_int) begin\n                frame_ptr_next = frame_ptr_reg + 1;\n                update_crc = 1;\n                if (frame_ptr_next < MIN_FRAME_LENGTH-5) begin\n                    state_next = STATE_PAD;\n                end else begin\n                    frame_ptr_next = 0;\n                    state_next = STATE_FCS;\n                end\n            end\n        end\n        STATE_FCS: begin\n            // send FCS\n            input_axis_tready_next = 0;\n\n            case (frame_ptr_reg)\n                2'd0: output_axis_tdata_int = ~crc_state[7:0];\n                2'd1: output_axis_tdata_int = ~crc_state[15:8];\n                2'd2: output_axis_tdata_int = ~crc_state[23:16];\n                2'd3: output_axis_tdata_int = ~crc_state[31:24];\n            endcase\n            output_axis_tvalid_int = 1;\n            output_axis_tlast_int = 0;\n            output_axis_tuser_int = 0;\n\n            if (output_axis_tready_int) begin\n                frame_ptr_next = frame_ptr_reg + 1;\n\n                if (frame_ptr_reg < 3) begin\n                    state_next = STATE_FCS;\n                end else begin\n                    reset_crc = 1;\n                    frame_ptr_next = 0;\n                    output_axis_tlast_int = 1;\n                    input_axis_tready_next = output_axis_tready_int_early;\n                    state_next = STATE_IDLE;\n                end\n            end else begin\n                state_next = STATE_FCS;\n            end\n        end\n    endcase\nend\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state_reg <= STATE_IDLE;\n        \n"], "Clone Blocks": [], "Diff Content": {"Delete": [[161, "                        if (ENABLE_PADDING && frame_ptr_next < MIN_FRAME_LENGTH-5) begin\n"], [187, "                if (frame_ptr_next < MIN_FRAME_LENGTH-5) begin\n"]], "Add": [[161, "                        if (ENABLE_PADDING && frame_ptr_reg < MIN_FRAME_LENGTH-5) begin\n"], [187, "                if (frame_ptr_reg < MIN_FRAME_LENGTH-5) begin\n"], [192, "            end else begin\n"], [192, "                state_next = STATE_PAD;\n"]]}}