{"Source Block": ["verilog-ethernet/rtl/axis_switch.v@166:271@HdlStmFor", "\ngenerate\n\n    genvar m, n;\n\n    for (m = 0; m < S_COUNT; m = m + 1) begin : s_ifaces\n\n        // decoding\n        reg [CL_S_COUNT-1:0] select_reg = 0, select_next;\n        reg drop_reg = 1'b0, drop_next;\n        reg select_valid_reg = 1'b0, select_valid_next;\n\n        integer k;\n\n        always @* begin\n            select_next = select_reg;\n            drop_next = drop_reg && !(int_s_axis_tvalid[m] && int_s_axis_tready[m] && int_s_axis_tlast[m]);\n            select_valid_next = select_valid_reg && !(int_s_axis_tvalid[m] && int_s_axis_tready[m] && int_s_axis_tlast[m]);\n\n            if (int_s_axis_tvalid[m] && !select_valid_reg) begin\n                select_next = 1'b0;\n                select_valid_next = 1'b0;\n                drop_next = 1'b1;\n                for (k = 0; k < M_COUNT; k = k + 1) begin\n                    if (M_BASE == 0) begin\n                        // M_BASE is zero, route with tdest as port index\n                        if (int_s_axis_tdest[m*DEST_WIDTH +: DEST_WIDTH] == k && (M_CONNECT & (1 << (m+k*S_COUNT)))) begin\n                            select_next = k;\n                            select_valid_next = 1'b1;\n                            drop_next = 1'b0;\n                        end\n                    end else if (M_TOP == 0) begin\n                        // M_TOP is zero, assume equal to M_BASE\n                        if (int_s_axis_tdest[m*DEST_WIDTH +: DEST_WIDTH] == M_BASE[k*DEST_WIDTH +: DEST_WIDTH] && (M_CONNECT & (1 << (m+k*S_COUNT)))) begin\n                            select_next = k;\n                            select_valid_next = 1'b1;\n                            drop_next = 1'b0;\n                        end\n                    end else begin\n                        if (int_s_axis_tdest[m*DEST_WIDTH +: DEST_WIDTH] >= M_BASE[k*DEST_WIDTH +: DEST_WIDTH] && int_s_axis_tdest[m*DEST_WIDTH +: DEST_WIDTH] <= M_TOP[k*DEST_WIDTH +: DEST_WIDTH] && (M_CONNECT & (1 << (m+k*S_COUNT)))) begin\n                            select_next = k;\n                            select_valid_next = 1'b1;\n                            drop_next = 1'b0;\n                        end\n                    end\n                end\n            end\n        end\n\n        always @(posedge clk) begin\n            if (rst) begin\n                select_valid_reg <= 1'b0;\n            end else begin\n                select_valid_reg <= select_valid_next;\n            end\n\n            select_reg <= select_next;\n            drop_reg <= drop_next;\n        end\n\n        // forwarding\n        assign int_axis_tvalid[m*M_COUNT +: M_COUNT] = (int_s_axis_tvalid[m] && select_valid_reg && !drop_reg) << select_reg;\n        assign int_s_axis_tready[m] = int_axis_tready[select_reg*M_COUNT+m] || drop_reg;\n\n        // S side register\n        axis_register #(\n            .DATA_WIDTH(DATA_WIDTH),\n            .KEEP_ENABLE(KEEP_ENABLE),\n            .KEEP_WIDTH(KEEP_WIDTH),\n            .LAST_ENABLE(1),\n            .ID_ENABLE(ID_ENABLE),\n            .ID_WIDTH(ID_WIDTH),\n            .DEST_ENABLE(1),\n            .DEST_WIDTH(DEST_WIDTH),\n            .USER_ENABLE(USER_ENABLE),\n            .USER_WIDTH(USER_WIDTH),\n            .REG_TYPE(S_REG_TYPE)\n        )\n        reg_inst (\n            .clk(clk),\n            .rst(rst),\n            // AXI input\n            .s_axis_tdata(s_axis_tdata[m*DATA_WIDTH +: DATA_WIDTH]),\n            .s_axis_tkeep(s_axis_tkeep[m*KEEP_WIDTH +: KEEP_WIDTH]),\n            .s_axis_tvalid(s_axis_tvalid[m]),\n            .s_axis_tready(s_axis_tready[m]),\n            .s_axis_tlast(s_axis_tlast[m]),\n            .s_axis_tid(s_axis_tid[m*ID_WIDTH +: ID_WIDTH]),\n            .s_axis_tdest(s_axis_tdest[m*DEST_WIDTH +: DEST_WIDTH]),\n            .s_axis_tuser(s_axis_tuser[m*USER_WIDTH +: USER_WIDTH]),\n            // AXI output\n            .m_axis_tdata(int_s_axis_tdata[m*DATA_WIDTH +: DATA_WIDTH]),\n            .m_axis_tkeep(int_s_axis_tkeep[m*KEEP_WIDTH +: KEEP_WIDTH]),\n            .m_axis_tvalid(int_s_axis_tvalid[m]),\n            .m_axis_tready(int_s_axis_tready[m]),\n            .m_axis_tlast(int_s_axis_tlast[m]),\n            .m_axis_tid(int_s_axis_tid[m*ID_WIDTH +: ID_WIDTH]),\n            .m_axis_tdest(int_s_axis_tdest[m*DEST_WIDTH +: DEST_WIDTH]),\n            .m_axis_tuser(int_s_axis_tuser[m*USER_WIDTH +: USER_WIDTH])\n        );\n    end // s_ifaces\n\n    for (n = 0; n < M_COUNT; n = n + 1) begin : m_ifaces\n\n        // arbitration\n        wire [S_COUNT-1:0] request;\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[174, "        reg [CL_S_COUNT-1:0] select_reg = 0, select_next;\n"]], "Add": [[174, "        reg [CL_M_COUNT-1:0] select_reg = 0, select_next;\n"]]}}