{"Source Block": ["verilog-ethernet/rtl/axis_stat_counter.v@112:244@HdlStmProcess", "\nassign busy = busy_reg;\n\ninteger offset, i, bit_cnt;\n\nalways @* begin\n    state_next = 2'bz;\n\n    tick_count_next = tick_count_reg;\n    byte_count_next = byte_count_reg;\n    frame_count_next = frame_count_reg;\n    frame_next = frame_reg;\n\n    output_axis_tdata_int = 0;\n    output_axis_tvalid_int = 0;\n    output_axis_tlast_int = 0;\n    output_axis_tuser_int = 0;\n\n    store_output = 0;\n\n    frame_ptr_next = frame_ptr_reg;\n\n    // data readout\n\n    case (state_reg)\n        STATE_IDLE: begin\n            if (trigger) begin\n                store_output = 1;\n                tick_count_next = 0;\n                byte_count_next = 0;\n                frame_count_next = 0;\n                frame_ptr_next = 0;\n\n                if (output_axis_tready_int) begin\n                    frame_ptr_next = 1;\n                    if (TAG_ENABLE) begin\n                        output_axis_tdata_int = tag[(TAG_BYTE_WIDTH-1)*8 +: 8];\n                    end else if (TICK_COUNT_ENABLE) begin\n                        output_axis_tdata_int = tag[(TICK_COUNT_BYTE_WIDTH-1)*8 +: 8];\n                    end else if (BYTE_COUNT_ENABLE) begin\n                        output_axis_tdata_int = tag[(BYTE_COUNT_BYTE_WIDTH-1)*8 +: 8];\n                    end else if (FRAME_COUNT_ENABLE) begin\n                        output_axis_tdata_int = tag[(FRAME_COUNT_BYTE_WIDTH-1)*8 +: 8];\n                    end\n                    output_axis_tvalid_int = 1;\n                end\n\n                state_next = STATE_OUTPUT_DATA;\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_OUTPUT_DATA: begin\n            if (output_axis_tready_int) begin\n                state_next = STATE_OUTPUT_DATA;\n                frame_ptr_next = frame_ptr_reg + 1;\n                output_axis_tvalid_int = 1;\n\n                offset = 0;\n                if (TAG_ENABLE) begin\n                    for (i = TAG_BYTE_WIDTH-1; i >= 0; i = i - 1) begin\n                        if (frame_ptr_reg == offset) begin\n                            output_axis_tdata_int = tag[i*8 +: 8];\n                        end\n                        offset = offset + 1;\n                    end\n                end\n                if (TICK_COUNT_ENABLE) begin\n                    for (i = TICK_COUNT_BYTE_WIDTH-1; i >= 0; i = i - 1) begin\n                        if (frame_ptr_reg == offset) begin\n                            output_axis_tdata_int = tick_count_output_reg[i*8 +: 8];\n                        end\n                        offset = offset + 1;\n                    end\n                end\n                if (BYTE_COUNT_ENABLE) begin\n                    for (i = BYTE_COUNT_BYTE_WIDTH-1; i >= 0; i = i - 1) begin\n                        if (frame_ptr_reg == offset) begin\n                            output_axis_tdata_int = byte_count_output_reg[i*8 +: 8];\n                        end\n                        offset = offset + 1;\n                    end\n                end\n                if (FRAME_COUNT_ENABLE) begin\n                    for (i = FRAME_COUNT_BYTE_WIDTH-1; i >= 0; i = i - 1) begin\n                        if (frame_ptr_reg == offset) begin\n                            output_axis_tdata_int = frame_count_output_reg[i*8 +: 8];\n                        end\n                        offset = offset + 1;\n                    end\n                end\n                if (frame_ptr_reg == offset-1) begin\n                    output_axis_tlast_int = 1;\n                    state_next = STATE_IDLE;\n                end\n            end else begin\n                state_next = STATE_OUTPUT_DATA;\n            end\n        end\n    endcase\n\n    // stats collection\n\n    // increment tick count by number of words that can be transferred per cycle\n    tick_count_next = tick_count_next + KEEP_WIDTH;\n\n    if (monitor_axis_tready & monitor_axis_tvalid) begin\n        // valid transfer cycle\n\n        // increment byte count by number of words transferred\n        bit_cnt = 0;\n        for (i = 0; i <= KEEP_WIDTH; i = i + 1) begin\n            //bit_cnt = bit_cnt + monitor_axis_tkeep[i];\n            if (monitor_axis_tkeep == ({KEEP_WIDTH{1'b1}}) >> (KEEP_WIDTH-i)) bit_cnt = i;\n        end\n        byte_count_next = byte_count_next + bit_cnt;\n\n        // count frames\n        if (monitor_axis_tlast) begin\n            // end of frame\n            frame_next = 0;\n        end else if (~frame_reg) begin\n            // first word after end of frame\n            frame_count_next = frame_count_next + 1;\n            frame_next = 1;\n        end\n    end\nend\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state_reg <= STATE_IDLE;\n        tick_count_reg <= 0;\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[150, "                        output_axis_tdata_int = tag[(TICK_COUNT_BYTE_WIDTH-1)*8 +: 8];\n"], [152, "                        output_axis_tdata_int = tag[(BYTE_COUNT_BYTE_WIDTH-1)*8 +: 8];\n"], [154, "                        output_axis_tdata_int = tag[(FRAME_COUNT_BYTE_WIDTH-1)*8 +: 8];\n"]], "Add": [[150, "                        output_axis_tdata_int = tick_count_reg[(TICK_COUNT_BYTE_WIDTH-1)*8 +: 8];\n"], [152, "                        output_axis_tdata_int = byte_count_reg[(BYTE_COUNT_BYTE_WIDTH-1)*8 +: 8];\n"], [154, "                        output_axis_tdata_int = frame_count_reg[(FRAME_COUNT_BYTE_WIDTH-1)*8 +: 8];\n"]]}}