{"Source Block": ["verilog-ethernet/rtl/axis_gmii_tx.v@131:358@HdlStmProcess", "    .state_in(crc_state),\n    .data_out(),\n    .state_out(crc_next)\n);\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    reset_crc = 1'b0;\n    update_crc = 1'b0;\n\n    mii_odd_next = mii_odd_reg;\n    mii_msn_next = mii_msn_reg;\n\n    frame_ptr_next = frame_ptr_reg;\n\n    s_axis_tready_next = 1'b0;\n\n    s_tdata_next = s_tdata_reg;\n\n    gmii_txd_next = 8'd0;\n    gmii_tx_en_next = 1'b0;\n    gmii_tx_er_next = 1'b0;\n\n    start_packet_next = 1'b0;\n\n    if (!clk_enable) begin\n        // clock disabled - hold state and outputs\n        gmii_txd_next = gmii_txd_reg;\n        gmii_tx_en_next = gmii_tx_en_reg;\n        gmii_tx_er_next = gmii_tx_er_reg;\n        state_next = state_reg;\n    end else if (mii_select && mii_odd_reg) begin\n        // MII odd cycle - hold state, output MSN\n        mii_odd_next = 1'b0;\n        gmii_txd_next = {4'd0, mii_msn_reg};\n        gmii_tx_en_next = gmii_tx_en_reg;\n        gmii_tx_er_next = gmii_tx_er_reg;\n        state_next = state_reg;\n    end else begin\n        case (state_reg)\n            STATE_IDLE: begin\n                // idle state - wait for packet\n                reset_crc = 1'b1;\n                mii_odd_next = 1'b0;\n\n                if (s_axis_tvalid) begin\n                    mii_odd_next = 1'b1;\n                    frame_ptr_next = 16'd1;\n                    gmii_txd_next = ETH_PRE;\n                    gmii_tx_en_next = 1'b1;\n                    state_next = STATE_PREAMBLE;\n                end else begin\n                    state_next = STATE_IDLE;\n                end\n            end\n            STATE_PREAMBLE: begin\n                // send preamble\n                reset_crc = 1'b1;\n\n                mii_odd_next = 1'b1;\n                frame_ptr_next = frame_ptr_reg + 16'd1;\n\n                gmii_txd_next = ETH_PRE;\n                gmii_tx_en_next = 1'b1;\n\n                if (frame_ptr_reg == 16'd6) begin\n                    s_axis_tready_next = 1'b1;\n                    s_tdata_next = s_axis_tdata;\n                    state_next = STATE_PREAMBLE;\n                end else if (frame_ptr_reg == 16'd7) begin\n                    // end of preamble; start payload\n                    frame_ptr_next = 16'd0;\n                    if (s_axis_tready_reg) begin\n                        s_axis_tready_next = 1'b1;\n                        s_tdata_next = s_axis_tdata;\n                    end\n                    gmii_txd_next = ETH_SFD;\n                    start_packet_next = 1'b1;\n                    state_next = STATE_PAYLOAD;\n                end else begin\n                    state_next = STATE_PREAMBLE;\n                end\n            end\n            STATE_PAYLOAD: begin\n                // send payload\n\n                update_crc = 1'b1;\n                s_axis_tready_next = 1'b1;\n\n                mii_odd_next = 1'b1;\n                frame_ptr_next = frame_ptr_reg + 16'd1;\n\n                gmii_txd_next = s_tdata_reg;\n                gmii_tx_en_next = 1'b1;\n\n                s_tdata_next = s_axis_tdata;\n\n                if (s_axis_tvalid) begin\n                    if (s_axis_tlast) begin\n                        s_axis_tready_next = !s_axis_tready_reg;\n                        if (s_axis_tuser) begin\n                            gmii_tx_er_next = 1'b1;\n                            frame_ptr_next = 1'b0;\n                            state_next = STATE_IFG;\n                        end else begin\n                            state_next = STATE_LAST;\n                        end\n                    end else begin\n                        state_next = STATE_PAYLOAD;\n                    end\n                end else begin\n                    // tvalid deassert, fail frame\n                    gmii_tx_er_next = 1'b1;\n                    frame_ptr_next = 16'd0;\n                    state_next = STATE_WAIT_END;\n                end\n            end\n            STATE_LAST: begin\n                // last payload word\n\n                update_crc = 1'b1;\n\n                mii_odd_next = 1'b1;\n                frame_ptr_next = frame_ptr_reg + 16'd1;\n\n                gmii_txd_next = s_tdata_reg;\n                gmii_tx_en_next = 1'b1;\n\n                if (ENABLE_PADDING && frame_ptr_reg < MIN_FRAME_LENGTH-5) begin\n                    s_tdata_next = 8'd0;\n                    state_next = STATE_PAD;\n                end else begin\n                    frame_ptr_next = 16'd0;\n                    state_next = STATE_FCS;\n                end\n            end\n            STATE_PAD: begin\n                // send padding\n\n                update_crc = 1'b1;\n                mii_odd_next = 1'b1;\n                frame_ptr_next = frame_ptr_reg + 16'd1;\n\n                gmii_txd_next = 8'd0;\n                gmii_tx_en_next = 1'b1;\n\n                s_tdata_next = 8'd0;\n\n                if (frame_ptr_reg < MIN_FRAME_LENGTH-5) begin\n                    state_next = STATE_PAD;\n                end else begin\n                    frame_ptr_next = 16'd0;\n                    state_next = STATE_FCS;\n                end\n            end\n            STATE_FCS: begin\n                // send FCS\n\n                mii_odd_next = 1'b1;\n                frame_ptr_next = frame_ptr_reg + 16'd1;\n\n                case (frame_ptr_reg)\n                    2'd0: gmii_txd_next = ~crc_state[7:0];\n                    2'd1: gmii_txd_next = ~crc_state[15:8];\n                    2'd2: gmii_txd_next = ~crc_state[23:16];\n                    2'd3: gmii_txd_next = ~crc_state[31:24];\n                endcase\n                gmii_tx_en_next = 1'b1;\n\n                if (frame_ptr_reg < 3) begin\n                    state_next = STATE_FCS;\n                end else begin\n                    frame_ptr_next = 16'd0;\n                    state_next = STATE_IFG;\n                end\n            end\n            STATE_WAIT_END: begin\n                // wait for end of frame\n\n                reset_crc = 1'b1;\n\n                mii_odd_next = 1'b1;\n                frame_ptr_next = frame_ptr_reg + 16'd1;\n                s_axis_tready_next = 1'b1;\n\n                if (s_axis_tvalid) begin\n                    if (s_axis_tlast) begin\n                        s_axis_tready_next = 1'b0;\n                        if (frame_ptr_reg < ifg_delay-1) begin\n                            state_next = STATE_IFG;\n                        end else begin\n                            state_next = STATE_IDLE;\n                        end\n                    end else begin\n                        state_next = STATE_WAIT_END;\n                    end\n                end else begin\n                    state_next = STATE_WAIT_END;\n                end\n            end\n            STATE_IFG: begin\n                // send IFG\n\n                reset_crc = 1'b1;\n\n                mii_odd_next = 1'b1;\n                frame_ptr_next = frame_ptr_reg + 16'd1;\n\n                if (frame_ptr_reg < ifg_delay-1) begin\n                    state_next = STATE_IFG;\n                end else begin\n                    state_next = STATE_IDLE;\n                end\n            end\n        endcase\n\n        if (mii_select) begin\n            mii_msn_next = gmii_txd_next[7:4];\n            gmii_txd_next[7:4] = 4'd0;\n        end\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state_reg <= STATE_IDLE;\n\n"], "Clone Blocks": [], "Diff Content": {"Delete": [], "Add": [[155, "    error_underflow_next = 1'b0;\n"], [245, "                    error_underflow_next = 1'b1;\n"]]}}