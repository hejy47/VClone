{"Source Block": ["miaow/src/verilog/rtl/lsu/lsu_op_manager.v@270:470@HdlStmProcess", "        vgpr_source1_addr_reg <= vgpr_source1_addr_reg_next;\n        gm_or_lds_reg <= gm_or_lds_reg_next;\n    end\nend\n\nalways@(*) begin\n    // LSU state/operation signals\n    lsu_state_next <= lsu_state;\n    lsu_rd_wr_next <= lsu_rd_wr;\n    \n    mem_op_cnt_reg_next <= mem_op_cnt_reg;\n    mem_op_cnter_next <= mem_op_cnter;\n    \n    // Memory interface signals\n    mem_in_addr_reg_next <= mem_in_addr_reg;\n    mem_rd_en_reg <= 1'b0;\n    mem_wr_en_reg <= 1'b0;\n    \n    tracemon_mem_addr_reg_next <= tracemon_mem_addr_reg;\n    \n    begin : MEM_BUFFER_MAP\n        integer i;\n        for(i = 0; i < 64; i = i + 1) begin\n            mem_data_buffer_next[i] <= mem_data_buffer[32 * i+:32];\n            mem_data_buffer_next_flat[32 * i+:32] <= mem_data_buffer_next[i];\n        end\n    end\n    \n    // Register bank control signals\n    sgpr_wr_mask_reg_next <= sgpr_wr_mask_reg;\n    exec_mask_reg_next <= exec_mask_reg;\n    exec_mask_base_reg_next <= exec_mask_base_reg;\n    \n    sgpr_op_next <= sgpr_op;\n    vgpr_op_next <= vgpr_op;\n    gpr_wr <= 1'b0;\n    current_wfid_next <= current_wfid;\n    current_pc_next <= current_pc;\n    gpr_op_depth_next <= gpr_op_depth_reg;\n    gpr_op_depth_cntr_next <= gpr_op_depth_cntr;\n    \n    vgpr_source1_addr_reg_next <= vgpr_source1_addr_reg;\n    \n    muxed_sgpr_source1_rd_en <= 1'b0;\n    muxed_sgpr_source2_rd_en <= 1'b0;\n    muxed_sgpr_source1_addr <= 9'bXXXXXXXXX;\n    muxed_sgpr_source2_addr <= 9'bXXXXXXXXX;\n    //muxed_sgpr_dest_addr <= 9'bXXXXXXXXX;\n\n    muxed_vgpr_source1_rd_en <= 1'b0;\n    muxed_vgpr_source2_rd_en <= 1'b0;\n    muxed_vgpr_source1_addr <= 10'bXXXXXXXXXX;\n    muxed_vgpr_source2_addr <= 10'bXXXXXXXXXX;\n    \n    gpr_dest_addr_next <= gpr_dest_addr;\n    \n    gm_or_lds_reg_next <= gm_or_lds_reg;\n    \n    case(lsu_state)\n        IDLE_STATE: begin\n            lsu_rd_wr_next <= 1'b0;\n            if(mem_op_rd | mem_op_wr) begin\n                current_wfid_next <= lsu_wfid;\n                current_pc_next <= instr_pc;\n                lsu_state_next <= ADDR_CALC_STATE;\n                mem_op_cnt_reg_next <= mem_op_cnt;\n                mem_op_cnter_next <= 6'd0;\n                \n                // Route SGPR read signals from opcode decoder\n                muxed_sgpr_source1_rd_en <= decoded_sgpr_source1_rd_en;\n                muxed_sgpr_source2_rd_en <= decoded_sgpr_source2_rd_en;\n                muxed_sgpr_source1_addr <= decoded_sgpr_source1_addr;\n                muxed_sgpr_source2_addr <= decoded_sgpr_source2_addr;\n                \n                // Route VGPR read signals from opcode decoder\n                muxed_vgpr_source2_rd_en <= decoded_vgpr_source2_rd_en;\n                muxed_vgpr_source2_addr <= decoded_vgpr_source2_addr;\n                \n                gpr_op_depth_next <= gpr_op_depth;\n            end\n            \n            // There are no SGPR to memory instructions so don't need to check\n            // where the data is coming from, it's always the VGPR for writes.\n            if(mem_op_wr) begin\n                lsu_rd_wr_next <= 1'b1;\n                vgpr_source1_addr_reg_next <= decoded_vgpr_source1_addr;\n            end\n            \n            // These signals technically could be only updated when we get a\n            // memory operation, but there's no real point to conditionalize\n            // them.\n            exec_mask_reg_next <= exec_mask;\n            exec_mask_base_reg_next <= exec_mask;\n            sgpr_wr_mask_reg_next <= sgpr_wr_mask;\n            \n            if(mem_op_rd) begin\n                sgpr_op_next <= ~mem_gpr;\n                vgpr_op_next <= mem_gpr;\n                gpr_dest_addr_next <= decoded_dest_addr;\n            end\n        end\n        // Get calculated address values\n        ADDR_CALC_STATE: begin\n            lsu_state_next <= RD_STATE;\n            mem_in_addr_reg_next <= mem_in_addr;\n            tracemon_mem_addr_reg_next <= mem_in_addr;\n            gpr_op_depth_cntr_next <= 2'd0;\n            mem_op_cnter_next <= 6'd0;\n            if(lsu_rd_wr) begin\n                lsu_state_next <= WR_REG_INIT_RD_STATE;\n            end\n            gm_or_lds_reg_next <= gm_or_lds;\n        end\n        \n        RD_STATE: begin\n            mem_rd_en_reg <= 1'b1;\n            if(vgpr_op & ~exec_mask_reg[0]) begin\n                // Stop trying to load\n                lsu_state_next <= RD_REG_WR_STATE;\n                mem_rd_en_reg <= 1'b0;\n            end\n            else if(mem_ack) begin\n                // Need to verify how SGPR addresses are generated, whether\n                // I'm supposed to just increment by 4's or if the offsets\n                // are part of the generated address bank.\n                mem_rd_en_reg <= 1'b0;\n                mem_op_cnter_next <= mem_op_cnter + 6'd1;\n                mem_in_addr_reg_next[2015:0] <= mem_in_addr_reg[2047:32];\n                mem_data_buffer_next[mem_op_cnter] <= mem_rd_data;\n                exec_mask_reg_next[62:0] <= exec_mask_reg[63:1];\n                if(mem_op_cnter == mem_op_cnt_reg) begin\n                    lsu_state_next <= RD_REG_WR_STATE;\n                end\n            end\n        end\n        \n        RD_REG_WR_STATE: begin\n            gpr_wr <= 1'b1;\n            gpr_op_depth_cntr_next <= gpr_op_depth_cntr + 2'd1;\n            lsu_state_next <= RD_STATE;\n            mem_op_cnter_next <= 6'd0;\n            exec_mask_reg_next <= exec_mask_base_reg;\n            gpr_dest_addr_next <= gpr_dest_addr + 12'd1;\n            if(gpr_op_depth_cntr == gpr_op_depth_reg) begin\n                // Signal done somehow\n                lsu_state_next <= SIGNAL_DONE_STATE;\n            end\n        end\n        \n        WR_REG_INIT_RD_STATE: begin\n            // There is literally no mechanism to actually write SGPR data\n            // out to memory, so ignoring that case for now.\n            muxed_vgpr_source1_rd_en <= 1'b1;\n            muxed_vgpr_source1_addr <= vgpr_source1_addr_reg;\n            lsu_state_next <= WR_REG_RD_STATE;\n        end\n        \n        WR_REG_RD_STATE: begin\n            mem_data_buffer_next_flat <= vgpr_source1_data;\n            lsu_state_next <= WR_STATE;\n        end\n        \n        WR_STATE: begin\n            mem_wr_en_reg <= 1'b1;\n            if(vgpr_op & ~exec_mask_reg[0]) begin\n                // Stop trying to load\n                lsu_state_next <= WR_REG_INC_STATE;\n                mem_wr_en_reg <= 1'b0;\n            end\n            else if(mem_ack) begin\n                mem_wr_en_reg <= 1'b0;\n                mem_op_cnter_next <= mem_op_cnter + 6'd1;\n                mem_in_addr_reg_next[2015:0] <= mem_in_addr_reg[2047:32];\n                mem_data_buffer_next_flat[2015:0] <= mem_data_buffer[2047:32];\n                exec_mask_reg_next[62:0] <= exec_mask_reg[63:1];\n                if(mem_op_cnter == mem_op_cnt_reg) begin\n                    lsu_state_next <= WR_REG_INC_STATE;\n                end\n            end\n        end\n        \n        WR_REG_INC_STATE: begin\n            lsu_state_next <= WR_REG_INIT_RD_STATE;\n            gpr_op_depth_cntr_next <= gpr_op_depth_cntr + 2'd1;\n            vgpr_source1_addr_reg_next <= vgpr_source1_addr_reg + 10'd1;\n            if(gpr_op_depth_cntr == gpr_op_depth_reg) begin\n                // Signal done somehow\n                lsu_state_next <= SIGNAL_DONE_STATE;\n            end\n        end\n        \n        SIGNAL_DONE_STATE: begin\n            lsu_state_next <= IDLE_STATE;\n        end\n    endcase\nend\n\nassign lsu_rdy = (lsu_state == IDLE_STATE) ? 1'b1 : 1'b0;\nassign lsu_done = (lsu_state == SIGNAL_DONE_STATE) ? 1'b1 : 1'b0;\nassign lsu_done_wfid = current_wfid;\n\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[397, "                mem_in_addr_reg_next[2015:0] <= mem_in_addr_reg[2047:32];\n"]], "Add": [[397, "                if(sgpr_op) begin\n"], [397, "                    mem_in_addr_reg_next[31:0] = mem_in_addr_reg[31:0] + 32'd4;\n"], [397, "                end\n"], [397, "                else begin\n"], [397, "                    mem_in_addr_reg_next[2015:0] <= mem_in_addr_reg[2047:32];\n"], [397, "                end\n"]]}}