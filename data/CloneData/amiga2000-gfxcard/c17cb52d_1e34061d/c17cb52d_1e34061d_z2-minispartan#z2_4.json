{"Source Block": ["amiga2000-gfxcard/z2-minispartan/z2.v@449:947@HdlStmProcess", "  end\nend\n\n// =================================================================================\n// ZORRO MACHINE\nalways @(posedge z_sample_clk) begin\n  LEDS <= zorro_state|(ram_arbiter_state<<5);\n  \n  case (zorro_state)\n    RESET: begin\n      dataout_enable <= 0;\n      dataout <= 0;\n      slaven <= 0;\n      z_ready <= 1'bZ; // clear XRDY (cpu wait)\n      zorro_ram_write_done <= 1;\n      zorro_ram_read_done <= 1;\n      blitter_rgb <= 'h0005;\n      blitter_enable <= 1;\n      \n      ram_low   <= 'h600000;\n      ram_high  <= 'h600000 + ram_size;\n      reg_low   <= 'h600000 + reg_base;\n      reg_high  <= 'h600000 + reg_base + 'h100;\n      \n      zorro_state <= CONFIGURING;\n    end\n    \n    CONFIGURING: begin\n      /*if (zaddr_autoconfig && !znCFGIN) begin\n        if (zorro_read) begin\n          // read iospace 'he80000 (Autoconfig ROM)\n          dataout_enable <= 1;\n          dataout <= 1;\n          slaven <= 1;\n          \n          case (zaddr & 'h0000ff)\n            'h000000: data <= 'b1100_0000_0000_0000; // zorro 2\n            'h000002: data <= 'b0111_0000_0000_0000; // 2mb\n            \n            'h000004: data <= 'b1111_0000_0000_0000; // product number\n            'h000006: data <= 'b1110_0000_0000_0000; // (23)\n            \n            'h000008: data <= 'b0011_0000_0000_0000; // flags inverted\n            'h00000a: data <= 'b1111_0000_0000_0000; // inverted zero\n            \n            'h000010: data <= 'b1111_0000_0000_0000; // manufacturer high byte inverted (02)\n            'h000012: data <= 'b1101_0000_0000_0000; // \n            'h000014: data <= 'b0110_0000_0000_0000; // manufacturer low byte (9a)\n            'h000016: data <= 'b0101_0000_0000_0000;\n            \n            'h000018: data <= 'b1111_0000_0000_0000; // serial\n            'h00001a: data <= 'b1110_0000_0000_0000; //\n            'h00001c: data <= 'b1111_0000_0000_0000; //\n            'h00001e: data <= 'b1110_0000_0000_0000; //\n            'h000020: data <= 'b1111_0000_0000_0000; //\n            'h000022: data <= 'b1110_0000_0000_0000; //\n            'h000024: data <= 'b1111_0000_0000_0000; //\n            'h000026: data <= 'b1110_0000_0000_0000; //\n            \n            'h000040: data <= 'b0000_0000_0000_0000; // interrupts (not inverted)\n            'h000042: data <= 'b0000_0000_0000_0000; //\n           \n            default: data <= 'b1111_0000_0000_0000;\n          endcase        \n        end else begin\n          // write to autoconfig register\n          if (datastrobe_synced) begin\n            case (zaddr & 'h0000ff)\n              'h000048: begin\n                ram_low[23:20] <= data_in[15:12];\n              end\n              'h00004a: begin\n                ram_low[19:16] <= data_in[15:12];\n                ram_high  <= ram_low + ram_size;\n                reg_low   <= ram_low + reg_base;\n                reg_high  <= ram_low + reg_base + 'h100;\n                zorro_state <= CONFIGURED; // configured\n              end\n              'h00004c: begin \n                zorro_state <= CONFIGURED; // configured, shut up\n              end\n            endcase\n          end\n        end\n      end else begin\n        // no address match\n        dataout <= 0;\n        dataout_enable <= 0;\n        slaven <= 0;\n      end*/\n    end\n      \n    CONFIGURED: begin\n      blitter_rgb <= 'hffff;\n      blitter_enable <= 0;\n      zorro_state <= IDLE;\n    \n      uart_write <= 1;\n      uart_data <= 33;\n      uart_nybble <= 9;\n    end\n  \n    // ----------------------------------------------------------------------------------  \n    IDLE: begin\n      dataout <= 0;\n      dataout_enable <= 0;\n      slaven <= 0;\n      write_stall <= 0;\n      z_ready <= 1'bZ; // clear XRDY (cpu wait)\n      \n      if (uart_nybble==9 && uart_busy) begin\n        uart_write <= 0;\n        uart_nybble <= 0;\n      end\n      \n      if (znRST_sync[1]==0) begin\n        // system reset\n        zorro_state <= IDLE;\n      end else if (znAS_sync[1]==0 && znAS_sync[0]==0) begin\n        if (zorro_read && zaddr_in_ram) begin\n          // read RAM\n          // request ram access from arbiter\n          zorro_ram_read_addr <= ((zaddr_sync-ram_low)>>1);\n          zorro_ram_read_request <= 1;\n          zorro_ram_read_done <= 0;\n          data <= 'hffff;\n          read_counter <= 0;\n          \n          slaven <= 1;\n          dataout_enable <= 1;\n          dataout <= 1;\n          \n          z_ready <= 0;\n          zorro_state <= WAIT_READ2;\n          \n        end else if (zorro_write && zaddr_in_ram) begin\n          // write RAM\n          \n          last_addr <= ((zaddr_sync-ram_low)>>1);\n          zorro_state <= WAIT_WRITE;\n          \n        end else if (zorro_write && zaddr_in_reg && datastrobe_synced) begin\n          // write to register\n          case (zaddr & 'h0000ff)\n            /*'h00: display_enable <= data_in[0];\n            'h02: read_to_fetch_time <= data_in[7:0];\n            'h04: fetch_delay_value <= data_in[7:0];\n            'h06: margin_x <= data_in[7:0];\n            'h08: fetch_preroll <= data_in[7:0];\n            'h0a: dataout_time <= data_in[7:0];\n            'h0c: slaven_time <= data_in[7:0];\n            'h0e: zready_time <= data_in[7:0];\n            'h10: glitch_reg <= data_in[7:0];\n            'h12: glitchx_reg <= data_in[11:0];\n            'h14: glitch_offset <= data_in[7:0];\n            'h16: negx_margin <= data_in[7:0];*/\n            \n            // blitter regs\n            'h20: blitter_x1 <= data_in[10:0];\n            'h22: blitter_y1 <= data_in[10:0];\n            'h24: blitter_x2 <= data_in[10:0];\n            'h26: blitter_y2 <= data_in[10:0];\n            'h28: blitter_rgb <= data_in[15:0];\n            'h2a: begin\n              blitter_enable <= data_in[3:0];\n              blitter_curx <= blitter_x1;\n              blitter_cury <= blitter_y1;\n              blitter_curx2 <= blitter_x3;\n              blitter_cury2 <= blitter_y3;\n            end\n            'h2c: blitter_x3 <= data_in[10:0];\n            'h2e: blitter_y3 <= data_in[10:0];\n            'h30: blitter_x4 <= data_in[10:0];\n            'h32: blitter_y4 <= data_in[10:0];\n            \n            // sd card regs\n            'h60: sd_reset <= data_in[8];\n            'h62: sd_read <= data_in[8];\n            'h64: sd_write <= data_in[8];\n            'h66: sd_handshake_in <= data_in[8];\n            'h68: sd_addr_in[31:16] <= data_in;\n            'h6a: sd_addr_in[15:0] <= data_in;\n            'h6c: sd_data_in <= data_in[15:8];\n          endcase\n        end else if (zorro_read && zaddr_in_reg) begin\n          // read from registers\n          \n          dataout_enable <= 1;\n          dataout <= 1;\n          slaven <= 1;\n          \n          case (zaddr & 'h0000ff)\n            'h2a: data <= blitter_enable|16'h0000;\n            /*'h00: data <= ram_low[23:16];\n            'h02: data <= ram_low[15:0];\n            'h04: data <= ram_high[23:16];\n            'h06: data <= ram_high[15:0];*/\n            \n            'h60: data <= sd_busy<<8;\n            'h62: data <= sd_read<<8;\n            'h64: data <= sd_write<<8;\n            'h66: data <= sd_handshake_out<<8;\n            'h68: data <= sd_addr_in[31:16];\n            'h6a: data <= sd_addr_in[15:0];\n            'h6c: data <= sd_data_in<<8;\n            'h6e: data <= sd_data_out<<8;\n            'h70: data <= sd_error;\n            \n            default: data <= 'h0000;\n          endcase\n         \n        end        \n      end\n    end\n  \n    // ----------------------------------------------------------------------------------\n    WAIT_READ2: begin\n      if (znAS_sync[1]==1 && znAS_sync[0]==1) begin\n        // ram too slow TODO: report this\n        zorro_ram_read_request <= 0;\n        zorro_state <= IDLE;\n      end else if (zorro_ram_read_done) begin\n        read_counter <= read_counter + 1;\n        zorro_ram_read_request <= 0;\n        \n        if (read_counter >= dataout_time) begin\n          zorro_state <= WAIT_READ;\n        end\n        data <= zorro_ram_read_data;\n      end\n    end\n  \n    // ----------------------------------------------------------------------------------\n    WAIT_READ:\n      if (znAS_sync[1]==1 && znAS_sync[0]==1) begin\n        zorro_state <= IDLE;\n        z_ready <= 1'bZ;\n      end else begin\n        data <= zorro_ram_read_data;\n        z_ready <= 1'bZ;\n      end\n   \n    // ----------------------------------------------------------------------------------\n    WAIT_WRITE:\n      if (!zorro_ram_write_request) begin\n      \n        /*if (uart_nybble<4) begin\n          z_ready <= 0;\n          if (uart_busy && uart_write) begin\n            uart_write <= 0;\n          end else if (!uart_busy && uart_write==0) begin\n            if (uart_nybble==0) begin\n              if (last_addr[7:4]<10)\n                uart_data <= last_addr[7:4]+48;\n              else\n                uart_data <= last_addr[7:4]+87;\n              uart_nybble <= 1;\n              uart_write <= 1;\n            end else if (uart_nybble==1) begin\n              if (last_addr[3:0]<10)\n                uart_data <= last_addr[3:0]+48;\n              else\n                uart_data <= last_addr[3:0]+87;\n              uart_nybble <= 2;\n              uart_write <= 1;\n            end else if (uart_nybble==2) begin\n              uart_data <= 13;\n              uart_nybble <= 3;\n              uart_write <= 1;\n            end else if (uart_nybble==3) begin\n              uart_data <= 10;\n              uart_nybble <= 4;\n              uart_write <= 1;\n            end\n          end\n        // nybble>=4\n        end else if (uart_busy && uart_nybble==4) begin\n          // wait\n        end else if (!uart_busy) begin*/\n          /*uart_data <= 0;\n          uart_nybble <= 0;\n          uart_write <= 0;*/\n          \n          // there is still room in the queue\n          z_ready <= 1'bZ;\n          write_stall <= 0;\n          if (datastrobe_synced && zdata_in_sync==data_in) begin\n            zorro_ram_write_addr <= last_addr;\n            zorro_ram_write_bytes <= {~znUDS_sync[2],~znLDS_sync[2]};\n            zorro_ram_write_data <= zdata_in_sync;\n            zorro_ram_write_request <= 1;\n            \n            zorro_state <= WAIT_WRITE2;\n          end\n        /*end else begin\n          z_ready <= 0;\n          write_stall <= 1;\n        end*/\n      end else begin\n        z_ready <= 0;\n        write_stall <= 1;\n      end\n    \n    // ----------------------------------------------------------------------------------\n    WAIT_WRITE2: begin\n      z_ready <= 1'bZ;\n      if (znAS_sync[1]==1 && znAS_sync[0]==1) begin\n        zorro_state <= IDLE;\n      end\n    end\n    \n  endcase\n\n// =================================================================================\n// RAM ARBITER\n\n  case (ram_arbiter_state)\n    RAM_READY: begin\n      // start fetching a row\n      ram_enable <= 1;\n      if (row_fetched) begin\n        if (cmd_ready) begin\n          ram_burst <= 0;\n          ram_arbiter_state <= RAM_BURST_OFF;\n          fetch_x <= 0;\n        end\n      end else begin\n        if (cmd_ready) begin\n          ram_burst <= 1;\n          ram_addr  <= ((fetch_y << 11) | 504);\n          ram_byte_enable <= 'b11;\n          ram_write <= 0;\n          ram_arbiter_state <= RAM_BURST_ON;\n          fetch_x <= 0;\n          fetch_x2 <= 504;\n        end\n      end\n    end\n    \n    RAM_BURST_ON: begin\n      if (cmd_ready) begin\n        ram_arbiter_state <= RAM_FETCHING_ROW;\n      end\n    end\n    \n    RAM_BURST_OFF: begin\n      ram_enable <= 0;\n      if (data_out_queue_empty)\n        ram_arbiter_state <= RAM_ROW_FETCHED;\n    end\n    \n    RAM_FETCHING_ROW:    \n      if (data_out_ready) begin\n        if (fetch_x >= screen_w) begin\n          row_fetched <= 1; // row completely fetched\n          ram_arbiter_state <= RAM_READY;\n        end else begin\n          ram_enable <= 1;\n          ram_write <= 0;\n          ram_byte_enable <= 'b11;\n          ram_addr  <= ((fetch_y << 11) | fetch_x2); // burst incremented\n          \n          //(sdram_state=='b10010)?'hffff:'h0000; // ram_data_out[15:0];\n          //fetch_x <= fetch_x + 1;\n           \n          //if (sdram_state=='b10010) begin // || sdram_state=='b00111 || sdram_state=='b01101) begin\n          //if (data_out_ready) begin\n            fetch_x <= fetch_x + 1;\n            fetch_x2 <= fetch_x2 + 1;\n            fetch_buffer[fetch_x] <= ram_data_out[15:0];\n          //end\n          \n          /*if (cmd_ready) begin\n            fetch_x <= fetch_x + 1;\n            ram_addr  <= ((fetch_y << 11) | fetch_x[10:0]);\n            ram_enable <= 1; // fetch next\n            ram_byte_enable <= 'b11;\n            ram_write <= 0;\n          end*/\n          \n        end\n      end\n    RAM_ROW_FETCHED:\n      if (counter_x>=h_max-64 && counter_y<screen_h) begin\n        row_fetched <= 0;\n        fetch_x <= 0;\n        fetch_y <= counter_y;\n        ram_arbiter_state <= RAM_READY;\n      end else if (writeq_fill>0) begin\n        // process write queue\n        if (cmd_ready) begin\n          if (writeq_addr[writeq_fill-1][uds_bit] && !writeq_addr[writeq_fill-1][lds_bit])\n            ram_byte_enable <= 'b10; // UDS\n          else if (writeq_addr[writeq_fill-1][lds_bit] && !writeq_addr[writeq_fill-1][uds_bit])\n            ram_byte_enable <= 'b01; // LDS\n          else\n            ram_byte_enable <= 'b11;\n          \n          ram_data_in <= (writeq_data[writeq_fill-1]);\n          ram_addr    <= (writeq_addr[writeq_fill-1][q_msb:0]);\n          ram_write   <= 1;\n          ram_enable  <= 1;\n          \n          writeq_fill <= writeq_fill-1;\n          // TODO additional wait state?\n        end\n      end else if (zorro_ram_write_request) begin\n        if (writeq_fill<max_fill) begin\n          // process write request\n          zorro_ram_write_done <= 1;\n          zorro_ram_write_request <= 0;\n          writeq_addr[writeq_fill][q_msb:0] <= zorro_ram_write_addr;\n          writeq_addr[writeq_fill][uds_bit] <= zorro_ram_write_bytes[1];\n          writeq_addr[writeq_fill][lds_bit] <= zorro_ram_write_bytes[0];\n          writeq_data[writeq_fill] <= zorro_ram_write_data;\n          \n          writeq_fill <= writeq_fill + 1;\n        end else begin\n          zorro_ram_write_done <= 0;\n        end\n      end else if (zorro_ram_read_request) begin\n        // process read request\n        zorro_ram_read_done <= 0;\n        if (cmd_ready && data_out_queue_empty) begin\n          ram_write <= 0;\n          ram_addr <= zorro_ram_read_addr;\n          ram_byte_enable <= 'b11;\n          ram_enable <= 1;\n          ram_arbiter_state <= RAM_READING_ZORRO;\n        end else \n          ram_enable <= 0;\n      end else if ((blitter_enable>0) && cmd_ready) begin // ==1 || blitter_enable==3\n        // rect fill blitter\n        if (blitter_curx<=blitter_x2) begin\n          blitter_curx <= blitter_curx + 1;\n          ram_byte_enable <= 'b11;\n          ram_addr    <= (blitter_cury<<11)|blitter_curx;\n          if (blitter_enable == 3) begin            \n            blitter_curx2 <= blitter_curx2 + 1;\n            blitter_enable <= 2;\n            ram_data_in <= blitter_copy_rgb;\n            ram_write   <= 1;\n            ram_enable  <= 1;\n          end else begin\n            ram_data_in <= blitter_rgb;\n            ram_write   <= 1;\n            ram_enable  <= 1;\n          end\n        end else if (blitter_cury<blitter_y2) begin\n          blitter_cury <= blitter_cury + 1;\n          blitter_curx <= blitter_x1;\n        end else begin\n          blitter_curx <= 0;\n          blitter_cury <= 0;\n          blitter_enable <= 0;\n          ram_enable <= 0;\n        end\n      end\n      /*end else if (blitter_enable==4 && data_out_ready) begin\n        // block copy (data ready)\n        ram_enable <= 0;\n        blitter_copy_rgb <= ram_data_out;\n        blitter_enable <= 3;\n      end else if (blitter_enable==2 && cmd_ready && data_out_queue_empty) begin //  && (counter_x<(h_max-fetch_preroll-'h10))\n        // block copy (read)\n        if (blitter_curx2<=blitter_x4) begin\n          ram_byte_enable <= 'b11;\n          ram_addr    <= (blitter_cury2<<11)|blitter_curx2;\n          ram_write   <= 0;\n          ram_enable  <= 1;\n          blitter_enable <= 4; // wait for read\n        end else if (blitter_cury2<blitter_y4) begin\n          blitter_cury2 <= blitter_cury2 + 1;\n          blitter_curx2 <= blitter_x3;\n        end else begin\n          blitter_curx2 <= 0;\n          blitter_cury2 <= 0;\n          blitter_enable <= 0;\n          ram_enable <= 0;\n        end\n      end*/\n      \n    RAM_READING_ZORRO: begin    \n        if (data_out_ready) begin\n          //ram_enable <= 0;\n          zorro_ram_read_data <= ram_data_out; // zorro_ram_read_addr; <- debug\n          zorro_ram_read_done <= 1;\n          zorro_ram_read_request <= 0;\n          ram_arbiter_state <= RAM_ROW_FETCHED;\n        end\n      end\n    \n  endcase\nend\n\nreg[15:0] rgb = 'h0000;\n\nalways @(posedge vga_clk) begin\n  if (counter_x >= h_max) begin\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[596, "            'h06: margin_x <= data_in[7:0];\n"], [602, "            'h12: glitchx_reg <= data_in[11:0];\n"], [778, "          ram_addr  <= ((fetch_y << 11) | 504);\n"], [783, "          fetch_x2 <= 504;\n"], [855, "      end else if (zorro_ram_write_request) begin\n"], [856, "        if (writeq_fill<max_fill) begin\n"], [858, "          zorro_ram_write_done <= 1;\n"], [859, "          zorro_ram_write_request <= 0;\n"], [860, "          writeq_addr[writeq_fill][q_msb:0] <= zorro_ram_write_addr;\n"], [861, "          writeq_addr[writeq_fill][uds_bit] <= zorro_ram_write_bytes[1];\n"], [862, "          writeq_addr[writeq_fill][lds_bit] <= zorro_ram_write_bytes[0];\n"], [863, "          writeq_data[writeq_fill] <= zorro_ram_write_data;\n"], [865, "          writeq_fill <= writeq_fill + 1;\n"], [866, "        end else begin\n"], [867, "          zorro_ram_write_done <= 0;\n"], [868, "        end\n"], [869, "      end else if (zorro_ram_read_request) begin\n"], [871, "        zorro_ram_read_done <= 0;\n"], [872, "        if (cmd_ready && data_out_queue_empty) begin\n"], [873, "          ram_write <= 0;\n"], [874, "          ram_addr <= zorro_ram_read_addr;\n"], [875, "          ram_byte_enable <= 'b11;\n"], [876, "          ram_enable <= 1;\n"], [877, "          ram_arbiter_state <= RAM_READING_ZORRO;\n"], [878, "        end else \n"], [879, "          ram_enable <= 0;\n"], [886, "          if (blitter_enable == 3) begin            \n"], [892, "          end else begin\n"], [896, "          end\n"], [904, "          ram_enable <= 0;\n"]], "Add": [[604, "            'h06: margin_x <= data_in[7:0];\n"], [604, "            'h12: glitchx_reg <= data_in[15:0];\n"], [604, "            'h14: ram_burst_col <= data_in[8:0];\n"], [669, "        z_ready <= 1'bZ;\n"], [778, "          ram_addr  <= ((fetch_y << 11) | glitchx_reg);\n"], [783, "          fetch_x2 <= glitchx_reg;\n"], [836, "      end else if (zorro_ram_read_request) begin\n"], [836, "        zorro_ram_read_done <= 0;\n"], [836, "        if (cmd_ready && data_out_queue_empty) begin\n"], [836, "          ram_write <= 0;\n"], [836, "          ram_addr <= zorro_ram_read_addr;\n"], [836, "          ram_byte_enable <= 'b11;\n"], [836, "          ram_enable <= 1;\n"], [836, "          ram_arbiter_state <= RAM_READING_ZORRO;\n"], [836, "        end else \n"], [836, "          ram_enable <= 0;\n"], [836, "      end else if (zorro_ram_write_request && writeq_fill<max_fill) begin\n"], [836, "        zorro_ram_write_done <= 1;\n"], [836, "        zorro_ram_write_request <= 0;\n"], [836, "        writeq_addr[writeq_fill][q_msb:0] <= zorro_ram_write_addr;\n"], [836, "        writeq_addr[writeq_fill][uds_bit] <= zorro_ram_write_bytes[1];\n"], [836, "        writeq_addr[writeq_fill][lds_bit] <= zorro_ram_write_bytes[0];\n"], [836, "        writeq_data[writeq_fill] <= zorro_ram_write_data;\n"], [836, "        writeq_fill <= writeq_fill + 1;\n"], [886, "          /*if (blitter_enable == 3) begin            \n"], [892, "          end else begin*/\n"]]}}