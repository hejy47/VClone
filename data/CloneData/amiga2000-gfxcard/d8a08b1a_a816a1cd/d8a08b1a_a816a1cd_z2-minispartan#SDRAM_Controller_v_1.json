{"Source Block": ["amiga2000-gfxcard/z2-minispartan/SDRAM_Controller_v.v@228:535@HdlStmProcess", "reg can_back_to_back = 0;\nreg burst_old = 0;\n\nalways @(posedge clk) captured_data <= sdram_din;\n\nalways @(posedge clk)\n   begin\n      startup_refresh_count <= startup_refresh_count+1'b1;\n      \n      //-- It we are ready for a new transaction and one is being presented\n      //-- then accept it. Also remember what we are reading or writing,\n      //-- and if it can be back-to-backed with the last transaction\n      if (ready_for_new == 1'b1 && cmd_enable == 1'b1) begin\n        if (save_bank == addr_bank && save_row == addr_row) \n          can_back_to_back <= 1'b1;\n        else\n          can_back_to_back <= 1'b0;\n        \n        //$display(\"%h r: %h c: %h\",cmd_address,addr_row,addr_col);\n        save_row         <= addr_row;\n        save_bank        <= addr_bank;\n        save_col         <= addr_col;\n        save_wr          <= cmd_wr; \n        save_data_in     <= cmd_data_in;\n        save_byte_enable <= cmd_byte_enable;\n        got_transaction  <= 1'b1;\n        ready_for_new    <= 1'b0;\n      end\n      \n      // empty read queue if switched off\n      if (cmd_enable == 0) begin\n        data_ready_delay <= 0;\n      end\n\n      if (data_ready_delay[0] == 1'b1) begin\n        data_out_reg       <= captured_data;\n        data_out_ready_reg <= 1'b1;\n      end else begin\n        data_out_ready_reg <= 1'b0;\n      end\n      \n      // no more bits in the queue?\n      if (data_ready_delay == 0)\n        data_out_queue_empty_reg <= 1;\n      else\n        data_out_queue_empty_reg <= 0;\n       \n      //-- update shift registers used to choose when to present data to/from memory\n      data_ready_delay <= {1'b0, data_ready_delay[data_ready_delay_high:1]};\n         \n      case(state) \n         s_startup: begin\n               //------------------------------------------------------------------------\n               //-- This is the initial startup state, where we wait for at least 100us\n               //-- before starting the start sequence\n               //-- \n               //-- The initialisation is sequence is \n               //--  * de-assert SDRAM_CKE\n               //--  * 100us wait, \n               //--  * assert SDRAM_CKE\n               //--  * wait at least one cycle, \n               //--  * PRECHARGE\n               //--  * wait 2 cycles\n               //--  * REFRESH, \n               //--  * tREF wait\n               //--  * REFRESH, \n               //--  * tREF wait \n               //--  * LOAD_MODE_REG \n               //--  * 2 cycles wait\n               //------------------------------------------------------------------------\n               iob_cke <= 1'b1;\n               \n               // All the commands during the startup are NOPS, except these\n               if(startup_refresh_count == startup_refresh_max-31) begin\n                  // ensure all rows are closed\n                  iob_command     <= CMD_PRECHARGE;\n                  iob_address[prefresh_cmd] <= 1'b1;  // all banks\n                  iob_bank        <= 2'b00;\n               end\n               else if (startup_refresh_count == startup_refresh_max-23) begin\n                  // these refreshes need to be at least tREF (66ns) apart\n                  iob_command     <= CMD_REFRESH;\n               end else if (startup_refresh_count == startup_refresh_max-15) \n                  iob_command     <= CMD_REFRESH;\n               else if (startup_refresh_count == startup_refresh_max-7) begin\n                  // Now load the mode register\n                  iob_command     <= CMD_LOAD_MODE_REG;\n                  iob_address     <= MODE_REG;\n               end\n\n               if (startup_refresh_count == 1'b0) begin\n                  state           <= s_idle;\n                  ready_for_new   <= 1'b1;\n                  got_transaction <= 1'b0;\n                  startup_refresh_count <= 2048 - cycles_per_refresh+1;\n               end\n            end\n         s_idle_in_6: state <= s_idle_in_5;\n         s_idle_in_5: state <= s_idle_in_4;\n         s_idle_in_4: state <= s_idle_in_3;\n         s_idle_in_3: state <= s_idle_in_2;\n         s_idle_in_2: state <= s_idle_in_1;\n         s_idle_in_1: state <= s_idle;\n\n         s_idle: begin\n           if (burst == 1 && burst_old == 0) begin\n              // switch burst on\n              iob_command     <= CMD_LOAD_MODE_REG;\n              iob_address     <= MODE_REG_BURST;\n              state <= s_idle_in_6;\n              ready_for_new   <= 1'b1;\n              burst_old <= 1;\n           end else if (burst == 0 && burst_old == 1) begin\n              // switch burst off\n              iob_command     <= CMD_LOAD_MODE_REG;\n              iob_address     <= MODE_REG;\n              state <= s_idle_in_6;\n              ready_for_new   <= 1'b1;\n              burst_old <= 0;\n           end else if (got_transaction == 1'b1) begin\n              state       <= s_open_in_2;\n              iob_command <= CMD_ACTIVE;\n              iob_address <= save_row;\n              iob_bank    <= save_bank;\n              //ready_for_new   <= 1'b1;\n           /*end else if (startup_refresh_count >= cycles_per_refresh) begin\n              // refresh when idle\n              startup_refresh_count <= 0;\n              state <= s_refresh;*/\n           end else begin\n              iob_command     <= CMD_NOP;\n              iob_address     <= 13'b0000000000000;\n              iob_bank        <= 2'b00;\n           end\n         end\n         \n         s_open_in_8: state <= s_open_in_7;\n         s_open_in_7: state <= s_open_in_6;\n         s_open_in_6: state <= s_open_in_5;\n         s_open_in_5: state <= s_open_in_4;\n         s_open_in_4: state <= s_open_in_3;\n         s_open_in_3: state <= s_open_in_2;\n         \n         s_open_in_2: state <= s_open_in_1;\n\n         s_open_in_1: begin \n            // still waiting for row to open\n            if (save_wr == 1'b1) begin\n              // write\n              state       <= s_write_1;\n              iob_dq_hiz  <= 1'b0;\n              iob_data    <= save_data_in[15:0];\n            end else begin\n              // read\n              iob_dq_hiz  <= 1'b1;\n              state       <= s_read_1;\n            end\n            ready_for_new   <= 1'b1; \n            got_transaction <= 1'b0;\n          end\n            \n         s_burst_read: begin\n           if (!burst) begin\n             state <=  s_precharge;\n             ready_for_new   <= 1'b1;\n             data_ready_delay[data_ready_delay_high]   <= 1'b0;\n           end else begin\n             iob_command     <= CMD_NOP;\n             iob_dqm     <= 2'b00;\n             iob_dq_hiz  <= 1'b1;\n             \n             if (save_col==burst_col) begin        // 'b111111010       \n               state       <= s_precharge;\n               data_ready_delay[data_ready_delay_high]   <= 1'b0;\n               ready_for_new   <= 1'b0;\n             end else begin\n               data_ready_delay[data_ready_delay_high]   <= 1'b1;\n               ready_for_new   <= 1'b1;\n             end\n           end\n         end\n         s_read_1: begin\n               iob_command     <= CMD_READ;\n               iob_address     <= save_col; \n               iob_bank        <= save_bank;\n               iob_address[prefresh_cmd] <= 1'b0;\n               iob_dqm     <= 2'b00;\n               \n               data_ready_delay[data_ready_delay_high]   <= 1'b1;\n               \n               if (burst) begin\n                 ready_for_new <= 1;\n                 state <= s_burst_read; \n               end else\n                 state <= s_read_2;\n            end   \n         s_read_2: begin\n               state <= s_read_3;\n               if (got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n                  if (save_wr == 1'b0) begin \n                     // read\n                     state           <= s_read_1;\n                     ready_for_new   <= 1'b1;\n                     got_transaction <= 1'b0;\n                  end\n               end\n            end   \n         s_read_3: begin\n               state <= s_read_4;\n               if (got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n                  if (save_wr == 1'b0) begin\n                     // read \n                     state           <= s_read_1;\n                     ready_for_new   <= 1'b1;\n                     got_transaction <= 1'b0;\n                  end\n               end\n            end\n\n         s_read_4: begin\n               state <= s_precharge;\n               //-- can we do back-to-back read?\n               if (got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n                  if (save_wr == 1'b0) begin \n                     state           <= s_read_1;\n                     ready_for_new   <= 1'b1;\n                     got_transaction <= 1'b0;\n                  end\n                  else\n                     state <= s_open_in_2;\n               end\n            end\n         //------------------------------------------------------------------\n         // -- Processing the write transaction\n         //-------------------------------------------------------------------\n         s_write_1: begin\n               state                     <= s_write_2;\n               iob_command               <= CMD_WRITE;\n               iob_address               <= save_col; \n               iob_address[prefresh_cmd] <= 1'b0;\n               iob_bank                  <= save_bank;\n               iob_dqm                   <= ~ save_byte_enable[1:0];      \n               iob_data                  <= save_data_in[15:0];\n            end\n         s_write_2: begin\n            $display(\"w2 %h\\t%h\\t%h\", save_bank, save_row, iob_address);\n               state           <= s_write_3;\n               // can we do a back-to-back write?\n               if (got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n                  if (save_wr == 1'b1) begin\n                     $display(\"back-to-back write\");\n                     \n                     // back-to-back write?\n                     state           <= s_write_1;\n                     ready_for_new   <= 1'b1;\n                     got_transaction <= 1'b0;\n                  end\n                  // Although it looks right in simulation you can't go write-to-read \n                  // here due to bus contention, as iob_dq_hiz takes a few ns.\n               end\n            end\n         s_write_3: begin\n               // must wait tRDL, hence the extra idle state\n               //-- back to back transaction?\n               if (got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n                  if (save_wr == 1'b1) begin\n                     // back-to-back write?\n                     state           <= s_write_1;\n                     ready_for_new   <= 1'b1;\n                     got_transaction <= 1'b0;\n                  end\n                  else begin\n                     // write-to-read switch?\n                     state           <= s_read_1;\n                     iob_dq_hiz      <= 1'b1;\n                     ready_for_new   <= 1'b1;\n                     got_transaction <= 1'b0;                  \n                  end \n               end else begin\n                  iob_dq_hiz         <= 1'b1;\n                  state              <= s_precharge;\n              end\n            end\n         //-- Closing the row off (this closes all banks)\n         s_precharge: begin\n               state                     <= s_idle_in_4;\n               iob_command               <= CMD_PRECHARGE;\n               iob_address[prefresh_cmd] <= 1'b0;\n            end\n         s_refresh: begin\n               state                     <= s_idle_in_6;\n               iob_command               <= CMD_REFRESH;\n            end\n         //-- We should never get here, but if we do then reset the memory\n         default: begin \n               state                 <= s_startup;\n               ready_for_new         <= 1'b0;\n               startup_refresh_count <= startup_refresh_max-sdram_startup_cycles;\n            end\n         endcase\n\n         if (reset == 1'b1) begin  // Sync reset\n            state                 <= s_startup;\n            ready_for_new         <= 1'b0;\n            startup_refresh_count <= startup_refresh_max-sdram_startup_cycles;\n         end\n      end      \nendmodule\n"], "Clone Blocks": [["amiga2000-gfxcard/attic/PapPro-sdram_verilog_v0.1/SDRAM_Controller_v.v@232:517", "      );\n   end \n     \nalways  @ (posedge clk ) captured_data      <= sdram_din;\n\nalways  @ (posedge clk )\n   begin\n      captured_data_last <= captured_data;\n      \n      //------------------------------------------------\n      //-- Default state is to do nothing\n      //------------------------------------------------\n      iob_command     <= CMD_NOP;\n      iob_address     <= 13'b0000000000000;\n      iob_bank        <= 2'b00;\n\n      //------------------------------------------------\n      //-- countdown for initialisation & refresh\n      //------------------------------------------------\n      startup_refresh_count <= startup_refresh_count+1;\n                  \n      //-------------------------------------------------------------------\n      //-- It we are ready for a new tranasction and one is being presented\n      //-- then accept it. Also remember what we are reading or writing,\n      //-- and if it can be back-to-backed with the last transaction\n      //-------------------------------------------------------------------\n      if (ready_for_new == 1'b1 && cmd_enable == 1'b1) begin\n         if(save_bank == addr_bank && save_row == addr_row) \n            can_back_to_back <= 1'b1;\n         else\n            can_back_to_back <= 1'b0;\n\n         save_row         <= addr_row;\n         save_bank        <= addr_bank;\n         save_col         <= addr_col;\n         save_wr          <= cmd_wr; \n         save_data_in     <= cmd_data_in;\n         save_byte_enable <= cmd_byte_enable;\n         got_transaction  <= 1'b1;\n         ready_for_new    <= 1'b0;\n      end\n\n      //------------------------------------------------\n      //-- Handle the data coming back from the \n      //-- SDRAM for the Read transaction\n      //------------------------------------------------\n      data_out_ready_reg <= 1'b0;\n      if (data_ready_delay[0] == 1'b1) begin\n         data_out_reg       <= {captured_data, captured_data_last};\n         data_out_ready_reg <= 1'b1;\n      end\n         \n      //----------------------------------------------------------------------------\n      //-- update shift registers used to choose when to present data to/from memory\n      //----------------------------------------------------------------------------\n      data_ready_delay <= {1'b0, data_ready_delay[data_ready_delay_high:1]};\n      iob_dqm       <= dqm_sr[1:0];\n      dqm_sr        <= {2'b11, dqm_sr[dqm_sr_high:2]};\n         \n      case(state) \n         s_startup: begin\n               //------------------------------------------------------------------------\n               //-- This is the initial startup state, where we wait for at least 100us\n               //-- before starting the start sequence\n               //-- \n               //-- The initialisation is sequence is \n               //--  * de-assert SDRAM_CKE\n               //--  * 100us wait, \n               //--  * assert SDRAM_CKE\n               //--  * wait at least one cycle, \n               //--  * PRECHARGE\n               //--  * wait 2 cycles\n               //--  * REFRESH, \n               //--  * tREF wait\n               //--  * REFRESH, \n               //--  * tREF wait \n               //--  * LOAD_MODE_REG \n               //--  * 2 cycles wait\n               //------------------------------------------------------------------------\n               iob_cke <= 1'b1;\n               \n               // All the commands during the startup are NOPS, except these\n               if(startup_refresh_count == startup_refresh_max-31) begin\n                  // ensure all rows are closed\n                  iob_command     <= CMD_PRECHARGE;\n                  iob_address[prefresh_cmd] <= 1'b1;  // all banks\n                  iob_bank        <= 2'b00;\n               end\n               else if (startup_refresh_count == startup_refresh_max-23) begin\n                  // these refreshes need to be at least tREF (66ns) apart\n                  iob_command     <= CMD_REFRESH;\n               end else if (startup_refresh_count == startup_refresh_max-15) \n                  iob_command     <= CMD_REFRESH;\n               else if (startup_refresh_count == startup_refresh_max-7) begin\n                  // Now load the mode register\n                  iob_command     <= CMD_LOAD_MODE_REG;\n                  iob_address     <= MODE_REG;\n               end\n\n               //------------------------------------------------------\n               //-- if startup is coomplete then go into idle mode,\n               //-- get prepared to accept a new command, and schedule\n               //-- the first refresh cycle\n               //------------------------------------------------------\n               if (startup_refresh_count == 1'b0) begin\n                  state           <= s_idle;\n                  ready_for_new   <= 1'b1;\n                  got_transaction <= 1'b0;\n                  startup_refresh_count <= 2048 - cycles_per_refresh+1;\n               end\n            end\n         s_idle_in_6: state <= s_idle_in_5;\n         s_idle_in_5: state <= s_idle_in_4;\n         s_idle_in_4: state <= s_idle_in_3;\n         s_idle_in_3: state <= s_idle_in_2;\n         s_idle_in_2: state <= s_idle_in_1;\n         s_idle_in_1: state <= s_idle;\n\n         s_idle: begin\n               // Priority is to issue a refresh if one is outstanding\n               if (pending_refresh == 1'b1 || forcing_refresh == 1'b1) begin\n                  //------------------------------------------------------------------------\n                  //-- Start the refresh cycle. \n                  //-- This tasks tRFC (66ns), so 6 idle cycles are needed @ 100MHz\n                  //------------------------------------------------------------------------\n                  state       <= s_idle_in_6;\n                  iob_command <= CMD_REFRESH;\n                  startup_refresh_count <= startup_refresh_count - cycles_per_refresh+1;\n               end\n               else if (got_transaction == 1'b1) begin\n                  //--------------------------------\n                  //-- Start the read or write cycle. \n                  //-- First task is to open the row\n                  //--------------------------------\n                  state       <= s_open_in_2;\n                  iob_command <= CMD_ACTIVE;\n                  iob_address <= save_row;\n                  iob_bank    <= save_bank;\n               end               \n            end\n         //--------------------------------------------\n         //-- Opening the row ready for reads or writes\n         //--------------------------------------------\n         s_open_in_2: state <= s_open_in_1;\n\n         s_open_in_1: begin \n               // still waiting for row to open\n               if(save_wr == 1'b1) begin\n                  state       <= s_write_1;\n                  iob_dq_hiz  <= 1'b0;\n                  iob_data    <= save_data_in[15:0]; // get the DQ bus out of HiZ early\n               end else begin\n                  iob_dq_hiz  <= 1'b1;\n                  state       <= s_read_1;\n               end\n               // we will be ready for a new transaction next cycle!\n               ready_for_new   <= 1'b1; \n               got_transaction <= 1'b0;                  \n            end\n         //----------------------------------\n         //-- Processing the read transaction\n         //----------------------------------\n         s_read_1: begin\n               state           <= s_read_2;\n               iob_command     <= CMD_READ;\n               iob_address     <= save_col; \n               iob_bank        <= save_bank;\n               iob_address[prefresh_cmd] <= 1'b0; // A10 actually matters - it selects auto precharge\n               \n               // Schedule reading the data values off the bus\n               data_ready_delay[data_ready_delay_high]   <= 1'b1;\n               \n               // Set the data masks to read all bytes\n               iob_dqm     <= 2'b00;\n               dqm_sr[1:0] <= 2'b00;\n            end   \n         s_read_2: begin\n               state <= s_read_3;\n               if (forcing_refresh == 1'b0 && got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n                  if (save_wr == 1'b0) begin \n                     state           <= s_read_1;\n                     ready_for_new   <= 1'b1; // we will be ready for a new transaction next cycle!\n                     got_transaction <= 1'b0;\n                  end\n               end\n            end   \n         s_read_3: begin\n               state <= s_read_4;\n               if (forcing_refresh == 1'b0 && got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n                  if (save_wr == 1'b0) begin\n                     state           <= s_read_1;\n                     ready_for_new   <= 1'b1; // we will be ready for a new transaction next cycle!\n                     got_transaction <= 1'b0;\n                  end\n               end\n            end\n\n         s_read_4: begin\n               state <= s_precharge;\n               //-- can we do back-to-back read?\n               if (forcing_refresh == 1'b0 && got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n                  if (save_wr == 1'b0) begin \n                     state           <= s_read_1;\n                     ready_for_new   <= 1'b1; // we will be ready for a new transaction next cycle!\n                     got_transaction <= 1'b0;\n                  end\n                  else\n                     state <= s_open_in_2; // we have to wait for the read data to come back before we swutch the bus into HiZ\n               end\n            end\n         //------------------------------------------------------------------\n         // -- Processing the write transaction\n         //-------------------------------------------------------------------\n         s_write_1: begin\n               state                     <= s_write_2;\n               iob_command               <= CMD_WRITE;\n               iob_address               <= save_col; \n               iob_address[prefresh_cmd] <= 1'b0; // A10 actually matters - it selects auto precharge\n               iob_bank                  <= save_bank;\n               iob_dqm                   <= ! save_byte_enable[1:0];    \n               dqm_sr[1:0]               <= ! save_byte_enable[3:2];    \n               iob_data                  <= save_data_in[15:0];\n               iob_data_next             <= save_data_in[31:16];\n            end   \n         s_write_2: begin\n               state           <= s_write_3;\n               iob_data        <= iob_data_next;\n               // can we do a back-to-back write?\n               if (forcing_refresh == 1'b0 && got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n                  if (save_wr == 1'b1) begin\n                     // back-to-back write?\n                     state           <= s_write_1;\n                     ready_for_new   <= 1'b1;\n                     got_transaction <= 1'b0;\n                  end\n                  // Although it looks right in simulation you can't go write-to-read \n                  // here due to bus contention, as iob_dq_hiz takes a few ns.\n               end\n            end\n         s_write_3: begin\n               // must wait tRDL, hence the extra idle state\n               //-- back to back transaction?\n               if (forcing_refresh == 1'b0 && got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n                  if (save_wr == 1'b1) begin\n                     // back-to-back write?\n                     state           <= s_write_1;\n                     ready_for_new   <= 1'b1;\n                     got_transaction <= 1'b0;\n                  end\n                  else begin\n                     // write-to-read switch?\n                     state           <= s_read_1;\n                     iob_dq_hiz      <= 1'b1;\n                     ready_for_new   <= 1'b1; // we will be ready for a new transaction next cycle!\n                     got_transaction <= 1'b0;                  \n                  end \n               end else begin\n                  iob_dq_hiz         <= 1'b1;\n                  state              <= s_precharge;\n              end\n            end\n         //-------------------------------------------------------------------\n         //-- Closing the row off (this closes all banks)\n         //-------------------------------------------------------------------\n         s_precharge: begin\n               state                     <= s_idle_in_3;\n               iob_command               <= CMD_PRECHARGE;\n               iob_address[prefresh_cmd] <= 1'b1; // A10 actually matters - it selects all banks or just one\n            end\n         //-------------------------------------------------------------------\n         //-- We should never get here, but if we do then reset the memory\n         //-------------------------------------------------------------------\n         default: begin \n               state                 <= s_startup;\n               ready_for_new         <= 1'b0;\n               startup_refresh_count <= startup_refresh_max-sdram_startup_cycles;\n            end\n         endcase\n\n         if (reset == 1'b1) begin  // Sync reset\n            state                 <= s_startup;\n            ready_for_new         <= 1'b0;\n            startup_refresh_count <= startup_refresh_max-sdram_startup_cycles;\n         end\n      end      \nendmodule\n"]], "Diff Content": {"Delete": [[353, "           /*end else if (startup_refresh_count >= cycles_per_refresh) begin\n"], [355, "              startup_refresh_count <= 0;\n"], [356, "              state <= s_refresh;*/\n"], [517, "         s_refresh: begin\n"], [518, "               state                     <= s_idle_in_6;\n"], [519, "               iob_command               <= CMD_REFRESH;\n"], [520, "            end\n"]], "Add": []}}