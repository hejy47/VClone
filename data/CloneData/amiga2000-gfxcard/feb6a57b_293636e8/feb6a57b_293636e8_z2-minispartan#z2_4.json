{"Source Block": ["amiga2000-gfxcard/z2-minispartan/z2.v@654:1498@HdlStmProcess", "reg [2:0] linescalecount = 0;\n\n// =================================================================================\n// ZORRO MACHINE\n\nalways @(posedge z_sample_clk) begin\n  case (zorro_state)\n    RESET: begin\n      scalemode <= 0;\n      colormode <= 3;\n      dataout_enable <= 0;\n      dataout <= 0;\n      slaven <= 0;\n      z_ready <= 1; // clear XRDY (cpu wait)\n      zorro_ram_read_done <= 1;\n      blitter_enable <= 0;\n      \n      ram_low   <= 'h600000;\n      ram_high  <= 'h600000 + ram_size-4;\n      reg_low   <= 'h600000 + reg_base;\n      reg_high  <= 'h600000 + reg_base + reg_size;\n      \n      // poor man's z3sense\n      if (zaddr_autoconfig) begin\n        zorro_state <= Z2_CONFIGURING;\n        ZORRO3 <= 0;\n      end else if (z3addr[31:16]=='hff00)\n        zorro_state <= Z3_CONFIGURING;\n      \n    end\n    \n    Z3_CONFIGURING: begin\n      colormode <= 3;\n      if (!znCFGIN && z3addr[31:16]=='hff00 && znFCS_sync[2]==0) begin\n        if (zorro_read) begin\n          // read iospace 'he80000 (Autoconfig ROM)\n          dataout_enable <= 1;\n          dataout_z3 <= 1;\n          data_z3_low16 <= 'hffff;\n          slaven <= 1;\n          dtack_time <= 0;\n          zorro_state <= Z3_DTACK;\n          \n          case (z3addr[15:0])\n            'h0000: data <= 'b1000_1111_1111_1111; // zorro 3 (10), no pool link (0), no autoboot (0)\n            'h0100: data <= 'b0000_1111_1111_1111; // next board unrelated (0), 8mb\n            \n            'h0004: data <= 'b1111_1111_1111_1111; // product number\n            'h0104: data <= 'b1110_1111_1111_1111; // (1)\n            \n            'h0008: data <= 'b1010_1111_1111_1111; // flags inverted 0011\n            'h0108: data <= 'b1111_1111_1111_1111; // inverted zero\n            \n            'h000c: data <= 'b1111_1111_1111_1111; // reserved?\n            'h010c: data <= 'b1111_1111_1111_1111; // \n            \n            'h0010: data <= 'b1001_1111_1111_1111; // manufacturer high byte inverted (02)\n            'h0110: data <= 'b0010_1111_1111_1111; // \n            'h0014: data <= 'b1001_1111_1111_1111; // manufacturer low byte (9a)\n            'h0114: data <= 'b0001_1111_1111_1111;\n            \n            'h0018: data <= 'b1111_1111_1111_1111; // serial 01 01 01 01\n            'h0118: data <= 'b1110_1111_1111_1111; //\n            'h001c: data <= 'b1111_1111_1111_1111; //\n            'h011c: data <= 'b1110_1111_1111_1111; //\n            'h0020: data <= 'b1111_1111_1111_1111; //\n            'h0120: data <= 'b1110_1111_1111_1111; //\n            'h0024: data <= 'b1111_1111_1111_1111; //\n            'h0124: data <= 'b1110_1111_1111_1111; //\n            \n            //'h000040: data <= 'b0000_0000_0000_0000; // interrupts (not inverted)\n            //'h000042: data <= 'b0000_0000_0000_0000; //\n           \n            default: data <= 'b1111_1111_1111_1111;\n          endcase\n        end else begin\n          // write to autoconfig register\n          slaven <= 1;\n          if (((znUDS_sync[2]==0) || (znLDS_sync[2]==0))) begin\n            dtack_time <= 0;\n            zorro_state <= Z3_DTACK;\n            //z_confdone <= 1;\n            //colormode <= 1;\n            casex (z3addr[15:0])\n              'hXX44: begin\n                ram_low[31:16] <= data_in;\n                z_confdone <= 1;\n                colormode <= 1;\n              end\n              'hXX48: begin\n              end\n              'hXX4c: begin\n                // shutup\n                z_confdone <= 1;\n                colormode <= 1;\n              end\n            endcase\n          end\n        end\n      end else begin\n        // no address match\n        dataout_z3 <= 0;\n        dataout_enable <= 0;\n        slaven <= 0;\n        dtack <= 0;\n      end\n    end\n    \n    Z3_DTACK: begin\n      if (znFCS_sync[2]==1) begin\n        dtack <= 0;\n        dataout_z3 <= 0;\n        dataout_enable <= 0;\n        slaven <= 0;\n        dtack_time <= 0;\n        if (z_confdone) begin\n          zorro_state <= CONFIGURED;\n          ram_high  <= ram_low + ram_size-4;\n          reg_low   <= ram_low + reg_base;\n          reg_high  <= ram_low + reg_base + reg_size;\n        end else\n          zorro_state <= Z3_CONFIGURING;\n      end else begin\n        if (dtack_time < 2)\n          dtack_time <= dtack_time + 1'b1;\n        else\n          dtack <= 1;\n      end\n    end\n    \n    Z2_CONFIGURING: begin\n      colormode <= 3;\n      if (zaddr_autoconfig && !znCFGIN) begin\n        if (zorro_read) begin\n          // read iospace 'he80000 (Autoconfig ROM)\n          dataout_enable <= 1;\n          dataout <= 1;\n          slaven <= 1;\n          \n          case (zaddr[7:0])\n            8'h00: data <= 'b1100_1111_1111_1111; // zorro 2\n            8'h02: data <= 'b0111_1111_1111_1111; // next board unrelated (0), 4mb\n            \n            8'h04: data <= 'b1111_1111_1111_1111; // product number\n            8'h06: data <= 'b1110_1111_1111_1111; // (23)\n            \n            8'h08: data <= 'b0011_1111_1111_1111; // flags inverted 0011\n            8'h0a: data <= 'b1111_1111_1111_1111; // inverted zero\n            \n            8'h10: data <= 'b1001_1111_1111_1111; // manufacturer high byte inverted (02)\n            8'h12: data <= 'b0010_1111_1111_1111; // \n            8'h14: data <= 'b1001_1111_1111_1111; // manufacturer low byte (9a)\n            8'h16: data <= 'b0001_1111_1111_1111;\n            \n            8'h18: data <= 'b1111_1111_1111_1111; // serial 01 01 01 01\n            8'h1a: data <= 'b1110_1111_1111_1111; //\n            8'h1c: data <= 'b1111_1111_1111_1111; //\n            8'h1e: data <= 'b1110_1111_1111_1111; //\n            8'h20: data <= 'b1111_1111_1111_1111; //\n            8'h22: data <= 'b1110_1111_1111_1111; //\n            8'h24: data <= 'b1111_1111_1111_1111; //\n            8'h26: data <= 'b1110_1111_1111_1111; //\n            \n            //'h000040: data <= 'b0000_0000_0000_0000; // interrupts (not inverted)\n            //'h000042: data <= 'b0000_0000_0000_0000; //\n           \n            default: data <= 'b1111_1111_1111_1111;\n          endcase\n        end else begin\n          // write to autoconfig register\n          if (datastrobe_synced) begin\n            case (zaddr[7:0])\n              8'h48: begin\n                ram_low[31:24] <= 8'h0;\n                ram_low[23:20] <= zdata_in_sync[15:12];\n                zorro_state <= CONFIGURED; // configured\n                z_confdone <= 1;\n                colormode <= 1;\n              end\n              8'h4a: begin\n                ram_low[31:24] <= 8'h0;\n                ram_low[19:16] <= zdata_in_sync[15:12];\n              end\n              8'h4c: begin \n                zorro_state <= CONFIGURED; // configured, shut up\n                z_confdone <= 1;\n                colormode <= 1;\n              end\n            endcase\n          end\n        end\n      end else begin\n        // no address match\n        dataout <= 0;\n        dataout_enable <= 0;\n        slaven <= 0;\n      end\n    end\n    \n    CONFIGURED: begin\n      capture_mode <= 0;\n      scalemode <= 0;\n      colormode <= 1;\n      //screen_w <= 'h500;\n      //screen_h <= 'h210;\n      blitter_base <= 0;\n      pan_ptr <= 0;\n      capture_porch <= 'hb0;\n      sprite_ay <= 0;\n      sprite_ay2 <= 0;\n      burst_enabled <= 1;\n      margin_x <= 7;\n      row_pitch <= 2048;\n      \n      blitter_enable <= 1;\n      blitter_rgb <= 'h1111;\n\n      ram_high  <= ram_low + ram_size - 4;\n      reg_low   <= ram_low + reg_base;\n      reg_high  <= ram_low + reg_base + 'h800;\n      \n      if (ZORRO3)\n        zorro_state <= Z3_IDLE;\n      else\n        zorro_state <= Z2_IDLE;\n    end\n    \n    PAUSE: begin\n    end\n  \n    // ----------------------------------------------------------------------------------  \n    Z2_IDLE: begin\n      if (znAS_sync[1]==0 && znAS_sync[0]==0) begin\n        if (zaddr_sync=='h000000 && znCFGIN) begin\n          // poor man's IO reset\n          z_confdone <= 0;\n          zorro_state <= Z2_CONFIGURING;\n        end else if (zorro_read && zaddr_in_ram) begin\n          // read RAM\n          // request ram access from arbiter\n          zorro_ram_read_addr <= z2_mapped_addr;\n          zorro_ram_read_request <= 1;\n          zorro_ram_read_done <= 0;\n          data <= 'hffff;\n          read_counter <= 0;\n          \n          slaven <= 1;\n          dataout_enable <= 1;\n          dataout <= 1;\n          \n          z_ready <= 0;\n          zorro_state <= WAIT_READ2;\n          \n        end else if (zorro_write && zaddr_in_ram) begin\n          // write RAM          \n          last_addr <= ((zaddr_sync2-ram_low)>>1); // z2_mapped_addr\n          zorro_state <= WAIT_WRITE;\n          \n        end else if (zorro_write && zaddr_in_reg) begin\n          // write to register\n          zaddr_regpart <= z2_mapped_addr[15:0];\n          zorro_state <= WAIT_REGWRITE;\n          \n        end else if (zorro_read && zaddr_in_reg) begin\n          // read from registers\n          \n          dataout_enable <= 1;\n          dataout <= 1;\n          slaven <= 1;\n          \n          case (zaddr_sync2[7:0])\n            'h20: data <= blitter_x1;\n            'h22: data <= blitter_y1;\n            'h24: data <= blitter_x2;\n            'h26: data <= blitter_y2;\n            'h28: data <= blitter_rgb;\n            'h2a: data <= blitter_enable;\n            \n            'h60: data <= sd_busy<<8;\n            'h62: data <= sd_read<<8;\n            'h64: data <= sd_write<<8;\n            'h66: data <= sd_handshake_out<<8;\n            'h68: data <= sd_addr_in[31:16];\n            'h6a: data <= sd_addr_in[15:0];\n            'h6c: data <= sd_data_in<<8;\n            'h6e: data <= sd_data_out<<8;\n            'h70: data <= sd_error;\n            'h72: data <= sd_clkdiv;\n            \n            default: data <= 'h0000;\n          endcase\n         \n        end        \n      end else begin\n        dataout <= 0;\n        dataout_enable <= 0;\n        slaven <= 0;\n        write_stall <= 0;\n        z_ready <= 1; // clear XRDY (cpu wait)\n      end\n    end\n    \n    WAIT_REGWRITE: begin\n      if (datastrobe_synced) begin\n        regdata_in <= zdata_in_sync;\n        zaddr_regpart <= zaddr_sync2[15:0];\n        zorro_state <= REGWRITE;\n      end\n    end\n    \n    // ----------------------------------------------------------------------------------\n    WAIT_READ2: begin\n      if (znAS_sync[1]==1 && znAS_sync[0]==1) begin\n        // ram too slow TODO: report this\n        zorro_ram_read_request <= 0;\n        zorro_state <= Z2_IDLE;\n        z_ready <= 1;\n      end else if (zorro_ram_read_done) begin\n        read_counter <= read_counter + 1;\n        zorro_ram_read_request <= 0;\n        \n        if (read_counter >= dataout_time) begin\n          zorro_state <= WAIT_READ;\n        end\n        data <= zorro_ram_read_data;\n      end\n    end\n  \n    // ----------------------------------------------------------------------------------\n    WAIT_READ:\n      if (znAS_sync[1]==1 && znAS_sync[0]==1) begin\n        zorro_state <= Z2_IDLE;\n        z_ready <= 1;\n      end else begin\n        data <= zorro_ram_read_data;\n        z_ready <= 1;\n      end\n   \n    // ----------------------------------------------------------------------------------\n    WAIT_WRITE:\n      if (!zorro_ram_write_request) begin\n        z_ready <= 1;\n        write_stall <= 0;\n        if (datastrobe_synced) begin // && zdata_in_sync==data_in\n          zorro_ram_write_addr <= last_addr;\n          zorro_ram_write_bytes <= {~znUDS_sync[2],~znLDS_sync[2]};\n          zorro_ram_write_data <= zdata_in_sync;\n          zorro_ram_write_request <= 1;\n          \n          zorro_state <= WAIT_WRITE2;\n        end\n      end else begin\n        z_ready <= 0;\n        write_stall <= 1;\n      end\n    \n    // ----------------------------------------------------------------------------------\n    WAIT_WRITE2: begin\n      z_ready <= 1;\n      if (znAS_sync[1]==1 && znAS_sync[0]==1) begin\n        zorro_state <= Z2_IDLE;\n      end\n    end\n    \n    // ----------------------------------------------------------------------------------\n    // ----------------------------------------------------------------------------------\n    Z3_IDLE: begin\n      if (znCFGIN) begin\n        z_confdone <= 0;\n        zorro_state <= Z3_CONFIGURING;\n      end else if (znFCS_sync[2]==0) begin\n        // falling edge of /FCS\n        if (z3addr=='h00000000) begin\n          // reset detection\n          z_confdone <= 0;\n          zorro_state <= Z3_CONFIGURING;\n        end else if ((z3addr >= ram_low) && (z3addr <= ram_high) && !zorro_read) begin\n          slaven <= 1;\n          if ((znUDS_sync[2]==0) || (znLDS_sync[2]==0) || (znDS1_sync[2]==0) || (znDS0_sync[2]==0)) begin\n            zorro_state <= Z3_WRITE_UPPER;\n          end\n        end else if ((z3addr >= ram_low) && (z3addr <= ram_high) && zorro_read) begin\n          // read from memory\n          slaven <= 1;\n          zorro_state <= Z3_READ_UPPER;\n        end else if (zorro_write && (z3addr >= reg_low) && (z3addr <= reg_high)) begin\n          // write to register\n          slaven <= 1;\n          if (znDS1_sync[2]==0) begin\n            regdata_in <= data_in_z3_low16;\n            zaddr_regpart <= (z3addr[15:0])|16'h2;\n            zorro_state <= REGWRITE;\n          end else if (znUDS_sync[2]==0) begin\n            regdata_in <= zdata_in_sync;\n            zaddr_regpart <= z3addr[15:0];\n            zorro_state <= REGWRITE;\n          end\n        end else if (zorro_read && (z3addr >= reg_low) && (z3addr <= reg_high)) begin\n          // read registers\n          slaven <= 1;\n          dataout_enable <= 1;\n          dataout_z3 <= 1;\n          data <= 0;\n          \n          if (znDS1_sync[2]==0) begin\n            regdata_in <= data_in_z3_low16;\n            zaddr_regpart <= (z3addr[15:0])|16'h2;\n            zorro_state <= REGREAD;\n          end else if (znUDS_sync[2]==0) begin\n            regdata_in <= zdata_in_sync;\n            zaddr_regpart <= z3addr[15:0];\n            zorro_state <= REGREAD;\n          end\n        end else begin\n          // address not recognized\n          slaven <= 0;\n          dtack <= 0;\n          dataout_enable <= 0;\n          dataout_z3 <= 0;\n        end\n        \n      end else begin\n        // not in a cycle\n        slaven <= 0;\n        dtack <= 0;\n        dataout_enable <= 0;\n        dataout_z3 <= 0;\n      end\n    end\n    \n    Z3_READ_UPPER: begin\n      if (!zorro_ram_read_request) begin\n        z3_read_addr <= z3_mapped_addr;\n        zorro_state <= Z3_READ_LOWER;\n        zorro_ram_read_addr <= z3_mapped_addr[23:0];\n        zorro_ram_read_bytes <= 2'b11;\n        zorro_ram_read_request <= 1;\n        zorro_ram_read_done <= 0;\n      end\n    end\n    \n    Z3_READ_LOWER: begin\n      if (zorro_ram_read_done) begin\n        zorro_ram_read_addr <= (z3_read_addr[23:0])|24'b1;\n        zorro_ram_read_bytes <= 2'b11;\n        zorro_ram_read_request <= 1;\n        zorro_ram_read_done <= 0;\n        z3_read_data <= zorro_ram_read_data;\n        zorro_state <= Z3_READ_DELAY;\n      end\n    end\n    \n    Z3_READ_DELAY: begin\n      if (zorro_ram_read_done) begin\n        data <= z3_read_data;\n        data_z3_low16 <= zorro_ram_read_data;\n        dataout_enable <= 1;\n        dataout_z3 <= 1;\n        zorro_ram_read_done <= 0;\n        zorro_state <= Z3_ENDCYCLE;\n      end\n    end\n    \n    Z3_WRITE_UPPER: begin\n      // wait for free memory bus\n      if ((znUDS_sync[2]==0) || (znLDS_sync[2]==0)) begin\n        if (!zorro_ram_write_request) begin\n          zorro_ram_write_addr <= z3_mapped_addr[23:0];\n          zorro_ram_write_bytes <= ~{znUDS_sync[2],znLDS_sync[2]};\n          zorro_ram_write_data <= z3_din_high_s2;\n          zorro_ram_write_request <= 1;\n          zorro_state <= Z3_WRITE_LOWER;\n        end\n      end else begin\n        // only lower bytes shall be written\n        zorro_state <= Z3_WRITE_LOWER;\n      end\n    end\n    \n    Z3_WRITE_LOWER: begin\n      if ((znDS1_sync[2]==0) || (znDS0_sync[2]==0)) begin\n        if (!zorro_ram_write_request) begin\n          zorro_ram_write_addr <= (z3_mapped_addr[23:0])|1'b1;\n          zorro_ram_write_bytes <= ~{znDS1_sync[2],znDS0_sync[2]};\n          zorro_ram_write_data <= z3_din_low_s2; // low!\n          zorro_ram_write_request <= 1;\n          \n          zorro_state <= Z3_ENDCYCLE;\n        end\n      end else begin\n        zorro_state <= Z3_ENDCYCLE;\n      end\n    end\n    \n    Z3_ENDCYCLE: begin\n      if (znFCS_sync[2]==1) begin\n        dtack <= 0;\n        slaven <= 0;\n        dataout_enable <= 0;\n        dataout_z3 <= 0;\n        zorro_state <= Z3_IDLE;\n      end else\n        dtack <= 1;\n    end\n    \n    REGREAD: begin\n      dtack <= 1;\n      zorro_state <= Z3_ENDCYCLE;\n      \n      case (zaddr_regpart)\n        'h2a: data_z3_low16 <= blitter_enable;\n        \n        'h60: data_z3_low16 <= sd_busy;\n        'h62: data_z3_low16 <= sd_read;\n        'h64: data_z3_low16 <= sd_write;\n        'h66: data_z3_low16 <= sd_handshake_out;\n        'h68: data_z3_low16 <= sd_addr_in[31:16];\n        'h6a: data_z3_low16 <= sd_addr_in[15:0];\n        'h6c: data_z3_low16 <= sd_data_in;\n        'h6e: data_z3_low16 <= sd_data_out;\n        'h70: data_z3_low16 <= sd_error;\n        'h72: data_z3_low16 <= sd_clkdiv;\n        \n        default: data_z3_low16 <= 'h0000;\n      endcase\n    end\n    \n    REGWRITE: begin\n      if (ZORRO3) begin\n        dtack <= 1;\n        zorro_state <= Z3_IDLE;\n      end else\n        zorro_state <= Z2_IDLE;\n      \n      /*if (zaddr_regpart>='h920) begin\n        sprite_palette_r[zaddr_nybble] <= regdata_in[7:0];\n      end else if (zaddr_regpart>='h910) begin\n        sprite_palette_g[zaddr_nybble] <= regdata_in[7:0];\n      end else if (zaddr_regpart>='h900) begin\n        sprite_palette_b[zaddr_nybble] <= regdata_in[7:0];\n      end else if (zaddr_regpart>='h880) begin\n        sprite_a2[zaddr_7f] <= regdata_in[15:0];\n      end else if (zaddr_regpart>='h800) begin\n        sprite_a1[zaddr_7f] <= regdata_in[15:0];*/\n      if (zaddr_regpart>='h600) begin\n        palette_r[zaddr_regpart[8:1]] <= regdata_in[7:0];\n      end else if (zaddr_regpart>='h400) begin\n        palette_g[zaddr_regpart[8:1]] <= regdata_in[7:0];\n      end else if (zaddr_regpart>='h200) begin\n        palette_b[zaddr_regpart[8:1]] <= regdata_in[7:0];\n      end else\n      case (zaddr_regpart)\n        //'h02: ram_refresh <= regdata_in[0];\n        'h04: scalemode <= regdata_in[1:0];\n        'h06: screen_w <= regdata_in[11:0];\n        'h08: screen_h <= regdata_in[11:0];\n        \n        'h0a: dataout_time <= regdata_in[7:0];\n        'h0c: margin_x <= regdata_in[9:0];\n        'h10: preheat_x <= regdata_in[4:0];\n        'h12: safe_x1 <= regdata_in[10:0];\n        'h14: safe_x2 <= regdata_in[10:0];\n        /*'h16: glitchx2_reg <= regdata_in[10:0];\n        'h18: ram_burst_col <= regdata_in[8:0];\n        'h1a: fetch_preroll <= regdata_in[10:0];*/\n        \n        // blitter regs\n        'h1c: blitter_base[23:16] <= regdata_in[7:0];\n        'h1e: blitter_base[15:0]  <= regdata_in;\n        'h20: blitter_x1 <= regdata_in[10:0];\n        'h22: blitter_y1 <= regdata_in[10:0];\n        'h24: blitter_x2 <= regdata_in[10:0];\n        'h26: blitter_y2 <= regdata_in[10:0];\n        'h28: blitter_rgb <= regdata_in[15:0];\n        'h2a: begin\n          blitter_enable <= regdata_in[3:0];\n          \n          blitter_curx <= blitter_x1;\n          blitter_cury <= blitter_y1;\n          blitter_curx2 <= blitter_x3;\n          blitter_cury2 <= blitter_y3;\n          \n          blitter_dirx <= (blitter_x3>blitter_x4)?1'b1:1'b0;\n          blitter_diry <= (blitter_y3>blitter_y4)?1'b1:1'b0;\n          \n          blitter_ptr <= blitter_base + (blitter_y1 << 11); // * row_pitch?\n          blitter_rgb32_t <= 1;\n        end\n        'h2c: blitter_x3 <= regdata_in[10:0];\n        'h2e: blitter_y3 <= regdata_in[10:0];\n        'h30: blitter_x4 <= regdata_in[10:0];\n        'h32: blitter_y4 <= regdata_in[10:0];\n        'h34: blitter_rgb32[0] <= regdata_in[15:0];\n        'h36: blitter_rgb32[1] <= regdata_in[15:0];\n        \n        'h38: pan_ptr[23:16] <= regdata_in[7:0];\n        'h3a: pan_ptr[15:0]  <= regdata_in;\n        \n        'h40: sprite_ax <= regdata_in[10:0];\n        'h42: sprite_ay <= regdata_in[10:0];\n        'h44: sprite_ax2 <= regdata_in[10:0];\n        'h46: sprite_ay2 <= regdata_in[10:0];\n        \n        'h48: colormode <= regdata_in[2:0];\n        \n        //'h50: capture_mode <= regdata_in[0];\n        'h52: capture_freq <= regdata_in[5:0];\n        'h54: capture_porch <= regdata_in[7:0];\n        'h56: capture_shift <= regdata_in[9:0];\n        \n        'h58: row_pitch <= regdata_in;\n        'h5a: burst_enabled <= regdata_in[0];\n        \n        // sd card regs\n        'h60: sd_reset <= regdata_in[8];\n        'h62: sd_read <= regdata_in[8];\n        'h64: sd_write <= regdata_in[8];\n        'h66: sd_handshake_in <= regdata_in[8];\n        'h68: sd_addr_in[31:16] <= regdata_in;\n        'h6a: sd_addr_in[15:0] <= regdata_in;\n        'h6c: sd_data_in <= regdata_in[15:8];\n      endcase\n    end\n\n  endcase\n\n// =================================================================================\n// RAM ARBITER\n\n  case (ram_arbiter_state)\n    RAM_READY: begin\n      ram_enable <= 1;\n      ram_arbiter_state <= RAM_READY2;\n    end\n    \n    RAM_READY2: begin\n      // start fetching a row\n      ram_addr  <= fetch_y+glitchx2_reg; //((fetch_y << 11)|glitchx2_reg);\n      ram_write <= 0;\n      ram_byte_enable <= 'b11;\n      fetch_x <= 0;\n      fetch_x2 <= glitchx2_reg;\n      \n      if (row_fetched) begin\n        ram_burst <= 0;\n        ram_arbiter_state <= RAM_BURST_OFF;\n      end else begin\n        //ram_burst <= 0;\n        ram_burst <= burst_enabled; // FIXME\n        ram_arbiter_state <= RAM_BURST_ON;\n      end\n    end\n    \n    RAM_BURST_ON: begin\n      if (cmd_ready) ram_arbiter_state <= RAM_FETCHING_ROW8;\n    end\n    \n    RAM_BURST_OFF: begin\n      ram_enable <= 0;\n      if (data_out_queue_empty && cmd_ready)\n        ram_arbiter_state <= RAM_ROW_FETCHED;\n    end\n    \n    RAM_FETCHING_ROW8: begin\n      if (fetch_x == (screen_w + margin_x)) begin\n        row_fetched <= 1; // row completely fetched\n        ram_burst <= 0;\n        ram_arbiter_state <= RAM_READY;\n      end else if (data_out_ready) begin\n        ram_enable <= 1;\n        ram_write <= 0;\n        ram_byte_enable <= 'b11;\n        ram_addr  <= ram_addr + 1'b1; // fetch_y + fetch_x; //2; //((fetch_y << 11) | fetch_x2); // burst incremented\n      \n        fetch_x <= fetch_x + 1'b1;\n        fetch_x2 <= fetch_x2 + 1'b1;\n        \n        fetch_buffer[fetch_x] <= ram_data_out;\n        //fetch_buffer2[fetch_x] <= ram_data_out;\n      end\n    end\n      \n    RAM_ROW_FETCHED:\n      if (need_row_fetch) begin\n        row_fetched <= 0;\n        fetch_x <= 0;\n        if (counter_y == screen_h-1) begin\n          fetch_y <= pan_ptr; // TODO pan point\n          linescalecount <= 0;\n        end else if (linescalecount < scalemode) begin\n          linescalecount <= linescalecount + 1'b1;\n        end else begin\n          fetch_y <= fetch_y + row_pitch;\n          linescalecount <= 0;\n        end\n        \n        ram_arbiter_state <= RAM_READY;\n        \n      end else if (counter_x < safe_x1 || counter_x > safe_x2) begin\n        // do nothing if not in safe area\n        \n      // BLITTER ----------------------------------------------------------------\n      end else if (blitter_enable==1 && cmd_ready) begin\n        if (colormode==2) begin\n          blitter_rgb <= blitter_rgb32[blitter_rgb32_t];\n          blitter_rgb32_t <= ~blitter_rgb32_t;\n        end\n        \n        // rect fill blitter\n        if (blitter_curx <= blitter_x2) begin\n          blitter_curx <= blitter_curx + 1'b1;\n          ram_byte_enable <= 'b11;\n          ram_addr    <= blitter_ptr + blitter_curx;          \n          ram_data_in <= blitter_rgb;\n          ram_write   <= 1;\n          ram_enable  <= 1;\n        end else if (blitter_cury<blitter_y2) begin\n          blitter_cury <= blitter_cury + 1'b1;\n          blitter_curx <= blitter_x1;\n          blitter_ptr <= blitter_ptr + row_pitch;\n        end else begin\n          blitter_curx <= 0;\n          blitter_cury <= 0;\n          blitter_enable <= 0;\n          //ram_enable <= 0;\n        end\n      end else if (blitter_enable==2 && cmd_ready) begin\n        // block copy read\n        if (data_out_queue_empty) begin\n          ram_byte_enable <= 'b11;\n          ram_addr    <= blitter_base+(blitter_cury2<<11)+blitter_curx2; // FIXME\n          ram_write   <= 0;\n          ram_enable  <= 1;\n          ram_arbiter_state <= RAM_READING_BLIT;\n        end else \n          ram_enable <= 0;\n        \n      end else if (blitter_enable==4 && cmd_ready) begin\n        // block copy write\n        ram_addr    <= blitter_base+(blitter_cury<<11)+blitter_curx; // FIXME\n        ram_data_in <= blitter_copy_rgb;\n        ram_write   <= 1;\n        ram_enable  <= 1;\n        ram_byte_enable <= 'b11;\n        \n        if (blitter_curx2 != blitter_x4) begin\n          if (blitter_dirx==1) begin\n            blitter_curx2 <= blitter_curx2 - 1'b1;\n            blitter_curx  <= blitter_curx - 1'b1;\n          end else begin\n            blitter_curx2 <= blitter_curx2 + 1'b1;\n            blitter_curx  <= blitter_curx + 1'b1;\n          end\n        end else if (blitter_cury2 == blitter_y4) begin\n          // done\n        end else if (blitter_diry == 0) begin\n          blitter_curx <= blitter_x1;\n          blitter_curx2 <= blitter_x3;\n          blitter_cury <= blitter_cury + 1'b1;\n          blitter_cury2 <= blitter_cury2 + 1'b1;\n        end else begin\n          blitter_curx <= blitter_x1;\n          blitter_curx2 <= blitter_x3;\n          blitter_cury <= blitter_cury - 1'b1;\n          blitter_cury2 <= blitter_cury2 - 1'b1;\n        end\n        \n        blitter_enable <= 5; // next\n      end else if (blitter_enable==5) begin\n        if (blitter_curx2==blitter_x4 && blitter_cury2 == blitter_y4)\n          blitter_enable <= 0;\n        else\n          blitter_enable <= 2;\n        ram_enable <= 0;\n        \n      // ZORRO READ/WRITE ----------------------------------------------\n      end else if (blitter_enable==0 && zorro_ram_read_request) begin\n        // process read request\n        zorro_ram_read_done <= 0;\n        if (cmd_ready && data_out_queue_empty) begin\n          ram_write <= 0;\n          ram_addr <= zorro_ram_read_addr;\n          ram_byte_enable <= 'b11;\n          ram_enable <= 1;\n          ram_arbiter_state <= RAM_READING_ZORRO;\n        end else \n          ram_enable <= 0;\n      end else if (blitter_enable==0 && zorro_ram_write_request && cmd_ready) begin\n        // process write request\n        zorro_ram_write_done <= 1;\n        zorro_ram_write_request <= 0;\n        \n        if (zorro_ram_write_bytes[1] && !zorro_ram_write_bytes[0])\n          ram_byte_enable <= 'b10; // UDS\n        else if (zorro_ram_write_bytes[0] && !zorro_ram_write_bytes[1])\n          ram_byte_enable <= 'b01; // LDS\n        else\n          ram_byte_enable <= 'b11;\n        \n        ram_data_in <= zorro_ram_write_data;\n        ram_addr    <= zorro_ram_write_addr;\n        ram_write   <= 1;\n        ram_enable  <= 1;\n        \n        ram_arbiter_state <= RAM_WRITING_ZORRO;\n      end else if (capture_mode==1) begin\n        ram_addr    <= capture_ptr+capture_x;\n        ram_byte_enable <= 'b11;\n        ram_data_in <= capture_rgb;\n        ram_write   <= 1;\n        ram_enable  <= 1;\n      end\n      \n    RAM_READING_BLIT: begin\n      // block copy (data ready)\n      if (data_out_ready) begin\n        ram_enable <= 0;\n        blitter_copy_rgb <= ram_data_out;\n        blitter_enable <= 4;\n        ram_arbiter_state <= RAM_ROW_FETCHED;\n      end\n    end\n      \n    RAM_READING_ZORRO: begin\n      if (data_out_ready) begin\n        ram_enable <= 0;\n        zorro_ram_read_data <= ram_data_out;\n        zorro_ram_read_done <= 1;\n        zorro_ram_read_request <= 0;\n        ram_arbiter_state <= RAM_ROW_FETCHED;\n      end\n    end\n    \n    RAM_WRITING_ZORRO: begin\n      ram_enable <= 0;\n      ram_arbiter_state <= RAM_ROW_FETCHED;\n    end\n    \n  endcase\nend\n\nreg[23:0] rgb = 'h000000;\nreg[31:0] rgb32 = 'h00000000;\nreg[11:0] counter_8x = 0;\nreg counter_x_hi = 0;\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[677, "      if (zaddr_autoconfig) begin\n"], [678, "        zorro_state <= Z2_CONFIGURING;\n"], [679, "        ZORRO3 <= 0;\n"], [680, "      end else if (z3addr[31:16]=='hff00)\n"], [681, "        zorro_state <= Z3_CONFIGURING;\n"], [777, "        if (dtack_time < 2)\n"], [1021, "      if (znCFGIN) begin\n"], [1024, "      end else if (znFCS_sync[2]==0) begin\n"], [1029, "          zorro_state <= Z3_CONFIGURING;\n"]], "Add": [[669, "      warmup_counter <= 'hffffff;\n"], [681, "      zorro_state <= PAUSE;\n"], [681, "      sdram_reset <= 1;\n"], [777, "        if (dtack_time < 3)\n"], [873, "      sdram_reset <= 0;\n"], [881, "      if (zaddr_autoconfig) begin\n"], [881, "        zorro_state <= Z2_CONFIGURING;\n"], [881, "        ZORRO3 <= 0;\n"], [881, "      end else if (z3addr[31:16]=='hff00) begin\n"], [881, "        zorro_state <= Z3_CONFIGURING;\n"], [881, "      end\n"], [1021, "      /*if (znCFGIN) begin\n"], [1024, "      end else*/ if (znFCS_sync[2]==0) begin\n"], [1029, "          zorro_state <= RESET;\n"], [1163, "        'h20: data_z3_low16 <= blitter_x1;\n"], [1163, "        'h22: data_z3_low16 <= blitter_y1;\n"], [1163, "        'h24: data_z3_low16 <= blitter_x2;\n"], [1163, "        'h26: data_z3_low16 <= blitter_y2;\n"], [1163, "        'h28: data_z3_low16 <= blitter_rgb;\n"]]}}