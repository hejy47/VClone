{"Source Block": ["amiga2000-gfxcard/z2-minispartan/z2.v@614:1622@HdlStmProcess", "reg z2_addr_valid = 0;\n\n// =================================================================================\n// ZORRO MACHINE\n\nalways @(posedge z_sample_clk) begin\n      \n  /*if (rec_enable) begin\n    if (rec_idx==1023) begin\n      rec_enable <= 0;\n      rec_idx <= 0;\n    end else begin\n      rec_idx <= rec_idx+1;\n      rec_zreadraw[rec_idx>>2] <= zREAD;\n      rec_zread[rec_idx>>2] <= zorro_read;\n      rec_zwrite[rec_idx>>2] <= zorro_write;\n      rec_zas0[rec_idx>>2] <= znAS_sync[0];\n      rec_zas1[rec_idx>>2] <= znAS_sync[1];\n      rec_zaddr_in_ram[rec_idx>>2] <= zaddr_in_ram;\n      rec_state[rec_idx>>2] <= ((zorro_state==WAIT_READ3)||(zorro_state==WAIT_READ2)||(zorro_state==WAIT_READ))?1'b1:1'b0;\n      rec_statew[rec_idx>>2] <= ((zorro_state==WAIT_WRITE2)||(zorro_state==WAIT_WRITE))?1'b1:1'b0;\n      rec_ready[rec_idx>>2] <= z_ready;\n      ///rec_zaddr[rec_idx] <= zaddr;\n    end\n  end*/\n  \n  if (znCFGIN_sync[1]==1 || z_reset) begin\n    zorro_state <= RESET;\n  end\n  \n  case (zorro_state)\n    RESET: begin\n      vga_clk_sel  <= 0;\n      screen_w     <= 1280;\n      h_rez        <= 1280;\n      h_sync_start <= 1280+72;\n      h_sync_end   <= 1280+80;\n      h_max        <= 1647;\n      screen_h     <= 720;\n      v_rez        <= 720;\n      v_sync_start <= 720+3;\n      v_sync_end   <= 720+8;\n      v_max        <= 749;\n      \n      z_confout <= 0;\n      z3_confdone <= 0;\n      \n      scalemode <= 0;\n      colormode <= 1;\n      dataout_enable <= 0;\n      dataout <= 0;\n      slaven <= 0;\n      z_ready <= 1; // clear XRDY (cpu wait)\n      zorro_ram_read_done <= 1;\n      blitter_enable <= 0;\n      warmup_counter <= 0;\n      sdram_reset <= 1;\n      \n      blitter_x1 <= 0;\n      blitter_y1 <= 0; \n      blitter_x2 <= 1279;\n      blitter_y2 <= 719;\n      blitter_ptr <= 0;\n      \n      ram_low   <= 'h600000;\n      ram_high  <= 'h600000 + ram_size-4;\n      reg_low   <= 'h600000 + ram_size;\n      reg_high  <= 'h600000 + ram_size + reg_size;\n      \n      if (clock_locked && znRST_sync == 2'b11)\n        zorro_state <= PAUSE;\n    end\n    \n    PAUSE: begin\n      // poor man's z3sense\n      if (zaddr_autoconfig) begin\n        ZORRO3 <= 0;\n        zorro_state <= Z2_CONFIGURING;\n      end else if (z3addr_autoconfig) begin\n        ZORRO3 <= 1;\n        zorro_state <= Z3_CONFIGURING;\n      end\n    end\n    \n    Z3_CONFIGURING: begin\n      if (znCFGIN_sync[2]==0 && z3addr_autoconfig && znFCS_sync[1]==0) begin\n        if (zorro_read) begin\n          // autoconfig ROM\n          dataout_enable <= 1;\n          dataout_z3 <= 1;\n          data_z3_low16 <= 'hffff;\n          slaven <= 1;\n          dtack_time <= 0;\n          zorro_state <= Z3_DTACK;\n          \n          case (z3addr[15:0])\n            'h0000: data_z3_hi16 <= 'b1000_1111_1111_1111; // zorro 3 (10), no pool link (0), no autoboot (0)\n            'h0100: data_z3_hi16 <= 'b0001_1111_1111_1111; // next board unrelated (0), 32mb\n            \n            'h0004: data_z3_hi16 <= 'b1111_1111_1111_1111; // product number\n            'h0104: data_z3_hi16 <= 'b1110_1111_1111_1111; // (1)\n            \n            'h0008: data_z3_hi16 <= 'b0000_1111_1111_1111; // flags inverted 0111 io,shutup,extension,reserved(1)\n            'h0108: data_z3_hi16 <= 'b1111_1111_1111_1111; // inverted zero\n            \n            'h000c: data_z3_hi16 <= 'b1111_1111_1111_1111; // reserved?\n            'h010c: data_z3_hi16 <= 'b1111_1111_1111_1111; // \n            \n            'h0010: data_z3_hi16 <= 'b1001_1111_1111_1111; // manufacturer high byte inverted\n            'h0110: data_z3_hi16 <= 'b0010_1111_1111_1111; // \n            'h0014: data_z3_hi16 <= 'b1001_1111_1111_1111; // manufacturer low byte\n            'h0114: data_z3_hi16 <= 'b0001_1111_1111_1111;\n            \n            'h0018: data_z3_hi16 <= 'b1111_1111_1111_1111; // serial 01 01 01 01\n            'h0118: data_z3_hi16 <= 'b1110_1111_1111_1111; //\n            'h001c: data_z3_hi16 <= 'b1111_1111_1111_1111; //\n            'h011c: data_z3_hi16 <= 'b1110_1111_1111_1111; //\n            'h0020: data_z3_hi16 <= 'b1111_1111_1111_1111; //\n            'h0120: data_z3_hi16 <= 'b1110_1111_1111_1111; //\n            'h0024: data_z3_hi16 <= 'b1111_1111_1111_1111; //\n            'h0124: data_z3_hi16 <= 'b1110_1111_1111_1111; //\n            \n            //'h000040: data_z3_hi16 <= 'b0000_0000_0000_0000; // interrupts (not inverted)\n            //'h000042: data_z3_hi16 <= 'b0000_0000_0000_0000; //\n           \n            default: data_z3_hi16 <= 'b1111_1111_1111_1111;\n          endcase\n        end else begin\n          // write to autoconfig register\n          slaven <= 1;\n          if (((znUDS_sync[2]==0) || (znLDS_sync[2]==0))) begin\n            dtack_time <= 0;\n            zorro_state <= Z3_DTACK;\n            casex (z3addr[15:0])\n              'hXX44: begin\n                z3_ram_low[31:16] <= data_in;\n                z3_confdone <= 1;\n              end\n              'hXX48: begin\n              end\n              'hXX4c: begin\n                // shutup\n                z3_confdone <= 1;\n              end\n            endcase\n          end\n        end\n      end else begin\n        // no address match\n        dataout_z3 <= 0;\n        dataout_enable <= 0;\n        slaven <= 0;\n        dtack <= 0;\n      end\n    end\n    \n    Z3_DTACK: begin\n      if (znFCS_sync[2]==1) begin\n        dtack <= 0;\n        dataout_z3 <= 0;\n        dataout_enable <= 0;\n        slaven <= 0;\n        dtack_time <= 0;\n        if (z3_confdone) begin\n          zorro_state <= CONFIGURED;\n          ram_high  <= z3_ram_low + z3_ram_size-'h10000-4;\n          reg_low   <= z3_ram_low + z3_ram_size-'h10000;\n          reg_high  <= z3_ram_low + z3_ram_size-'h10000 + reg_size;\n        end else\n          zorro_state <= Z3_CONFIGURING;\n      end else begin\n        if (dtack_time < 2)\n          dtack_time <= dtack_time + 1'b1;\n        else\n          dtack <= 1;\n      end\n    end\n    \n    Z2_CONFIGURING: begin\n      // CHECK\n      if (zaddr_autoconfig && !znCFGIN_sync[2]) begin\n        if (zorro_read) begin\n          // read iospace 'he80000 (Autoconfig ROM)\n          dataout_enable <= 1;\n          dataout <= 1;\n          slaven <= 1;\n          \n          case (zaddr_sync2[7:0])\n            8'h00: data <= 'b1100_1111_1111_1111; // zorro 2\n            8'h02: data <= 'b0111_1111_1111_1111; // next board unrelated (0), 4mb\n            \n            8'h04: data <= 'b1111_1111_1111_1111; // product number\n            8'h06: data <= 'b1110_1111_1111_1111; // (1)\n            \n            8'h08: data <= 'b0011_1111_1111_1111; // flags inverted 0011\n            8'h0a: data <= 'b1111_1111_1111_1111; // inverted zero\n            \n            8'h10: data <= 'b1001_1111_1111_1111; // manufacturer high byte inverted (02)\n            8'h12: data <= 'b0010_1111_1111_1111; // \n            8'h14: data <= 'b1001_1111_1111_1111; // manufacturer low byte (9a)\n            8'h16: data <= 'b0001_1111_1111_1111;\n            \n            8'h18: data <= 'b1111_1111_1111_1111; // serial 01 01 01 01\n            8'h1a: data <= 'b1110_1111_1111_1111; //\n            8'h1c: data <= 'b1111_1111_1111_1111; //\n            8'h1e: data <= 'b1110_1111_1111_1111; //\n            8'h20: data <= 'b1111_1111_1111_1111; //\n            8'h22: data <= 'b1110_1111_1111_1111; //\n            8'h24: data <= 'b1111_1111_1111_1111; //\n            8'h26: data <= 'b1110_1111_1111_1111; //\n            \n            //'h000040: data <= 'b0000_0000_0000_0000; // interrupts (not inverted)\n            //'h000042: data <= 'b0000_0000_0000_0000; //\n           \n            default: data <= 'b1111_1111_1111_1111;\n          endcase\n        end else begin\n          // write to autoconfig register\n          if (datastrobe_synced) begin\n            case (zaddr_sync2[7:0])\n              8'h48: begin\n                ram_low[31:24] <= 8'h0;\n                ram_low[23:20] <= zdata_in_sync[15:12];\n                ram_low[15:0] <= 16'h0;\n                zorro_state <= Z2_PRE_CONFIGURED; // configured\n              end\n              8'h4a: begin\n                ram_low[31:24] <= 8'h0;\n                ram_low[19:16] <= zdata_in_sync[15:12];\n                ram_low[15:0] <= 16'h0;\n              end\n              \n              8'h4c: begin \n                zorro_state <= Z2_PRE_CONFIGURED; // configured, shut up\n              end\n            endcase\n          end\n        end\n      end else begin\n        // no address match\n        dataout <= 0;\n        dataout_enable <= 0;\n        slaven <= 0;\n      end\n    end\n    \n    Z2_PRE_CONFIGURED: begin\n      if (znAS_sync[2]==1) begin\n        z_confout<=1;\n        zorro_state <= CONFIGURED;\n      end\n    end\n    \n    /*Z2_PRE_CONFIGURED2: begin\n      if (znCFGIN_sync[2:0]=='b111) begin\n        zorro_state <= Z2_IDLE;\n      end\n    end*/\n    \n    CONFIGURED: begin\n      scalemode <= 0;\n      colormode <= 1;\n      blitter_base <= 0;\n      pan_ptr <= 0;\n      burst_enabled <= 1;\n      margin_x <= 7;\n      row_pitch <= 2048;\n      row_pitch_shift <= 11;\n      \n      blitter_enable <= 1;\n      blitter_rgb <= 'h1111;\n\n      ram_high  <= ram_low + ram_size-'h10000-4;\n      reg_low   <= ram_low + ram_size-'h10000;\n      reg_high  <= ram_low + ram_size-'h10000 + reg_size;\n      \n      z3_ram_high  <= z3_ram_low + z3_ram_size-'h10000-4;\n      z3_reg_low   <= z3_ram_low + z3_ram_size-'h10000;\n      z3_reg_high  <= z3_ram_low + z3_ram_size-'h10000 + reg_size;\n      \n      z_confout <= 1;\n      \n      sdram_reset <= 0;\n      if (ZORRO3) begin\n        zorro_state <= Z3_IDLE;\n      end else begin\n        zorro_state <= Z2_IDLE;\n      end\n    end\n  \n    // ----------------------------------------------------------------------------------\n    Z2_IDLE: begin\n      if (dvid_reset) begin\n        dvid_reset_counter <= 2;\n        zorro_state <= RESET_DVID;\n      end else\n      if (z2_addr_valid) begin\n        if (zorro_read && zaddr_in_ram) begin\n          /*if (!rec_enable) begin \n            rec_enable <= 1;\n            rec_idx <= 0;\n          end*/\n          \n          // read RAM\n          // request ram access from arbiter\n          last_addr <= ((zaddr_sync2-ram_low)>>1);\n          data <= 'hffff;\n          read_counter <= 0;\n          \n          slaven <= 1;\n          dataout_enable <= 1;\n          dataout <= 1;\n          \n          zorro_state <= WAIT_READ3;\n          \n        end else if (zorro_write && zaddr_in_ram) begin\n          // write RAM          \n          last_addr <= ((zaddr_sync2-ram_low)>>1); // z2_mapped_addr\n          zorro_state <= WAIT_WRITE;\n          \n        end else if (zorro_write && zaddr_in_reg) begin\n          // write to register\n          zaddr_regpart <= z2_mapped_addr[15:0];\n          zorro_state <= WAIT_REGWRITE;\n          \n        end else if (zorro_read && zaddr_in_reg) begin\n          // read from registers\n          \n          dataout_enable <= 1;\n          dataout <= 1;\n          slaven <= 1;\n          \n          case (zaddr_sync2[7:0])\n            //'h00: data <= REVISION;\n            'h20: data <= blitter_x1;\n            'h22: data <= blitter_y1;\n            'h24: data <= blitter_x2;\n            'h26: data <= blitter_y2;\n            'h28: data <= blitter_rgb;\n            'h2a: data <= blitter_enable;\n            \n            'h60: data <= {sd_busy,8'h00};\n            'h62: data <= {sd_read,8'h00};\n            'h64: data <= {sd_write,8'h00};\n            'h66: data <= {sd_handshake_out,8'h00};\n            'h68: data <= sd_addr_in[31:16];\n            'h6a: data <= sd_addr_in[15:0];\n            'h6c: data <= {sd_data_in,8'h00};\n            'h6e: data <= {sd_data_out,8'h00};\n            'h70: data <= sd_error;\n            //'h72: data <= sd_clkdiv;\n            \n            default: data <= REVISION; //'h0000;\n          endcase\n        end        \n      end else begin\n        dataout <= 0;\n        dataout_enable <= 0;\n        slaven <= 0;\n        write_stall <= 0;\n        z_ready <= 1; // clear XRDY (cpu wait)\n      end\n    end\n    \n    WAIT_REGWRITE: begin\n      if (datastrobe_synced) begin\n        regdata_in <= zdata_in_sync;\n        zaddr_regpart <= zaddr_sync2[15:0];\n        zorro_state <= REGWRITE;\n      end\n    end\n    \n    // ----------------------------------------------------------------------------------\n    WAIT_READ3: begin\n      z_ready <= 0;\n      if (!zorro_ram_read_request) begin\n        zorro_ram_read_addr <= last_addr;\n        zorro_ram_read_request <= 1;\n        zorro_ram_read_done <= 0;\n        zorro_state <= WAIT_READ2;\n      end\n    end\n    \n    WAIT_READ2: begin\n      /*if (znAS_sync[1]==1 && znAS_sync[0]==1) begin\n        // ram too slow TODO: report this\n        zorro_ram_read_request <= 0;\n        zorro_state <= Z2_IDLE;\n        z_ready <= 1;\n      end else */\n      \n      if (zorro_ram_read_done) begin\n        data <= zorro_ram_read_data;\n        read_counter <= read_counter + 1;\n        zorro_ram_read_request <= 0;\n        \n        if (read_counter >= dataout_time) begin\n          zorro_state <= WAIT_READ;\n        end\n      end\n    end\n  \n    // ----------------------------------------------------------------------------------\n    WAIT_READ: begin\n      //data <= zorro_ram_read_data;\n      z_ready <= 1;\n      if (znAS_sync[1]==1 && znAS_sync[0]==1) begin\n        zorro_state <= Z2_IDLE;\n      end\n    end\n   \n    // ----------------------------------------------------------------------------------\n    WAIT_WRITE:\n      if (!zorro_ram_write_request) begin\n        z_ready <= 1;\n        write_stall <= 0;\n        if (datastrobe_synced) begin // && zdata_in_sync==data_in\n          zorro_ram_write_addr <= last_addr;\n          zorro_ram_write_bytes <= {~znUDS_sync[2],~znLDS_sync[2]};\n          zorro_ram_write_data <= zdata_in_sync;\n          zorro_ram_write_request <= 1;\n          \n          zorro_state <= WAIT_WRITE2;\n        end\n      end else begin\n        z_ready <= 0;\n        write_stall <= 1;\n      end\n    \n    // ----------------------------------------------------------------------------------\n    WAIT_WRITE2: begin\n      z_ready <= 1;\n      if (znAS_sync[1]==1 && znAS_sync[0]==1) begin\n        zorro_state <= Z2_IDLE;\n      end\n    end\n    \n    RESET_DVID: begin\n      /*ram_arbiter_state <= RAM_READY;\n      zorro_ram_write_request <= 0;\n      zorro_ram_read_request <= 0;\n      zorro_ram_read_done <= 1;\n      fetch_line_y <= 0;\n      fetch_x <= 0;\n      row_fetched <= 1;*/\n      \n      if (dvid_reset_counter==0) begin\n        dvid_reset <= 0;\n        if (ZORRO3)\n          zorro_state <= Z3_IDLE;\n        else\n          zorro_state <= Z2_IDLE;\n      end else\n        dvid_reset_counter <= dvid_reset_counter - 1'b1;\n    end\n    \n    // ----------------------------------------------------------------------------------\n    // ----------------------------------------------------------------------------------\n    Z3_IDLE: begin\n      if (dvid_reset) begin\n        dvid_reset_counter <= 2;\n        zorro_state <= RESET_DVID;\n      end else\n      if (znFCS_sync[2]==0) begin\n        // falling edge of /FCS\n        if (z3addr_in_ram && zorro_write) begin\n          slaven <= 1;\n          if ((znUDS_sync[2]==0) || (znLDS_sync[2]==0) || (znDS1_sync[2]==0) || (znDS0_sync[2]==0)) begin\n            zorro_state <= Z3_WRITE_UPPER;\n          end\n        end else if (z3addr_in_ram && zorro_read) begin\n          // read from memory\n          slaven <= 1;\n          zorro_state <= Z3_READ_UPPER;\n        end else if (zorro_write && z3addr_in_reg) begin\n          // write to register\n          slaven <= 1;\n          if (znDS1_sync[2]==0) begin\n            regdata_in <= data_in_z3_low16;\n            zaddr_regpart <= (z3addr[15:0])|16'h2;\n            zorro_state <= REGWRITE;\n          end else if (znUDS_sync[2]==0) begin\n            regdata_in <= zdata_in_sync;\n            zaddr_regpart <= z3addr[15:0];\n            zorro_state <= REGWRITE;\n          end\n        end else if (zorro_read && z3addr_in_reg) begin\n          // read registers\n          slaven <= 1;\n          data_z3_hi16 <= 0;\n          data_z3_low16 <= 0;\n          \n          if (znDS1_sync[2]==0 || znDS0_sync[2]==0 || znUDS_sync[2]==0 || znLDS_sync[2]==0) begin\n            zaddr_regpart <= {z3addr[15:2],2'b00}; //|16'h2;\n            zorro_state <= REGREAD;\n          end\n        end else begin\n          // address not recognized\n          slaven <= 0;\n          //dtack <= 0;\n          //dataout_enable <= 0;\n          //dataout_z3 <= 0;\n        end\n        \n      end else begin\n        // not in a cycle\n        slaven <= 0;\n        //dtack <= 0;\n        //dataout_enable <= 0;\n        //dataout_z3 <= 0;\n      end\n    end\n    \n    Z3_READ_UPPER: begin\n      if (!zorro_ram_read_request) begin\n        z3_read_addr <= z3_mapped_addr;\n        zorro_state <= Z3_READ_LOWER;\n        zorro_ram_read_addr <= z3_mapped_addr[23:0];\n        zorro_ram_read_bytes <= 2'b11;\n        zorro_ram_read_request <= 1;\n        zorro_ram_read_done <= 0;\n      end\n    end\n    \n    // FIXME looks racy\n    Z3_READ_LOWER: begin\n      if (zorro_ram_read_done) begin\n        zorro_ram_read_addr <= (z3_read_addr[23:0])|24'b1;\n        zorro_ram_read_bytes <= 2'b11;\n        zorro_ram_read_request <= 1;\n        zorro_ram_read_done <= 0;\n        z3_read_data <= zorro_ram_read_data;\n        zorro_state <= Z3_READ_DELAY;\n      end\n    end\n    \n    Z3_READ_DELAY: begin\n      if (zorro_ram_read_done) begin\n        data_z3_hi16 <= z3_read_data;\n        data_z3_low16 <= zorro_ram_read_data;\n        dataout_enable <= 1;\n        dataout_z3 <= 1;\n        zorro_ram_read_done <= 0;\n        zorro_state <= Z3_ENDCYCLE;\n      end\n    end\n    \n    Z3_WRITE_UPPER: begin\n      // wait for free memory bus\n      if ((znUDS_sync[2]==0) || (znLDS_sync[2]==0)) begin\n        if (!zorro_ram_write_request) begin\n          zorro_ram_write_addr <= z3_mapped_addr[23:0];\n          zorro_ram_write_bytes <= ~{znUDS_sync[2],znLDS_sync[2]};\n          zorro_ram_write_data <= z3_din_high_s2;\n          zorro_ram_write_request <= 1;\n          zorro_state <= Z3_WRITE_LOWER;\n        end\n      end else begin\n        // only lower bytes shall be written\n        zorro_state <= Z3_WRITE_LOWER;\n      end\n    end\n    \n    Z3_WRITE_LOWER: begin\n      if ((znDS1_sync[2]==0) || (znDS0_sync[2]==0)) begin\n        if (!zorro_ram_write_request) begin\n          zorro_ram_write_addr <= (z3_mapped_addr[23:0])|1'b1;\n          zorro_ram_write_bytes <= ~{znDS1_sync[2],znDS0_sync[2]};\n          zorro_ram_write_data <= z3_din_low_s2; // low!\n          zorro_ram_write_request <= 1;\n          \n          zorro_state <= Z3_ENDCYCLE;\n        end\n      end else begin\n        zorro_state <= Z3_ENDCYCLE;\n      end\n    end\n    \n    Z3_ENDCYCLE: begin\n      if (znFCS_sync[2]==1) begin\n        dtack <= 0;\n        slaven <= 0;\n        dataout_enable <= 0;\n        dataout_z3 <= 0;\n        zorro_state <= Z3_IDLE;\n      end else\n        dtack <= 1;\n    end\n    \n    REGREAD_POST: begin\n      data_z3_hi16 <= z3_regread_hi;\n      data_z3_low16 <= z3_regread_lo;\n      zorro_state <= Z3_ENDCYCLE;\n    end\n    \n    REGREAD: begin\n      dataout_enable <= 1;\n      dataout_z3 <= 1;\n      zorro_state <= REGREAD_POST;\n      \n      case (zaddr_regpart)\n        /*'h00: begin z3_regread_hi <= REVISION;\n              z3_regread_lo <= 0; end*/\n        'h20: begin z3_regread_hi <= blitter_x1;\n              z3_regread_lo <= blitter_y1; end // 'h22\n              \n        'h24: begin z3_regread_hi <= blitter_x2;\n              z3_regread_lo <= blitter_y2; end // 'h26\n              \n        'h28: begin z3_regread_hi <= blitter_rgb;\n              z3_regread_lo <= blitter_enable; end // 'h2a\n        \n        'h60: begin z3_regread_hi <= {sd_busy,8'h00};\n              z3_regread_lo <= {sd_read,8'h00}; end // 'h62\n        'h64: begin z3_regread_hi <= {sd_write,8'h00};\n              z3_regread_lo <= {sd_handshake_out,8'h00}; end // 'h66\n        'h68: begin z3_regread_hi <= sd_addr_in[31:16];\n              z3_regread_lo <= sd_addr_in[15:0]; end // 'h6a\n        'h6c: begin z3_regread_hi <= {sd_data_in,8'h00};\n              z3_regread_lo <= {sd_data_out,8'h00}; end // 'h6e\n        \n        'h70: begin z3_regread_hi <= sd_error; z3_regread_lo <= 0; end\n        /*'h72: data_z3_low16 <= sd_clkdiv;*/\n        \n        'h80: begin z3_regread_hi <= ram_arbiter_state; z3_regread_lo <= zorro_state; end\n        'h84: begin z3_regread_hi <= counter_x; z3_regread_lo <= counter_y; end\n        'h88: begin z3_regread_hi <= h_max; z3_regread_lo <= v_max; end\n        'h8c: begin z3_regread_hi <= fetch_x; z3_regread_lo <= 0; end\n        'h90: begin z3_regread_hi <= fetch_y[23:16]; z3_regread_lo <= fetch_y[15:0]; end\n        'h94: begin z3_regread_hi <= data_out_ready; z3_regread_lo <= ram_enable; end\n        'h98: begin z3_regread_hi <= ram_write; z3_regread_lo <= 0; end\n        \n        default: begin\n          z3_regread_hi <= REVISION; //'h0000; \n          z3_regread_lo <= 'h0000;\n        end\n      endcase\n    end\n    \n    REGWRITE: begin\n      if (ZORRO3) begin\n        zorro_state <= Z3_ENDCYCLE;\n      end else\n        zorro_state <= Z2_IDLE;\n      \n      if (zaddr_regpart>='h600) begin\n        palette_r[zaddr_regpart[8:1]] <= regdata_in[7:0];\n      end else if (zaddr_regpart>='h400) begin\n        palette_g[zaddr_regpart[8:1]] <= regdata_in[7:0];\n      end else if (zaddr_regpart>='h200) begin\n        palette_b[zaddr_regpart[8:1]] <= regdata_in[7:0];\n      end else\n      case (zaddr_regpart)\n        'h02: screen_w <= regdata_in[11:0];\n        'h04: scalemode <= regdata_in[1:0];\n        'h06: begin\n          screen_w <= regdata_in[11:0];\n          h_rez    <= regdata_in[11:0];\n        end\n        'h08: begin\n          screen_h <= regdata_in[11:0];\n          v_rez    <= regdata_in[11:0];\n        end\n        'h82: refresh_time <= regdata_in[15:0];\n        \n        'h70: h_sync_start <= regdata_in[11:0];\n        'h72: h_sync_end <= regdata_in[11:0];\n        'h74: h_max <= regdata_in[11:0];\n        'h76: v_sync_start <= regdata_in[11:0];\n        'h78: v_sync_end <= regdata_in[11:0];\n        'h7a: v_max <= regdata_in[11:0];\n        'h7c: begin \n          vga_clk_sel <= regdata_in[1:0];\n          dvid_reset <= 1;\n        end\n        \n        //'h0a: dataout_time <= regdata_in[7:0];\n        'h0c: margin_x <= regdata_in[9:0];\n        'h10: preheat_x <= regdata_in[4:0];\n        //'h12: safe_x1 <= regdata_in[10:0];\n        'h14: safe_x2 <= regdata_in[10:0];\n        /*'h16: glitchx2_reg <= regdata_in[10:0];\n        'h18: ram_burst_col <= regdata_in[8:0];*/\n        'h1a: fetch_preroll <= regdata_in[10:0];\n        \n        // blitter regs\n        'h1c: blitter_base[23:16] <= regdata_in[7:0];\n        'h1e: blitter_base[15:0]  <= regdata_in;\n        'h20: blitter_x1 <= regdata_in[11:0];\n        'h22: blitter_y1 <= regdata_in[11:0];\n        'h24: blitter_x2 <= regdata_in[11:0];\n        'h26: blitter_y2 <= regdata_in[11:0];\n        'h28: blitter_rgb <= regdata_in[15:0];\n        'h2a: begin\n          blitter_enable <= regdata_in[3:0];\n          \n          blitter_curx <= blitter_x1;\n          blitter_cury <= blitter_y1;\n          blitter_curx2 <= blitter_x3;\n          blitter_cury2 <= blitter_y3;\n          \n          blitter_dirx <= (blitter_x3>blitter_x4)?1'b1:1'b0;\n          blitter_diry <= (blitter_y3>blitter_y4)?1'b1:1'b0;\n          \n          blitter_ptr <= blitter_base + (blitter_y1 << row_pitch_shift);\n          blitter_ptr2 <= blitter_base + (blitter_y3 << row_pitch_shift);\n          blitter_rgb32_t <= 1;\n        end\n        'h2c: blitter_x3 <= regdata_in[11:0];\n        'h2e: blitter_y3 <= regdata_in[11:0];\n        'h30: blitter_x4 <= regdata_in[11:0];\n        'h32: blitter_y4 <= regdata_in[11:0];\n        'h34: blitter_rgb32[0] <= regdata_in[15:0];\n        'h36: blitter_rgb32[1] <= regdata_in[15:0];\n        \n        'h38: pan_ptr[23:16] <= regdata_in[7:0];\n        'h3a: pan_ptr[15:0]  <= regdata_in;\n        \n        /*'h40: sprite_ax <= regdata_in[10:0];\n        'h42: sprite_ay <= regdata_in[10:0];\n        'h44: sprite_ax2 <= regdata_in[10:0];\n        'h46: sprite_ay2 <= regdata_in[10:0];*/\n        \n        'h48: colormode <= regdata_in[2:0];\n        \n        //'h50: capture_mode <= regdata_in[0];\n        //'h52: capture_freq <= regdata_in[5:0];\n        //'h54: capture_porch <= regdata_in[7:0];\n        //'h56: capture_shift <= regdata_in[9:0];\n        \n        'h58: row_pitch <= regdata_in;\n        //'h5a: burst_enabled <= regdata_in[0];\n        'h5c: row_pitch_shift <= regdata_in[4:0];\n        \n        // sd card regs\n        'h60: sd_reset <= regdata_in[8];\n        'h62: sd_read <= regdata_in[8];\n        'h64: sd_write <= regdata_in[8];\n        'h66: sd_handshake_in <= regdata_in[8];\n        'h68: sd_addr_in[31:16] <= regdata_in[15:0];\n        'h6a: sd_addr_in[15:0] <= regdata_in[15:0];\n        'h6c: sd_data_in <= regdata_in[15:8];\n        \n        'h80: ram_arbiter_state <= regdata_in[4:0];\n      endcase\n    end\n    \n    default:\n      // shouldn't happen\n      zorro_state <= CONFIGURED;\n\n  endcase\n\n// =================================================================================\n// RAM ARBITER\n\n  case (ram_arbiter_state)\n    RAM_READY: begin\n      ram_enable <= 1;\n      //ram_write <= 0;\n      ram_arbiter_state <= RAM_READY2;\n      fetch_y <= pan_ptr + (fetch_line_y << row_pitch_shift);\n    end\n    \n    RAM_READY2: begin\n      // start fetching a row\n      ram_addr  <= fetch_y+glitchx2_reg;\n      ram_write <= 0;\n      ram_byte_enable <= 'b11;\n      //ram_enable <= 1;\n      fetch_x <= 0;\n      fetch_x2 <= glitchx2_reg;\n      \n      if (row_fetched) begin\n        ram_burst <= 0;\n        ram_arbiter_state <= RAM_BURST_OFF;\n      end else begin\n        ram_burst <= 1;\n        ram_arbiter_state <= RAM_BURST_ON;\n      end\n    end\n    \n    RAM_BURST_ON: begin\n      //ram_enable <= 1;\n      //ram_write <= 0;\n      if (cmd_ready) ram_arbiter_state <= RAM_FETCHING_ROW8;\n    end\n    \n    RAM_FETCHING_ROW8: begin\n      //ram_enable <= 1;\n      //ram_write <= 0;\n      if ((fetch_x >= (screen_w + margin_x))) begin\n        row_fetched <= 1; // row completely fetched\n        ram_burst <= 0;\n        ram_arbiter_state <= RAM_READY;\n        \n      end else if (data_out_ready) begin\n        ram_enable <= 1;\n        ram_write <= 0;\n        ram_byte_enable <= 'b11;\n        ram_addr  <= ram_addr + 1'b1; // burst incremented\n      \n        fetch_x <= fetch_x + 1'b1;\n        fetch_x2 <= fetch_x2 + 1'b1;\n        \n        fetch_buffer[fetch_x] <= ram_data_out;\n      end\n    end\n    \n    RAM_BURST_OFF: begin\n      ram_enable <= 0;\n      if (data_out_queue_empty && cmd_ready)\n        ram_arbiter_state <= RAM_ROW_FETCHED;\n    end\n    \n    RAM_ROW_FETCHED:\n      if ((need_row_fetch_y!=fetch_line_y) && (counter_x > h_max-safe_x2)) begin\n        row_fetched <= 0;\n        fetch_x <= 0;\n        fetch_line_y <= need_row_fetch_y;\n        //linescalecount <= 0;\n        ram_arbiter_state <= RAM_READY;\n        \n      // FIXME need better solution, this causes total lockup and slowness\n      end else if (counter_x > h_max-safe_x2) begin\n        // do nothing if not in safe area\n        \n      // BLITTER ----------------------------------------------------------------\n      /*end else if (blitter_enable==1 && cmd_ready) begin\n        if (colormode==2) begin\n          blitter_rgb <= blitter_rgb32[blitter_rgb32_t];\n        end\n        blitter_rgb32_t <= ~blitter_rgb32_t;\n        \n        // rect fill blitter\n        if (blitter_curx <= blitter_x2) begin\n          blitter_curx <= blitter_curx + 1'b1;\n          ram_byte_enable <= 'b11;\n          ram_addr    <= blitter_ptr + blitter_curx;          \n          ram_data_in <= blitter_rgb;\n          ram_write   <= 1;\n          ram_enable  <= 1;\n        end else if (blitter_cury<blitter_y2) begin\n          blitter_cury <= blitter_cury + 1'b1;\n          blitter_curx <= blitter_x1;\n          blitter_ptr <= blitter_ptr + row_pitch;\n        end else begin\n          blitter_curx <= 0;\n          blitter_cury <= 0;\n          blitter_enable <= 0;\n          //ram_enable <= 0;\n        end*/\n      /*end else if (blitter_enable==2 && cmd_ready) begin\n        // block copy read\n        if (data_out_queue_empty) begin\n          ram_byte_enable <= 'b11;\n          ram_addr    <= blitter_ptr2+blitter_curx2;\n          ram_write   <= 0;\n          ram_enable  <= 1;\n          ram_arbiter_state <= RAM_READING_BLIT;\n        end else \n          ram_enable <= 0;\n        \n      end else if (blitter_enable==4 && cmd_ready) begin\n        // block copy write\n        ram_addr    <= blitter_ptr+blitter_curx;\n        ram_data_in <= blitter_copy_rgb;\n        ram_write   <= 1;\n        ram_enable  <= 1;\n        ram_byte_enable <= 'b11;\n        \n        if (blitter_curx2 != blitter_x4) begin\n          if (blitter_dirx==1) begin\n            blitter_curx2 <= blitter_curx2 - 1'b1;\n            blitter_curx  <= blitter_curx - 1'b1;\n          end else begin\n            blitter_curx2 <= blitter_curx2 + 1'b1;\n            blitter_curx  <= blitter_curx + 1'b1;\n          end\n        end else if (blitter_cury2 == blitter_y4) begin\n          // done\n        end else if (blitter_diry == 0) begin\n          blitter_curx <= blitter_x1;\n          blitter_curx2 <= blitter_x3;\n          blitter_ptr <= blitter_ptr + row_pitch;\n          blitter_ptr2 <= blitter_ptr2 + row_pitch;\n          blitter_cury <= blitter_cury + 1'b1;\n          blitter_cury2 <= blitter_cury2 + 1'b1;\n        end else begin\n          blitter_curx <= blitter_x1;\n          blitter_curx2 <= blitter_x3;\n          blitter_ptr <= blitter_ptr - row_pitch;\n          blitter_ptr2 <= blitter_ptr2 - row_pitch;\n          blitter_cury <= blitter_cury - 1'b1;\n          blitter_cury2 <= blitter_cury2 - 1'b1;\n        end\n        \n        blitter_enable <= 5; // next\n      end else if (blitter_enable==5) begin\n        if (blitter_curx2==blitter_x4 && blitter_cury2 == blitter_y4)\n          blitter_enable <= 0;\n        else\n          blitter_enable <= 2;\n        ram_enable <= 0;\n        */\n      // ZORRO READ/WRITE ----------------------------------------------\n      end else if (/*blitter_enable==0 &&*/ zorro_ram_read_request && cmd_ready) begin\n        // process read request\n        zorro_ram_read_done <= 0;\n        if (data_out_queue_empty) begin\n          ram_arbiter_state <= RAM_READING_ZORRO_PRE;\n        end else \n          ram_enable <= 0;\n      end else if (/*blitter_enable==0 &&*/ zorro_ram_write_request && cmd_ready) begin\n        // process write request\n        ram_arbiter_state <= RAM_WRITING_ZORRO_PRE;\n      end else if (/*blitter_enable==0 &&*/ refresh_counter>refresh_time && !zorro_ram_read_request && !zorro_ram_write_request && cmd_ready) begin\n        ram_arbiter_state <= RAM_REFRESH_PRE;\n      end else if (blitter_enable) begin\n        blitter_enable <= 0;\n      end else\n        refresh_counter <= refresh_counter + 1;\n    \n    RAM_REFRESH_PRE: begin\n      if (data_out_queue_empty) begin\n        ram_write <= 0;\n        ram_addr <= refresh_addr;\n        ram_byte_enable <= 'b11;\n        refresh_addr <= refresh_addr + 512;\n        ram_enable <= 1;\n        ram_arbiter_state <= RAM_REFRESH;\n        refresh_counter <= 0;\n      end else \n        ram_enable <= 0;\n    end\n    \n    RAM_REFRESH: begin\n      if (data_out_ready) begin\n        ram_enable <= 0;\n        ram_arbiter_state <= RAM_ROW_FETCHED;\n      end\n    end\n    \n    RAM_READING_BLIT: begin\n      // block copy (data ready)\n      if (data_out_ready) begin\n        ram_enable <= 0;\n        blitter_copy_rgb <= ram_data_out;\n        blitter_enable <= 4;\n        ram_arbiter_state <= RAM_ROW_FETCHED;\n      end\n    end\n    \n    RAM_READING_ZORRO_PRE: begin\n      ram_write <= 0;\n      ram_addr <= zorro_ram_read_addr;\n      ram_byte_enable <= 'b11;\n      ram_enable <= 1;\n      ram_arbiter_state <= RAM_READING_ZORRO;\n    end\n    \n    RAM_READING_ZORRO: begin\n      if (data_out_ready) begin\n        ram_enable <= 0;\n        zorro_ram_read_data <= ram_data_out;\n        zorro_ram_read_done <= 1;\n        zorro_ram_read_request <= 0;\n        ram_arbiter_state <= RAM_ROW_FETCHED;\n      end/* else begin // FIXME\n        ram_enable <= 1;\n        ram_write <= 0;\n      end*/\n    end\n    \n    RAM_WRITING_ZORRO_PRE: begin\n      if (zorro_ram_write_bytes[1] && !zorro_ram_write_bytes[0])\n        ram_byte_enable <= 'b10; // UDS\n      else if (zorro_ram_write_bytes[0] && !zorro_ram_write_bytes[1])\n        ram_byte_enable <= 'b01; // LDS\n      else\n        ram_byte_enable <= 'b11;\n      \n      ram_data_in <= zorro_ram_write_data;\n      ram_addr    <= zorro_ram_write_addr;\n      ram_write   <= 1;\n      ram_enable  <= 1;\n      \n      ram_arbiter_state <= RAM_WRITING_ZORRO;\n    end\n    \n    RAM_WRITING_ZORRO: begin\n      zorro_ram_write_done <= 1;\n      zorro_ram_write_request <= 0;\n        \n      ram_enable <= 0;\n      ram_arbiter_state <= RAM_ROW_FETCHED;\n    end\n    \n    default:\n      // should also never happen\n      ram_arbiter_state <= RAM_READY;\n    \n  endcase\nend\n\nreg[23:0] rgb = 'h000000;\nreg[31:0] rgb32 = 'h00000000;\nreg[11:0] counter_8x = 0;\nreg counter_x_hi = 0;\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[1052, "      /*ram_arbiter_state <= RAM_READY;\n"], [1053, "      zorro_ram_write_request <= 0;\n"], [1054, "      zorro_ram_read_request <= 0;\n"], [1055, "      zorro_ram_read_done <= 1;\n"], [1056, "      fetch_line_y <= 0;\n"], [1057, "      fetch_x <= 0;\n"], [1058, "      row_fetched <= 1;*/\n"], [1442, "      /*end else if (blitter_enable==1 && cmd_ready) begin\n"], [1465, "        end*/\n"], [1532, "      end else if (blitter_enable) begin\n"], [1533, "        blitter_enable <= 0;\n"]], "Add": [[1442, "      end else if (blitter_enable==1 && cmd_ready) begin\n"], [1465, "        end\n"], [1533, "      /*end else if (blitter_enable) begin\n"], [1533, "        blitter_enable <= 0;*/\n"]]}}