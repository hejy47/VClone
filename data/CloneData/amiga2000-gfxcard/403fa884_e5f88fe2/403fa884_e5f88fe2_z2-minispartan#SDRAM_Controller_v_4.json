{"Source Block": ["amiga2000-gfxcard/z2-minispartan/SDRAM_Controller_v.v@236:526@HdlStmProcess", "      );\n   end \n     \nalways  @ (posedge clk ) captured_data      <= sdram_din;\n\nalways  @ (posedge clk )\n   begin\n      //captured_data_last <= captured_data;\n      \n      //------------------------------------------------\n      //-- Default state is to do nothing\n      //------------------------------------------------\n      iob_command     <= CMD_NOP;\n      iob_address     <= 13'b0000000000000;\n      iob_bank        <= 2'b00;\n\n      //------------------------------------------------\n      //-- countdown for initialisation & refresh\n      //------------------------------------------------\n      startup_refresh_count <= startup_refresh_count+1;\n                  \n      //-------------------------------------------------------------------\n      //-- It we are ready for a new tranasction and one is being presented\n      //-- then accept it. Also remember what we are reading or writing,\n      //-- and if it can be back-to-backed with the last transaction\n      //-------------------------------------------------------------------\n      if (ready_for_new == 1'b1 && cmd_enable == 1'b1) begin\n         //$display(\"%h r: %h c: %h\",cmd_address,addr_row,addr_col);\n         \n         if(save_bank == addr_bank && save_row == addr_row) \n            can_back_to_back <= 1'b1;\n         else\n            can_back_to_back <= 1'b0;\n\n         save_row         <= addr_row;\n         save_bank        <= addr_bank;\n         save_col         <= addr_col;\n         save_wr          <= cmd_wr; \n         save_data_in     <= cmd_data_in;\n         save_byte_enable <= cmd_byte_enable;\n         got_transaction  <= 1'b1;\n         ready_for_new    <= 1'b0;\n      end\n\n      //------------------------------------------------\n      //-- Handle the data coming back from the \n      //-- SDRAM for the Read transaction\n      //------------------------------------------------\n      data_out_ready_reg <= 1'b0;\n      if (data_ready_delay[0] == 1'b1) begin\n         data_out_reg       <= {captured_data, captured_data};\n         data_out_ready_reg <= 1'b1;\n      end\n         \n      //----------------------------------------------------------------------------\n      //-- update shift registers used to choose when to present data to/from memory\n      //----------------------------------------------------------------------------\n      data_ready_delay <= {1'b0, data_ready_delay[data_ready_delay_high:1]};\n      //iob_dqm       <= dqm_sr[1:0];\n      //dqm_sr        <= {2'b11, dqm_sr[dqm_sr_high:2]};\n         \n      case(state) \n         s_startup: begin\n               //------------------------------------------------------------------------\n               //-- This is the initial startup state, where we wait for at least 100us\n               //-- before starting the start sequence\n               //-- \n               //-- The initialisation is sequence is \n               //--  * de-assert SDRAM_CKE\n               //--  * 100us wait, \n               //--  * assert SDRAM_CKE\n               //--  * wait at least one cycle, \n               //--  * PRECHARGE\n               //--  * wait 2 cycles\n               //--  * REFRESH, \n               //--  * tREF wait\n               //--  * REFRESH, \n               //--  * tREF wait \n               //--  * LOAD_MODE_REG \n               //--  * 2 cycles wait\n               //------------------------------------------------------------------------\n               iob_cke <= 1'b1;\n               \n               // All the commands during the startup are NOPS, except these\n               if(startup_refresh_count == startup_refresh_max-31) begin\n                  // ensure all rows are closed\n                  iob_command     <= CMD_PRECHARGE;\n                  iob_address[prefresh_cmd] <= 1'b1;  // all banks\n                  iob_bank        <= 2'b00;\n               end\n               else if (startup_refresh_count == startup_refresh_max-23) begin\n                  // these refreshes need to be at least tREF (66ns) apart\n                  iob_command     <= CMD_REFRESH;\n               end else if (startup_refresh_count == startup_refresh_max-15) \n                  iob_command     <= CMD_REFRESH;\n               else if (startup_refresh_count == startup_refresh_max-7) begin\n                  // Now load the mode register\n                  iob_command     <= CMD_LOAD_MODE_REG;\n                  iob_address     <= MODE_REG;\n               end\n\n               //------------------------------------------------------\n               //-- if startup is complete then go into idle mode,\n               //-- get prepared to accept a new command, and schedule\n               //-- the first refresh cycle\n               //------------------------------------------------------\n               if (startup_refresh_count == 1'b0) begin\n                  state           <= s_idle;\n                  ready_for_new   <= 1'b1;\n                  got_transaction <= 1'b0;\n                  startup_refresh_count <= 2048 - cycles_per_refresh+1;\n               end\n            end\n         s_idle_in_6: state <= s_idle_in_5;\n         s_idle_in_5: state <= s_idle_in_4;\n         s_idle_in_4: state <= s_idle_in_3;\n         s_idle_in_3: state <= s_idle_in_2;\n         s_idle_in_2: state <= s_idle_in_1;\n         s_idle_in_1: state <= s_idle;\n\n         s_idle: begin\n               // Priority is to issue a refresh if one is outstanding\n               if (pending_refresh == 1'b1 || forcing_refresh == 1'b1) begin\n                  //------------------------------------------------------------------------\n                  //-- Start the refresh cycle. \n                  //-- This tasks tRFC (66ns), so 6 idle cycles are needed @ 100MHz\n                  //------------------------------------------------------------------------\n                  state       <= s_idle_in_6;\n                  iob_command <= CMD_REFRESH;\n                  startup_refresh_count <= startup_refresh_count - cycles_per_refresh+1;\n               end\n               else if (got_transaction == 1'b1) begin\n                  //--------------------------------\n                  //-- Start the read or write cycle. \n                  //-- First task is to open the row\n                  //--------------------------------\n                  state       <= s_open_in_2;\n                  iob_command <= CMD_ACTIVE;\n                  iob_address <= save_row;\n                  iob_bank    <= save_bank;\n               end               \n            end\n         //--------------------------------------------\n         //-- Opening the row ready for reads or writes\n         //--------------------------------------------\n         s_open_in_2: state <= s_open_in_1;\n\n         s_open_in_1: begin \n               // still waiting for row to open\n               if(save_wr == 1'b1) begin\n                  state       <= s_write_1;\n                  iob_dq_hiz  <= 1'b0;\n                  iob_data    <= save_data_in[15:0]; // get the DQ bus out of HiZ early\n               end else begin\n                  iob_dq_hiz  <= 1'b1;\n                  state       <= s_read_1;\n               end\n               // we will be ready for a new transaction next cycle!\n               ready_for_new   <= 1'b1; \n               got_transaction <= 1'b0;                  \n            end\n         //----------------------------------\n         //-- Processing the read transaction\n         //----------------------------------\n         s_read_1: begin\n               state           <= s_read_2;\n               iob_command     <= CMD_READ;\n               iob_address     <= save_col; \n               iob_bank        <= save_bank;\n               iob_address[prefresh_cmd] <= 1'b0; // A10 actually matters - it selects auto precharge\n               \n               // Schedule reading the data values off the bus\n               data_ready_delay[data_ready_delay_high]   <= 1'b1;\n               \n               // Set the data masks to read all bytes\n               iob_dqm     <= 2'b00;\n               //dqm_sr[1:0] <= 2'b00;\n            end   \n         s_read_2: begin\n               state <= s_read_3;\n               if (forcing_refresh == 1'b0 && got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n                  if (save_wr == 1'b0) begin \n                     state           <= s_read_1;\n                     ready_for_new   <= 1'b1; // we will be ready for a new transaction next cycle!\n                     got_transaction <= 1'b0;\n                  end\n               end\n            end   \n         s_read_3: begin\n               state <= s_read_4;\n               if (forcing_refresh == 1'b0 && got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n                  if (save_wr == 1'b0) begin\n                     state           <= s_read_1;\n                     ready_for_new   <= 1'b1; // we will be ready for a new transaction next cycle!\n                     got_transaction <= 1'b0;\n                  end\n               end\n            end\n\n         s_read_4: begin\n               state <= s_precharge;\n               //-- can we do back-to-back read?\n               if (forcing_refresh == 1'b0 && got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n                  if (save_wr == 1'b0) begin \n                     state           <= s_read_1;\n                     ready_for_new   <= 1'b1; // we will be ready for a new transaction next cycle!\n                     got_transaction <= 1'b0;\n                  end\n                  else\n                     state <= s_open_in_2; // we have to wait for the read data to come back before we switch the bus into HiZ\n               end\n            end\n         //------------------------------------------------------------------\n         // -- Processing the write transaction\n         //-------------------------------------------------------------------\n         s_write_1: begin\n               state                     <= s_write_2;\n               iob_command               <= CMD_WRITE;\n               iob_address               <= save_col; \n               iob_address[prefresh_cmd] <= 1'b0; // A10 actually matters - it selects auto precharge\n               iob_bank                  <= save_bank;\n               iob_dqm                   <= ~ save_byte_enable[1:0];    \n               //dqm_sr[1:0]               <= ~ save_byte_enable[3:2];    \n               iob_data                  <= save_data_in[15:0];\n               //iob_data_next             <= save_data_in[31:16];\n            end\n         s_write_2: begin\n            $display(\"w2 %h\\t%h\\t%h\", save_bank, save_row, iob_address);\n               state           <= s_write_3;\n               //iob_data        <= iob_data_next;\n               // can we do a back-to-back write?\n               if (forcing_refresh == 1'b0 && got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n                  if (save_wr == 1'b1) begin\n                     $display(\"back-to-back write\");\n                     \n                     // back-to-back write?\n                     state           <= s_write_1;\n                     ready_for_new   <= 1'b1;\n                     got_transaction <= 1'b0;\n                  end\n                  // Although it looks right in simulation you can't go write-to-read \n                  // here due to bus contention, as iob_dq_hiz takes a few ns.\n               end\n            end\n         s_write_3: begin\n               // must wait tRDL, hence the extra idle state\n               //-- back to back transaction?\n               if (forcing_refresh == 1'b0 && got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n                  if (save_wr == 1'b1) begin\n                     // back-to-back write?\n                     state           <= s_write_1;\n                     ready_for_new   <= 1'b1;\n                     got_transaction <= 1'b0;\n                  end\n                  else begin\n                     // write-to-read switch?\n                     state           <= s_read_1;\n                     iob_dq_hiz      <= 1'b1;\n                     ready_for_new   <= 1'b1; // we will be ready for a new transaction next cycle!\n                     got_transaction <= 1'b0;                  \n                  end \n               end else begin\n                  iob_dq_hiz         <= 1'b1;\n                  state              <= s_precharge;\n              end\n            end\n         //-------------------------------------------------------------------\n         //-- Closing the row off (this closes all banks)\n         //-------------------------------------------------------------------\n         s_precharge: begin\n               state                     <= s_idle_in_3;\n               iob_command               <= CMD_PRECHARGE;\n               iob_address[prefresh_cmd] <= 1'b1; // A10 actually matters - it selects all banks or just one\n            end\n         //-------------------------------------------------------------------\n         //-- We should never get here, but if we do then reset the memory\n         //-------------------------------------------------------------------\n         default: begin \n               state                 <= s_startup;\n               ready_for_new         <= 1'b0;\n               startup_refresh_count <= startup_refresh_max-sdram_startup_cycles;\n            end\n         endcase\n\n         if (reset == 1'b1) begin  // Sync reset\n            state                 <= s_startup;\n            ready_for_new         <= 1'b0;\n            startup_refresh_count <= startup_refresh_max-sdram_startup_cycles;\n         end\n      end      \nendmodule\n"], "Clone Blocks": [["amiga2000-gfxcard/attic/PapPro-sdram_verilog_v0.1/SDRAM_Controller_v.v@232:517", "      );\n   end \n     \nalways  @ (posedge clk ) captured_data      <= sdram_din;\n\nalways  @ (posedge clk )\n   begin\n      captured_data_last <= captured_data;\n      \n      //------------------------------------------------\n      //-- Default state is to do nothing\n      //------------------------------------------------\n      iob_command     <= CMD_NOP;\n      iob_address     <= 13'b0000000000000;\n      iob_bank        <= 2'b00;\n\n      //------------------------------------------------\n      //-- countdown for initialisation & refresh\n      //------------------------------------------------\n      startup_refresh_count <= startup_refresh_count+1;\n                  \n      //-------------------------------------------------------------------\n      //-- It we are ready for a new tranasction and one is being presented\n      //-- then accept it. Also remember what we are reading or writing,\n      //-- and if it can be back-to-backed with the last transaction\n      //-------------------------------------------------------------------\n      if (ready_for_new == 1'b1 && cmd_enable == 1'b1) begin\n         if(save_bank == addr_bank && save_row == addr_row) \n            can_back_to_back <= 1'b1;\n         else\n            can_back_to_back <= 1'b0;\n\n         save_row         <= addr_row;\n         save_bank        <= addr_bank;\n         save_col         <= addr_col;\n         save_wr          <= cmd_wr; \n         save_data_in     <= cmd_data_in;\n         save_byte_enable <= cmd_byte_enable;\n         got_transaction  <= 1'b1;\n         ready_for_new    <= 1'b0;\n      end\n\n      //------------------------------------------------\n      //-- Handle the data coming back from the \n      //-- SDRAM for the Read transaction\n      //------------------------------------------------\n      data_out_ready_reg <= 1'b0;\n      if (data_ready_delay[0] == 1'b1) begin\n         data_out_reg       <= {captured_data, captured_data_last};\n         data_out_ready_reg <= 1'b1;\n      end\n         \n      //----------------------------------------------------------------------------\n      //-- update shift registers used to choose when to present data to/from memory\n      //----------------------------------------------------------------------------\n      data_ready_delay <= {1'b0, data_ready_delay[data_ready_delay_high:1]};\n      iob_dqm       <= dqm_sr[1:0];\n      dqm_sr        <= {2'b11, dqm_sr[dqm_sr_high:2]};\n         \n      case(state) \n         s_startup: begin\n               //------------------------------------------------------------------------\n               //-- This is the initial startup state, where we wait for at least 100us\n               //-- before starting the start sequence\n               //-- \n               //-- The initialisation is sequence is \n               //--  * de-assert SDRAM_CKE\n               //--  * 100us wait, \n               //--  * assert SDRAM_CKE\n               //--  * wait at least one cycle, \n               //--  * PRECHARGE\n               //--  * wait 2 cycles\n               //--  * REFRESH, \n               //--  * tREF wait\n               //--  * REFRESH, \n               //--  * tREF wait \n               //--  * LOAD_MODE_REG \n               //--  * 2 cycles wait\n               //------------------------------------------------------------------------\n               iob_cke <= 1'b1;\n               \n               // All the commands during the startup are NOPS, except these\n               if(startup_refresh_count == startup_refresh_max-31) begin\n                  // ensure all rows are closed\n                  iob_command     <= CMD_PRECHARGE;\n                  iob_address[prefresh_cmd] <= 1'b1;  // all banks\n                  iob_bank        <= 2'b00;\n               end\n               else if (startup_refresh_count == startup_refresh_max-23) begin\n                  // these refreshes need to be at least tREF (66ns) apart\n                  iob_command     <= CMD_REFRESH;\n               end else if (startup_refresh_count == startup_refresh_max-15) \n                  iob_command     <= CMD_REFRESH;\n               else if (startup_refresh_count == startup_refresh_max-7) begin\n                  // Now load the mode register\n                  iob_command     <= CMD_LOAD_MODE_REG;\n                  iob_address     <= MODE_REG;\n               end\n\n               //------------------------------------------------------\n               //-- if startup is coomplete then go into idle mode,\n               //-- get prepared to accept a new command, and schedule\n               //-- the first refresh cycle\n               //------------------------------------------------------\n               if (startup_refresh_count == 1'b0) begin\n                  state           <= s_idle;\n                  ready_for_new   <= 1'b1;\n                  got_transaction <= 1'b0;\n                  startup_refresh_count <= 2048 - cycles_per_refresh+1;\n               end\n            end\n         s_idle_in_6: state <= s_idle_in_5;\n         s_idle_in_5: state <= s_idle_in_4;\n         s_idle_in_4: state <= s_idle_in_3;\n         s_idle_in_3: state <= s_idle_in_2;\n         s_idle_in_2: state <= s_idle_in_1;\n         s_idle_in_1: state <= s_idle;\n\n         s_idle: begin\n               // Priority is to issue a refresh if one is outstanding\n               if (pending_refresh == 1'b1 || forcing_refresh == 1'b1) begin\n                  //------------------------------------------------------------------------\n                  //-- Start the refresh cycle. \n                  //-- This tasks tRFC (66ns), so 6 idle cycles are needed @ 100MHz\n                  //------------------------------------------------------------------------\n                  state       <= s_idle_in_6;\n                  iob_command <= CMD_REFRESH;\n                  startup_refresh_count <= startup_refresh_count - cycles_per_refresh+1;\n               end\n               else if (got_transaction == 1'b1) begin\n                  //--------------------------------\n                  //-- Start the read or write cycle. \n                  //-- First task is to open the row\n                  //--------------------------------\n                  state       <= s_open_in_2;\n                  iob_command <= CMD_ACTIVE;\n                  iob_address <= save_row;\n                  iob_bank    <= save_bank;\n               end               \n            end\n         //--------------------------------------------\n         //-- Opening the row ready for reads or writes\n         //--------------------------------------------\n         s_open_in_2: state <= s_open_in_1;\n\n         s_open_in_1: begin \n               // still waiting for row to open\n               if(save_wr == 1'b1) begin\n                  state       <= s_write_1;\n                  iob_dq_hiz  <= 1'b0;\n                  iob_data    <= save_data_in[15:0]; // get the DQ bus out of HiZ early\n               end else begin\n                  iob_dq_hiz  <= 1'b1;\n                  state       <= s_read_1;\n               end\n               // we will be ready for a new transaction next cycle!\n               ready_for_new   <= 1'b1; \n               got_transaction <= 1'b0;                  \n            end\n         //----------------------------------\n         //-- Processing the read transaction\n         //----------------------------------\n         s_read_1: begin\n               state           <= s_read_2;\n               iob_command     <= CMD_READ;\n               iob_address     <= save_col; \n               iob_bank        <= save_bank;\n               iob_address[prefresh_cmd] <= 1'b0; // A10 actually matters - it selects auto precharge\n               \n               // Schedule reading the data values off the bus\n               data_ready_delay[data_ready_delay_high]   <= 1'b1;\n               \n               // Set the data masks to read all bytes\n               iob_dqm     <= 2'b00;\n               dqm_sr[1:0] <= 2'b00;\n            end   \n         s_read_2: begin\n               state <= s_read_3;\n               if (forcing_refresh == 1'b0 && got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n                  if (save_wr == 1'b0) begin \n                     state           <= s_read_1;\n                     ready_for_new   <= 1'b1; // we will be ready for a new transaction next cycle!\n                     got_transaction <= 1'b0;\n                  end\n               end\n            end   \n         s_read_3: begin\n               state <= s_read_4;\n               if (forcing_refresh == 1'b0 && got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n                  if (save_wr == 1'b0) begin\n                     state           <= s_read_1;\n                     ready_for_new   <= 1'b1; // we will be ready for a new transaction next cycle!\n                     got_transaction <= 1'b0;\n                  end\n               end\n            end\n\n         s_read_4: begin\n               state <= s_precharge;\n               //-- can we do back-to-back read?\n               if (forcing_refresh == 1'b0 && got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n                  if (save_wr == 1'b0) begin \n                     state           <= s_read_1;\n                     ready_for_new   <= 1'b1; // we will be ready for a new transaction next cycle!\n                     got_transaction <= 1'b0;\n                  end\n                  else\n                     state <= s_open_in_2; // we have to wait for the read data to come back before we swutch the bus into HiZ\n               end\n            end\n         //------------------------------------------------------------------\n         // -- Processing the write transaction\n         //-------------------------------------------------------------------\n         s_write_1: begin\n               state                     <= s_write_2;\n               iob_command               <= CMD_WRITE;\n               iob_address               <= save_col; \n               iob_address[prefresh_cmd] <= 1'b0; // A10 actually matters - it selects auto precharge\n               iob_bank                  <= save_bank;\n               iob_dqm                   <= ! save_byte_enable[1:0];    \n               dqm_sr[1:0]               <= ! save_byte_enable[3:2];    \n               iob_data                  <= save_data_in[15:0];\n               iob_data_next             <= save_data_in[31:16];\n            end   \n         s_write_2: begin\n               state           <= s_write_3;\n               iob_data        <= iob_data_next;\n               // can we do a back-to-back write?\n               if (forcing_refresh == 1'b0 && got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n                  if (save_wr == 1'b1) begin\n                     // back-to-back write?\n                     state           <= s_write_1;\n                     ready_for_new   <= 1'b1;\n                     got_transaction <= 1'b0;\n                  end\n                  // Although it looks right in simulation you can't go write-to-read \n                  // here due to bus contention, as iob_dq_hiz takes a few ns.\n               end\n            end\n         s_write_3: begin\n               // must wait tRDL, hence the extra idle state\n               //-- back to back transaction?\n               if (forcing_refresh == 1'b0 && got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n                  if (save_wr == 1'b1) begin\n                     // back-to-back write?\n                     state           <= s_write_1;\n                     ready_for_new   <= 1'b1;\n                     got_transaction <= 1'b0;\n                  end\n                  else begin\n                     // write-to-read switch?\n                     state           <= s_read_1;\n                     iob_dq_hiz      <= 1'b1;\n                     ready_for_new   <= 1'b1; // we will be ready for a new transaction next cycle!\n                     got_transaction <= 1'b0;                  \n                  end \n               end else begin\n                  iob_dq_hiz         <= 1'b1;\n                  state              <= s_precharge;\n              end\n            end\n         //-------------------------------------------------------------------\n         //-- Closing the row off (this closes all banks)\n         //-------------------------------------------------------------------\n         s_precharge: begin\n               state                     <= s_idle_in_3;\n               iob_command               <= CMD_PRECHARGE;\n               iob_address[prefresh_cmd] <= 1'b1; // A10 actually matters - it selects all banks or just one\n            end\n         //-------------------------------------------------------------------\n         //-- We should never get here, but if we do then reset the memory\n         //-------------------------------------------------------------------\n         default: begin \n               state                 <= s_startup;\n               ready_for_new         <= 1'b0;\n               startup_refresh_count <= startup_refresh_max-sdram_startup_cycles;\n            end\n         endcase\n\n         if (reset == 1'b1) begin  // Sync reset\n            state                 <= s_startup;\n            ready_for_new         <= 1'b0;\n            startup_refresh_count <= startup_refresh_max-sdram_startup_cycles;\n         end\n      end      \nendmodule\n"]], "Diff Content": {"Delete": [[241, "always  @ (posedge clk )\n"], [265, "         if(save_bank == addr_bank && save_row == addr_row) \n"], [266, "            can_back_to_back <= 1'b1;\n"], [267, "         else\n"], [268, "            can_back_to_back <= 1'b0;\n"], [270, "         save_row         <= addr_row;\n"], [271, "         save_bank        <= addr_bank;\n"], [272, "         save_col         <= addr_col;\n"], [273, "         save_wr          <= cmd_wr; \n"], [274, "         save_data_in     <= cmd_data_in;\n"], [275, "         save_byte_enable <= cmd_byte_enable;\n"], [276, "         got_transaction  <= 1'b1;\n"], [277, "         ready_for_new    <= 1'b0;\n"], [286, "         data_out_reg       <= {captured_data, captured_data};\n"], [358, "               if (pending_refresh == 1'b1 || forcing_refresh == 1'b1) begin\n"], [363, "                  state       <= s_idle_in_6;\n"], [364, "                  iob_command <= CMD_REFRESH;\n"], [365, "                  startup_refresh_count <= startup_refresh_count - cycles_per_refresh+1;\n"], [366, "               end\n"], [367, "               else if (got_transaction == 1'b1) begin\n"], [372, "                  state       <= s_open_in_2;\n"], [373, "                  iob_command <= CMD_ACTIVE;\n"], [374, "                  iob_address <= save_row;\n"], [375, "                  iob_bank    <= save_bank;\n"], [376, "               end               \n"], [377, "            end\n"], [388, "                  iob_data    <= save_data_in[15:0]; // get the DQ bus out of HiZ early\n"], [405, "               iob_address[prefresh_cmd] <= 1'b0; // A10 actually matters - it selects auto precharge\n"], [416, "               if (forcing_refresh == 1'b0 && got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n"], [426, "               if (forcing_refresh == 1'b0 && got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n"], [438, "               if (forcing_refresh == 1'b0 && got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n"], [445, "                     state <= s_open_in_2; // we have to wait for the read data to come back before we switch the bus into HiZ\n"], [455, "               iob_address[prefresh_cmd] <= 1'b0; // A10 actually matters - it selects auto precharge\n"], [457, "               iob_dqm                   <= ~ save_byte_enable[1:0];    \n"], [467, "               if (forcing_refresh == 1'b0 && got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n"], [483, "               if (forcing_refresh == 1'b0 && got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n"]], "Add": [[241, "reg can_back_to_back = 0;\n"], [241, "always @(posedge clk) captured_data <= sdram_din;\n"], [241, "always @(posedge clk)\n"], [268, "        if(save_bank == addr_bank && save_row == addr_row) \n"], [268, "          can_back_to_back <= 1'b1;\n"], [268, "        else\n"], [268, "          can_back_to_back <= 1'b0;\n"], [277, "        save_row         <= addr_row;\n"], [277, "        save_bank        <= addr_bank;\n"], [277, "        save_col         <= addr_col;\n"], [277, "        save_wr          <= cmd_wr; \n"], [277, "        save_data_in     <= cmd_data_in;\n"], [277, "        save_byte_enable <= cmd_byte_enable;\n"], [277, "        got_transaction  <= 1'b1;\n"], [277, "        ready_for_new    <= 1'b0;\n"], [277, "      end\n"], [277, "      if (cmd_enable == 0) begin\n"], [277, "        data_ready_delay <= 0;\n"], [286, "         data_out_reg       <= captured_data;\n"], [288, "      if (data_ready_delay == 0)\n"], [288, "        data_out_queue_empty_reg <= 1;\n"], [288, "      else\n"], [288, "        data_out_queue_empty_reg <= 0;\n"], [377, "           if (got_transaction == 1'b1) begin\n"], [377, "              state       <= s_open_in_2;\n"], [377, "              iob_command <= CMD_ACTIVE;\n"], [377, "              iob_address <= save_row;\n"], [377, "              iob_bank    <= save_bank;\n"], [377, "           end               \n"], [377, "         end\n"], [388, "                  iob_data    <= save_data_in[15:0];\n"], [405, "               iob_address[prefresh_cmd] <= 1'b0; // A10: auto precharge\n"], [416, "               if (got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n"], [426, "               if (got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n"], [438, "               if (got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n"], [445, "                     state <= s_open_in_2;\n"], [455, "               iob_address[prefresh_cmd] <= 1'b0;\n"], [457, "               iob_dqm                   <= ~ save_byte_enable[1:0];      \n"], [467, "               if (got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n"], [483, "               if (got_transaction == 1'b1 && can_back_to_back == 1'b1) begin\n"]]}}