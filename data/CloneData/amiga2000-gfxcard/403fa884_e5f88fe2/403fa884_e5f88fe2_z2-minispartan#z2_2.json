{"Source Block": ["amiga2000-gfxcard/z2-minispartan/z2.v@392:768@HdlStmProcess", "parameter RAM_READING_ZORRO = 3;\nparameter RAM_WRITING = 4;\n\n// =================================================================================\n// ZORRO MACHINE\nalways @(posedge z_sample_clk) begin\n  case (zorro_state)\n    RESET: begin\n      dataout_enable <= 0;\n      dataout <= 0;\n      slaven <= 0;\n      z_ready <= 1'bZ; // clear XRDY (cpu wait)\n      zorro_ram_write_done <= 1;\n      zorro_ram_read_done <= 1;\n      blitter_rgb <= 'h4444;\n      blitter_enable <= 1;\n      \n      zorro_state <= CONFIGURING;\n    end\n    \n    CONFIGURING: begin\n      blitter_rgb <= 'h5555;\n      blitter_enable <= 1;\n      if (zaddr_autoconfig && !znCFGIN) begin\n        if (zorro_read) begin\n          // read iospace 'he80000 (Autoconfig ROM)\n          dataout_enable <= 1;\n          dataout <= 1;\n          slaven <= 1;\n          \n          case (zaddr & 'h0000ff)\n            'h000000: data <= 'b1100_0000_0000_0000; // zorro 2\n            'h000002: data <= 'b0111_0000_0000_0000; // 2mb\n            \n            'h000004: data <= 'b1111_0000_0000_0000; // product number\n            'h000006: data <= 'b1110_0000_0000_0000; // (23)\n            \n            'h000008: data <= 'b0011_0000_0000_0000; // flags inverted\n            'h00000a: data <= 'b1111_0000_0000_0000; // inverted zero\n            \n            'h000010: data <= 'b1111_0000_0000_0000; // manufacturer high byte inverted (02)\n            'h000012: data <= 'b1101_0000_0000_0000; // \n            'h000014: data <= 'b0110_0000_0000_0000; // manufacturer low byte (9a)\n            'h000016: data <= 'b0101_0000_0000_0000;\n            \n            'h000018: data <= 'b1111_0000_0000_0000; // serial\n            'h00001a: data <= 'b1110_0000_0000_0000; //\n            'h00001c: data <= 'b1111_0000_0000_0000; //\n            'h00001e: data <= 'b1110_0000_0000_0000; //\n            'h000020: data <= 'b1111_0000_0000_0000; //\n            'h000022: data <= 'b1110_0000_0000_0000; //\n            'h000024: data <= 'b1111_0000_0000_0000; //\n            'h000026: data <= 'b1110_0000_0000_0000; //\n            \n            'h000040: data <= 'b0000_0000_0000_0000; // interrupts (not inverted)\n            'h000042: data <= 'b0000_0000_0000_0000; //\n           \n            default: data <= 'b1111_0000_0000_0000;\n          endcase        \n        end else begin\n          // write to autoconfig register\n          if (datastrobe_synced) begin\n            case (zaddr & 'h0000ff)\n              'h000048: begin\n                ram_low[23:20] <= data_in[15:12];\n                LEDS <= 'hff;\n              end\n              'h00004a: begin\n                ram_low[19:16] <= data_in[15:12];\n                ram_high  <= ram_low + ram_size;\n                reg_low   <= ram_low + reg_base;\n                reg_high  <= ram_low + reg_base + 'h100;\n                zorro_state <= CONFIGURED; // configured\n                LEDS <= 'hfe;\n              end\n              'h00004c: begin \n                zorro_state <= CONFIGURED; // configured\n                LEDS <= 'hf0; // shut up register\n              end\n            endcase\n          end\n        end\n      end else begin\n        // no address match\n        dataout <= 0;\n        dataout_enable <= 0;\n        slaven <= 0;\n      end\n    end\n      \n    CONFIGURED: begin\n      LEDS <= 1;\n      blitter_rgb <= 'hffff;\n      blitter_enable <= 1;\n      zorro_state <= IDLE;\n    end\n  \n    // ----------------------------------------------------------------------------------  \n    IDLE: begin\n      dataout <= 0;\n      dataout_enable <= 0;\n      slaven <= 0;\n      write_stall <= 0;\n      z_ready <= 1'bZ; // clear XRDY (cpu wait)\n      \n      if (!znRST) begin\n        // system reset\n        zorro_state <= RESET;\n      end else if (znAS_sync[1]==0) begin\n        if (zorro_read && zaddr_in_ram) begin\n          // read RAM\n          // request ram access from arbiter\n          zorro_ram_read_addr <= ((zaddr-ram_low)>>1);\n          zorro_ram_read_request <= 1;\n          zorro_ram_read_done <= 0;\n          data <= 'h5555;\n          dataout <= 1;\n          dataout_enable <= 1;\n          read_counter <= 0;\n          \n          z_ready <= 0;\n          zorro_state <= WAIT_READ2;\n          \n        end else if (zorro_write && zaddr_in_ram) begin\n          // write RAM\n          \n          last_addr <= ((zaddr-ram_low)>>1);\n          zorro_state <= WAIT_WRITE;\n          \n        end else if (zorro_write && zaddr_in_reg && datastrobe_synced) begin\n          LEDS <= data_in[15:8];\n          // write to register\n          case (zaddr & 'h0000ff)\n            'h00: display_enable <= data_in[0];\n            'h02: read_to_fetch_time <= data_in[7:0];\n            'h04: fetch_delay_value <= data_in[7:0];\n            'h06: margin_x <= data_in[7:0];\n            'h08: fetch_preroll <= data_in[7:0];\n            'h0a: dataout_time <= data_in[7:0];\n            'h0c: slaven_time <= data_in[7:0];\n            'h0e: zready_time <= data_in[7:0];\n            'h10: glitch_reg <= data_in[7:0];\n            'h12: glitchx_reg <= data_in[11:0];\n            'h14: glitch_offset <= data_in[7:0];\n            'h16: negx_margin <= data_in[7:0];\n            \n            // blitter regs\n            'h20: blitter_x1 <= data_in[10:0];\n            'h22: blitter_y1 <= data_in[10:0];\n            'h24: blitter_x2 <= data_in[10:0];\n            'h26: blitter_y2 <= data_in[10:0];\n            'h28: blitter_rgb <= data_in[15:0];\n            'h2a: begin\n              blitter_enable <= data_in[8];\n              blitter_curx <= blitter_x1;\n              blitter_cury <= blitter_y1;\n            end\n            \n            // sd card regs\n            'h30: sd_reset <= data_in[8];\n            'h32: sd_read <= data_in[8];\n            'h34: sd_write <= data_in[8];\n            'h36: sd_handshake_in <= data_in[8];\n            'h38: sd_addr_in[31:16] <= data_in;\n            'h3a: sd_addr_in[15:0] <= data_in;\n            'h3c: sd_data_in <= data_in[15:8];\n          endcase\n        end else if (zorro_read && zaddr_in_reg) begin\n          // read from registers\n          \n          dataout_enable <= 1;\n          dataout <= 1;\n          slaven <= 1;\n          \n          case (zaddr & 'h0000ff)\n            'h2a: data <= blitter_enable?16'hffff:16'h0000;\n          \n            'h40: data <= ram_low[23:16];\n            'h42: data <= ram_low[15:0];\n            'h44: data <= ram_high[23:16];\n            'h46: data <= ram_high[15:0];\n            \n            'h30: data <= sd_busy<<8;\n            'h32: data <= sd_read<<8;\n            'h34: data <= sd_write<<8;\n            'h36: data <= sd_handshake_out<<8;\n            'h38: data <= sd_addr_in[31:16];\n            'h3a: data <= sd_addr_in[15:0];\n            'h3c: data <= sd_data_in<<8;\n            'h3e: data <= sd_data_out<<8;\n            'h40: data <= sd_error;\n            \n            default: data <= 'h0000;\n          endcase\n         \n        end        \n      end\n    end\n  \n    // ----------------------------------------------------------------------------------\n    WAIT_READ2:\n      if (znAS_sync[1]==1) begin\n        // ram too slow TODO: report this\n        zorro_ram_read_request <= 0;\n        zorro_state <= IDLE;\n        data <= 'h0000;\n      end else if (zorro_ram_read_done) begin\n        zorro_ram_read_request <= 0;\n        zorro_state <= WAIT_READ;\n        data <= zorro_ram_read_data;\n        read_counter <= 0;\n      end\n  \n    // ----------------------------------------------------------------------------------\n    WAIT_READ:\n      if (znAS_sync[1]==1) begin\n        zorro_state <= IDLE;\n      end else begin\n        dataout_enable <= 1;\n        dataout <= 1;\n        slaven <= 1;\n        z_ready <= 1'bZ;\n      end\n   \n    // ----------------------------------------------------------------------------------\n    WAIT_WRITE:\n      // FIXME race conditions occur if writeq is mutated while read\n      if (!zorro_ram_write_request) begin\n        // there is still room in the queue\n        z_ready <= 1'bZ;\n        write_stall <= 0;\n        if (datastrobe_synced) begin\n          zorro_ram_write_addr <= last_addr;\n          zorro_ram_write_bytes <= {~znUDS_sync[2],~znLDS_sync[2]};\n          zorro_ram_write_data <= zdata_in_sync;\n          zorro_ram_write_request <= 1;\n            \n          zorro_state <= WAIT_WRITE2;\n        end\n      end else begin\n        z_ready <= 0;\n        write_stall <= 1;\n      end\n    \n    // ----------------------------------------------------------------------------------\n    WAIT_WRITE2: begin\n      if (znAS_sync[1]==1) zorro_state <= IDLE;\n    end\n    \n  endcase\n\n// =================================================================================\n// RAM ARBITER\n\n  case (ram_arbiter_state)\n    RAM_READY: begin\n      // start fetching a row\n      fetch_x <= 0;\n      if (row_fetched) begin\n        ram_enable <= 0;\n        ram_arbiter_state <= RAM_ROW_FETCHED;\n      end else begin\n        if (cmd_ready) begin\n          ram_addr  <= ((fetch_y << 11) | fetch_x);\n          ram_enable <= 1; // fetch next\n          ram_byte_enable <= 'b11;\n          ram_write <= 0;\n          ram_arbiter_state <= RAM_FETCHING_ROW;\n          fetch_x <= 1;\n        end\n      end\n    end\n    \n    RAM_FETCHING_ROW:\n      if (data_out_ready) begin\n        if (fetch_x >= screen_w) begin\n          fetch_x  <= 0;\n          row_fetched <= 1; // row completely fetched\n          ram_arbiter_state <= RAM_ROW_FETCHED;\n          ram_enable <= 0;\n        end else begin\n          fetch_buffer[fetch_x] <= ram_data_out[15:0];\n          \n          if (cmd_ready) begin\n            fetch_x <= fetch_x + 1;\n            ram_addr  <= ((fetch_y << 11) | fetch_x);\n            ram_enable <= 1; // fetch next\n            ram_byte_enable <= 'b11;\n            ram_write <= 0;\n          end\n        end\n      end\n    RAM_ROW_FETCHED:\n      if (!row_fetched) begin\n        ram_enable <= 0;\n        ram_arbiter_state <= RAM_READY;\n      end else if (writeq_fill>0 && !zorro_ram_write_request) begin\n        // process write queue\n        if (cmd_ready) begin\n          if (writeq_addr[writeq_fill-1][uds_bit] && !writeq_addr[writeq_fill-1][lds_bit])\n            ram_byte_enable <= 'b10; // UDS\n          else if (writeq_addr[writeq_fill-1][lds_bit] && !writeq_addr[writeq_fill-1][uds_bit])\n            ram_byte_enable <= 'b01; // LDS\n          else\n            ram_byte_enable <= 'b11;\n          \n          ram_data_in <= (writeq_data[writeq_fill-1]);\n          ram_addr    <= (writeq_addr[writeq_fill-1][q_msb:0]);\n          ram_write   <= 1;\n          ram_enable  <= 1;\n          \n          writeq_fill <= writeq_fill-1;\n          // TODO additional wait state?\n        end\n      end else if (zorro_ram_write_request) begin\n        if (writeq_fill<max_fill-1) begin\n          // process write request\n          zorro_ram_write_done <= 1;\n          zorro_ram_write_request <= 0;\n          writeq_addr[writeq_fill][q_msb:0] <= zorro_ram_write_addr;\n          writeq_addr[writeq_fill][uds_bit] <= zorro_ram_write_bytes[1];\n          writeq_addr[writeq_fill][lds_bit] <= zorro_ram_write_bytes[0];\n          writeq_data[writeq_fill] <= zorro_ram_write_data;\n          \n          writeq_fill <= writeq_fill + 1;\n        end else begin\n          zorro_ram_write_done <= 0;\n        end\n        \n      end else if (zorro_ram_read_request) begin\n        // process read request\n        zorro_ram_read_done <= 0;\n        if (cmd_ready) begin\n          ram_write <= 0;\n          ram_addr <= zorro_ram_read_addr;\n          ram_byte_enable <= 'b11;\n          ram_enable <= 1;\n          ram_arbiter_state <= RAM_READING_ZORRO;\n        end\n      end else if (blitter_enable && cmd_ready) begin\n        if (blitter_curx<=blitter_x2) begin\n          blitter_curx <= blitter_curx + 1;\n          ram_byte_enable <= 'b11;\n          ram_data_in <= blitter_rgb;\n          ram_addr    <= (blitter_cury<<11)|blitter_curx;\n          ram_write   <= 1;\n          ram_enable  <= 1;\n        end else if (blitter_cury<blitter_y2) begin\n          blitter_cury <= blitter_cury + 1;\n          blitter_curx <= blitter_x1;\n        end else begin\n          blitter_curx <= 0;\n          blitter_cury <= 0;\n          blitter_enable <= 0;\n        end\n      end\n      \n    RAM_READING_ZORRO: if (data_out_ready) begin\n        zorro_ram_read_data <= ram_data_out;\n        zorro_ram_read_done <= 1;\n        zorro_ram_read_request <= 0;\n        ram_arbiter_state <= RAM_ROW_FETCHED;\n      end     \n  endcase\n  \n  // decide when to fetch next row\n  if (counter_x==h_max-fetch_preroll && counter_y<screen_h) begin\n    row_fetched <= 0;\n    fetch_x <= 0;\n    fetch_y <= counter_y;\n  end\nend\n\nreg[15:0] rgb = 'h0000;\n\nalways @(posedge vga_clk) begin\n  if (counter_x >= h_max) begin\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[652, "        ram_arbiter_state <= RAM_ROW_FETCHED;\n"], [670, "          ram_arbiter_state <= RAM_ROW_FETCHED;\n"], [686, "        ram_enable <= 0;\n"], [688, "      end else if (writeq_fill>0 && !zorro_ram_write_request) begin\n"], [724, "        if (cmd_ready) begin\n"], [749, "    RAM_READING_ZORRO: if (data_out_ready) begin\n"], [750, "        zorro_ram_read_data <= ram_data_out;\n"], [751, "        zorro_ram_read_done <= 1;\n"], [752, "        zorro_ram_read_request <= 0;\n"], [753, "        ram_arbiter_state <= RAM_ROW_FETCHED;\n"], [754, "      end     \n"]], "Add": [[652, "        if (data_out_queue_empty)\n"], [652, "          ram_arbiter_state <= RAM_ROW_FETCHED;\n"], [671, "          ram_arbiter_state <= RAM_ROW_FETCHED;\n"], [688, "      end else if (writeq_fill>0) begin\n"], [724, "        ram_enable <= 0;\n"], [724, "        if (cmd_ready && data_out_queue_empty) begin\n"], [745, "          ram_enable <= 0;\n"], [754, "    RAM_READING_ZORRO: begin    \n"], [754, "        ram_enable <= 0;\n"], [754, "        if (data_out_ready) begin\n"], [754, "          zorro_ram_read_data <= ram_data_out;\n"], [754, "          zorro_ram_read_done <= 1;\n"], [754, "          zorro_ram_read_request <= 0;\n"], [754, "          ram_arbiter_state <= RAM_ROW_FETCHED;\n"], [754, "        end\n"], [754, "      end\n"]]}}