{"Source Block": ["e200_opensource/rtl/e203/general/sirv_gnrl_bufs.v@411:530@HdlStmIf", ");\n\ngenvar i;\ngenerate //{\n\n  if(DP == 0) begin: dp_eq1//{ pass through when it is 0 entries\n\n     assign o_vld = i_vld;\n     assign i_rdy = o_rdy;\n     assign o_dat = i_dat;\n\n  end//}\n  else begin: dp_gt1//{\n\n    // FIFO registers\n    wire [DW-1:0] fifo_rf_r [DP-1:0];\n    wire [DP-1:0] fifo_rf_en;\n\n    // read/write enable\n    wire wen = i_vld & i_rdy;\n    wire ren = o_vld & o_rdy;\n    \n    ////////////////\n    ///////// Read-Pointer and Write-Pointer\n    wire [DP-1:0] rptr_vec_nxt; \n    wire [DP-1:0] rptr_vec_r;\n    wire [DP-1:0] wptr_vec_nxt; \n    wire [DP-1:0] wptr_vec_r;\n\n    if(DP == 1) begin:rptr_dp_1\n      assign rptr_vec_nxt = 1'b1; \n    end\n    else begin:rptr_dp_not_1\n      assign rptr_vec_nxt = \n          rptr_vec_r[DP-1] ? {{DP-1{1'b0}}, 1'b1} :\n                          (rptr_vec_r << 1);\n    end\n\n    if(DP == 1) begin:wptr_dp_1\n      assign wptr_vec_nxt = 1'b1; \n    end\n    else begin:wptr_dp_not_1\n      assign wptr_vec_nxt =\n          wptr_vec_r[DP-1] ? {{DP-1{1'b0}}, 1'b1} :\n                          (wptr_vec_r << 1);\n    end\n\n    sirv_gnrl_dfflrs #(1)    rptr_vec_0_dfflrs  (ren, rptr_vec_nxt[0]     , rptr_vec_r[0]     , clk, rst_n);\n    sirv_gnrl_dfflrs #(1)    wptr_vec_0_dfflrs  (wen, wptr_vec_nxt[0]     , wptr_vec_r[0]     , clk, rst_n);\n    if(DP > 1) begin:dp_gt1\n    sirv_gnrl_dfflr  #(DP-1) rptr_vec_31_dfflr  (ren, rptr_vec_nxt[DP-1:1], rptr_vec_r[DP-1:1], clk, rst_n);\n    sirv_gnrl_dfflr  #(DP-1) wptr_vec_31_dfflr  (wen, wptr_vec_nxt[DP-1:1], wptr_vec_r[DP-1:1], clk, rst_n);\n    end\n\n    ////////////////\n    ///////// Vec register to easy full and empty and the o_vld generation with flop-clean\n    wire [DP:0] i_vec;\n    wire [DP:0] o_vec;\n    wire [DP:0] vec_nxt; \n    wire [DP:0] vec_r;\n\n    wire vec_en = (ren ^ wen );\n    assign vec_nxt = wen ? {vec_r[DP-1:0], 1'b1} : (vec_r >> 1);  \n    \n    sirv_gnrl_dfflrs #(1)  vec_0_dfflrs     (vec_en, vec_nxt[0]     , vec_r[0]     ,     clk, rst_n);\n    sirv_gnrl_dfflr  #(DP) vec_31_dfflr     (vec_en, vec_nxt[DP:1], vec_r[DP:1],     clk, rst_n);\n    \n    assign i_vec = {1'b0,vec_r[DP:1]};\n    assign o_vec = {1'b0,vec_r[DP:1]};\n\n    if(DP == 1) begin:cut_dp_eq1//{\n        if(CUT_READY == 1) begin:cut_ready//{\n          // If cut ready, then only accept when fifo is not full\n          assign i_rdy = (~i_vec[DP-1]);\n        end//}\n        else begin:no_cut_ready//{\n          // If not cut ready, then can accept when fifo is not full or it is popping \n          assign i_rdy = (~i_vec[DP-1]) | ren;\n        end//}\n    end//}\n    else begin : no_cut_dp_gt1//}{\n      assign i_rdy = (~i_vec[DP-1]);\n    end//}\n\n\n    ///////// write fifo\n    for (i=0; i<DP; i=i+1) begin:fifo_rf//{\n      assign fifo_rf_en[i] = wen & wptr_vec_r[i];\n      // Write the FIFO registers\n      sirv_gnrl_dffl  #(DW) fifo_rf_dffl (fifo_rf_en[i], i_dat, fifo_rf_r[i], clk);\n    end//}\n\n    /////////One-Hot Mux as the read path\n    integer j;\n    reg [DW-1:0] mux_rdat;\n    always @*\n    begin : rd_port_PROC//{\n      mux_rdat = {DW{1'b0}};\n      for(j=0; j<DP; j=j+1) begin\n        mux_rdat = mux_rdat | ({DW{rptr_vec_r[j]}} & fifo_rf_r[j]);\n      end\n    end//}\n    \n    if(MSKO == 1) begin:mask_output//{\n        // Mask the data with valid since the FIFO register is not reset and as X \n        assign o_dat = {DW{o_vld}} & mux_rdat;\n    end//}\n    else begin:no_mask_output//{\n        // Not Mask the data with valid since no care with X for datapth\n        assign o_dat = mux_rdat;\n    end//}\n    \n    // o_vld as flop-clean\n    assign o_vld = (o_vec[0]);\n    \n  end//}\nendgenerate//}\n\nendmodule \n\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[423, "  else begin: dp_gt1//{\n"]], "Add": [[423, "  else begin: dp_gt0//{\n"]]}}