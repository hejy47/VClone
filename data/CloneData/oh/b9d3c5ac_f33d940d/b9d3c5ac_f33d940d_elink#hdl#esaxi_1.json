{"Source Block": ["oh/elink/hdl/esaxi.v@232:274@HdlStmProcess", "           else if( last_wr_beat )\n             write_active <= 1'b0;         \n\tend // else: !if(~s_axi_aresetn)\n   \n   // capture address & other aw info, update address during cycle\n   always @( posedge s_axi_aclk ) \n     if (~s_axi_aresetn)  \n       begin\n          //s_axi_bid          <= 'd0;  // capture for write response\n          axi_awaddr[31:0] <= 32'd0;\n          axi_awsize[2:0]  <= 3'd0;\n          axi_awburst[1:0] <= 2'd0;         \n       end \n     else \n       begin\t  \n          if( s_axi_awready & s_axi_awvalid ) \n\t    begin\t     \n\t       //TODO: If we support only one host read, why the need?\n               //s_axi_bid      <= s_axi_awid;\n\t       //TODO: something is wrong here!!!\n               axi_awaddr[31:0]   <= { ecfg_coreid[11:c_s_axi_addr_width-20],\n\t\t\t\t       s_axi_awaddr[29:0] };\n               axi_awsize   <= s_axi_awsize;  // 0=byte, 1=16b, 2=32b\n               axi_awburst  <= s_axi_awburst; // type, 0=fixed, 1=incr, 2=wrap\n\t       \n            end \n\t  else if( s_axi_wvalid & s_axi_wready ) \n\t    begin\t       \n               if( axi_awburst == 2'b01 ) \n\t\t begin //incremental burst\n\t\t    // the write address for all the beats in the transaction are increments by the data width.\n\t\t    // note: this should be based on awsize instead to support narrow bursts, i think.\n\t\t    axi_awaddr[31:addr_lsb] <= axi_awaddr[31:addr_lsb] + 32'd1;\n\t\t    //awaddr aligned to data width\n\t\t    axi_awaddr[addr_lsb-1:0]  <= {addr_lsb{1'b0}};   \t\t  \n\t\t end  // both fixed & wrapping types are treated as fixed, no update.\n            end // if ( s_axi_wvalid & axi_wready )\n       end // else: !if(~s_axi_aresetn)\n   \n   //###################################################\n   //#WRITE CHANNEL\n   //###################################################\n   always @ (posedge s_axi_aclk)\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[264, "\t\t    axi_awaddr[31:addr_lsb] <= axi_awaddr[31:addr_lsb] + 32'd1;\n"]], "Add": [[264, "\t\t    axi_awaddr[31:addr_lsb] <= axi_awaddr[31:addr_lsb] + 30'd1;\n"]]}}