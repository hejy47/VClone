{"Source Block": ["oh/esaxi/hdl/esaxi_v1_0_S00_AXI.v@264:306@HdlStmProcess", "      end // else: !if( S_AXI_ARESETN == 1'b0 )\n   end // always @ ( posedge S_AXI_ACLK )\n   \n   // Capture address & other AW info, update address during cycle\n   \n   always @( posedge S_AXI_ACLK ) begin\n      if ( S_AXI_ARESETN == 1'b0 )  begin\n\n         axi_bid      <= 'd0;  // capture for write response\n         axi_awaddr   <= 'd0;\n         axi_awsize   <= 3'd0;\n         axi_awburst  <= 2'd0;\n         \n      end else begin\n\n         if( axi_awready & S_AXI_AWVALID ) begin\n\n            axi_bid      <= S_AXI_AWID;\n            axi_awaddr   <= { ecfg_coreid[11:C_S_AXI_ADDR_WIDTH-20],\n                              S_AXI_AWADDR };\n            axi_awsize   <= S_AXI_AWSIZE;  // 0=byte, 1=16b, 2=32b\n            axi_awburst  <= S_AXI_AWBURST; // type, 0=fixed, 1=incr, 2=wrap\n\n         end else if( S_AXI_WVALID & axi_wready ) begin\n\n            if( axi_awburst == 2'b01 ) begin //incremental burst\n               // The write address for all the beats in the transaction are increments by the data width.\n               // NOTE: This should be based on awsize instead to support narrow bursts, I think.\n               \n               axi_awaddr[31:ADDR_LSB] <= axi_awaddr[31 - 1:ADDR_LSB] + 1;\n               //awaddr aligned to data width\n               axi_awaddr[ADDR_LSB-1:0]  <= {ADDR_LSB{1'b0}};   \n\n            end  // Both FIXED & WRAPPING types are treated as FIXED, no update.\n\n         end // if ( S_AXI_WVALID & axi_wready )\n      end // else: !if( S_AXI_ARESETN == 1'b0 )\n   end // always @ ( posedge S_AXI_ACLK )\n   \n   // Write Channel Implementation\n\n   always @( posedge S_AXI_ACLK ) begin\n      if( S_AXI_ARESETN == 1'b0 ) begin\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[293, "               axi_awaddr[31:ADDR_LSB] <= axi_awaddr[31 - 1:ADDR_LSB] + 1;\n"]], "Add": [[293, "               axi_awaddr[31:ADDR_LSB] <= axi_awaddr[31:ADDR_LSB] + 32'd1;\n"]]}}