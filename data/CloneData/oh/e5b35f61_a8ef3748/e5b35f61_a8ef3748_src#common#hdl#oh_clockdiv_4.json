{"Source Block": ["oh/src/common/hdl/oh_clockdiv.v@114:124@HdlStmAssign", "   \n   // clock mux\n   assign clk1_sel[3] =  1'b0;               // not implemented\n   assign clk1_sel[2] = (clkdiv[7:0]==8'd0); // div1 (bypass)\n   assign clk1_sel[1] = (clkdiv[7:0]==8'd1); // div2 clock \n   assign clk1_sel[0] = |clkdiv[7:1];        // all others\n   \n   oh_clockmux #(.N(4))\n   oh_clockmux1 (.clkout(clkout1),\n\t\t .clk(clk),\n\t\t .en( clk1_sel[3:0]),\n"], "Clone Blocks": [["oh/src/common/hdl/oh_clockdiv.v@113:123", "     clkout1_shift <= clkout1_reg;\n   \n   // clock mux\n   assign clk1_sel[3] =  1'b0;               // not implemented\n   assign clk1_sel[2] = (clkdiv[7:0]==8'd0); // div1 (bypass)\n   assign clk1_sel[1] = (clkdiv[7:0]==8'd1); // div2 clock \n   assign clk1_sel[0] = |clkdiv[7:1];        // all others\n   \n   oh_clockmux #(.N(4))\n   oh_clockmux1 (.clkout(clkout1),\n\t\t .clk(clk),\n"], ["oh/src/common/hdl/oh_clockdiv.v@112:122", "   always @ (negedge clk)\n     clkout1_shift <= clkout1_reg;\n   \n   // clock mux\n   assign clk1_sel[3] =  1'b0;               // not implemented\n   assign clk1_sel[2] = (clkdiv[7:0]==8'd0); // div1 (bypass)\n   assign clk1_sel[1] = (clkdiv[7:0]==8'd1); // div2 clock \n   assign clk1_sel[0] = |clkdiv[7:1];        // all others\n   \n   oh_clockmux #(.N(4))\n   oh_clockmux1 (.clkout(clkout1),\n"], ["oh/src/common/hdl/oh_clockdiv.v@111:121", "   // creating divide by 2 shifted clock with negedge\n   always @ (negedge clk)\n     clkout1_shift <= clkout1_reg;\n   \n   // clock mux\n   assign clk1_sel[3] =  1'b0;               // not implemented\n   assign clk1_sel[2] = (clkdiv[7:0]==8'd0); // div1 (bypass)\n   assign clk1_sel[1] = (clkdiv[7:0]==8'd1); // div2 clock \n   assign clk1_sel[0] = |clkdiv[7:1];        // all others\n   \n   oh_clockmux #(.N(4))\n"]], "Diff Content": {"Delete": [], "Add": [[119, "   oh_lat0 #(.DW(4)) \n"], [119, "   latch_clk1 (.out (clk1_sel_sh[3:0]),\n"], [119, "\t       .clk (clk),\n"], [119, "\t       .in  (clk1_sel[3:0]));\n"]]}}