{"Source Block": ["oh/eclock/hdl/eclock.v@153:244@HdlStmIf", "   BUFG lclk_p_buf\n     (.O   (lclk_p),\n      .I   (lclk_p_src));\n\ngenerate\n   if( FEATURE_CCLK_DIV ) begin : gen_cclk_div\n\n         // Create adjustable (but fast) CCLK\n   wire      rxi_cclk_out;\n   reg [8:1] cclk_pattern;\n   reg [3:0] clk_div_sync;\n   reg       enb_sync;\n   \n   always @ (posedge cclk_p) begin  // Might need x-clock TIG here\n\n      clk_div_sync <= ecfg_cclk_div;\n      enb_sync     <= ecfg_cclk_en;\n\n      if(enb_sync)\n        case(clk_div_sync)\n          4'h0:    cclk_pattern <= 8'd0;         // Clock OFF\n          4'h7:    cclk_pattern <= 8'b10101010;  // Divide by 1\n          4'h6:    cclk_pattern <= 8'b11001100;  // Divide by 2\n          4'h5:    cclk_pattern <= 8'b11110000;  // Divide by 4\n          default: cclk_pattern <= {8{~cclk_pattern[1]}}; // /8\n        endcase\n      else\n        cclk_pattern <= 8'b00000000;\n\n   end // always @ (posedge lclk_p)\n         \n   OSERDESE2 \n     #(\n       .DATA_RATE_OQ(\"DDR\"),  // DDR, SDR\n       .DATA_RATE_TQ(\"SDR\"),  // DDR, BUF, SDR\n       .DATA_WIDTH(8),        // Parallel data width (2-8,10,14)\n       .INIT_OQ(1'b0),        // Initial value of OQ output (1'b0,1'b1)\n       .INIT_TQ(1'b0),        // Initial value of TQ output (1'b0,1'b1)\n       .SERDES_MODE(\"MASTER\"), // MASTER, SLAVE\n       .SRVAL_OQ(1'b0),       // OQ output value when SR is used (1'b0,1'b1)\n       .SRVAL_TQ(1'b0),       // TQ output value when SR is used (1'b0,1'b1)\n       .TBYTE_CTL(\"FALSE\"),   // Enable tristate byte operation (FALSE, TRUE)\n       .TBYTE_SRC(\"FALSE\"),   // Tristate byte source (FALSE, TRUE)\n       .TRISTATE_WIDTH(1)     // 3-state converter width (1,4)\n       ) OSERDESE2_inst \n       (\n        .OFB(),             // 1-bit output: Feedback path for data\n        .OQ(cclk),          // 1-bit output: Data path output\n        .SHIFTOUT1(),       // SHIFTOUTn: 1-bit (each): Data output expansion\n        .SHIFTOUT2(),\n        .TBYTEOUT(),        // 1-bit output: Byte group tristate\n        .TFB(),             // 1-bit output: 3-state control\n        .TQ(),              // 1-bit output: 3-state control\n        .CLK(cclk_base),    // 1-bit input: High speed clock\n        .CLKDIV(cclk_p),    // 1-bit input: Divided clock\n        .D1(cclk_pattern[1]), // D1 - D8: Parallel data inputs (1-bit each)\n        .D2(cclk_pattern[2]),\n        .D3(cclk_pattern[3]),\n        .D4(cclk_pattern[4]),\n        .D5(cclk_pattern[5]),\n        .D6(cclk_pattern[6]),\n        .D7(cclk_pattern[7]),\n        .D8(cclk_pattern[8]),\n        .OCE(1'b1),         // 1-bit input: Output data clock enable\n        .RST(reset),        // 1-bit input: Reset\n        .SHIFTIN1(1'b0),    // SHIFTINn: Data input expansion (1-bit each)\n        .SHIFTIN2(1'b0),\n        .T1(1'b0),          // T1 - T4: Parallel 3-state inputs\n        .T2(1'b0),\n        .T3(1'b0),\n        .T4(1'b0),\n        .TBYTEIN(1'b0),     // 1-bit input: Byte group tristate\n        .TCE(1'b0)          // 1-bit input: 3-state clock enable\n        );\n\n   end else begin : gen_fixed_cclk // Non-dividable CCLK\n\n   reg       enb_sync;\n\n   always @ (posedge cclk_p)\n      enb_sync     <= ecfg_cclk_en;\n\n   // The following does not result in timing failures,\n   //  but doesn't seem glitch-safe\n   assign cclk = cclk_base & enb_sync;\n   \n   end\nendgenerate\n   \n   // xilinx OBUFDS instantiation\n   //\n   OBUFDS\n"], "Clone Blocks": [["oh/elink/hdl/eclock.v@156:247", "   BUFG lclk_p_buf\n     (.O   (txlclk_p),\n      .I   (lclk_p_src));\n\ngenerate\n   if( FEATURE_CCLK_DIV ) begin : gen_cclk_div\n\n         // Create adjustable (but fast) CCLK\n   wire      rxi_cclk_out;\n   reg [8:1] cclk_pattern;\n   reg [3:0] clk_div_sync;\n   reg       enb_sync;\n   \n   always @ (posedge cclk_p) begin  // Might need x-clock TIG here\n\n      clk_div_sync <= ecfg_cclk_div;\n      enb_sync     <= ecfg_cclk_en;\n\n      if(enb_sync)\n        case(clk_div_sync)\n          4'h0:    cclk_pattern <= 8'd0;         // Clock OFF\n          4'h7:    cclk_pattern <= 8'b10101010;  // Divide by 1\n          4'h6:    cclk_pattern <= 8'b11001100;  // Divide by 2\n          4'h5:    cclk_pattern <= 8'b11110000;  // Divide by 4\n          default: cclk_pattern <= {8{~cclk_pattern[1]}}; // /8\n        endcase\n      else\n        cclk_pattern <= 8'b00000000;\n\n   end // always @ (posedge lclk_p)\n         \n   OSERDESE2 \n     #(\n       .DATA_RATE_OQ(\"DDR\"),  // DDR, SDR\n       .DATA_RATE_TQ(\"SDR\"),  // DDR, BUF, SDR\n       .DATA_WIDTH(8),        // Parallel data width (2-8,10,14)\n       .INIT_OQ(1'b0),        // Initial value of OQ output (1'b0,1'b1)\n       .INIT_TQ(1'b0),        // Initial value of TQ output (1'b0,1'b1)\n       .SERDES_MODE(\"MASTER\"), // MASTER, SLAVE\n       .SRVAL_OQ(1'b0),       // OQ output value when SR is used (1'b0,1'b1)\n       .SRVAL_TQ(1'b0),       // TQ output value when SR is used (1'b0,1'b1)\n       .TBYTE_CTL(\"FALSE\"),   // Enable tristate byte operation (FALSE, TRUE)\n       .TBYTE_SRC(\"FALSE\"),   // Tristate byte source (FALSE, TRUE)\n       .TRISTATE_WIDTH(1)     // 3-state converter width (1,4)\n       ) OSERDESE2_inst \n       (\n        .OFB(),             // 1-bit output: Feedback path for data\n        .OQ(cclk),          // 1-bit output: Data path output\n        .SHIFTOUT1(),       // SHIFTOUTn: 1-bit (each): Data output expansion\n        .SHIFTOUT2(),\n        .TBYTEOUT(),        // 1-bit output: Byte group tristate\n        .TFB(),             // 1-bit output: 3-state control\n        .TQ(),              // 1-bit output: 3-state control\n        .CLK(cclk_base),    // 1-bit input: High speed clock\n        .CLKDIV(cclk_p),    // 1-bit input: Divided clock\n        .D1(cclk_pattern[1]), // D1 - D8: Parallel data inputs (1-bit each)\n        .D2(cclk_pattern[2]),\n        .D3(cclk_pattern[3]),\n        .D4(cclk_pattern[4]),\n        .D5(cclk_pattern[5]),\n        .D6(cclk_pattern[6]),\n        .D7(cclk_pattern[7]),\n        .D8(cclk_pattern[8]),\n        .OCE(1'b1),         // 1-bit input: Output data clock enable\n        .RST(reset),        // 1-bit input: Reset\n        .SHIFTIN1(1'b0),    // SHIFTINn: Data input expansion (1-bit each)\n        .SHIFTIN2(1'b0),\n        .T1(1'b0),          // T1 - T4: Parallel 3-state inputs\n        .T2(1'b0),\n        .T3(1'b0),\n        .T4(1'b0),\n        .TBYTEIN(1'b0),     // 1-bit input: Byte group tristate\n        .TCE(1'b0)          // 1-bit input: 3-state clock enable\n        );\n\n   end else begin : gen_fixed_cclk // Non-dividable CCLK\n\n   reg       enb_sync;\n\n   always @ (posedge cclk_p)\n      enb_sync     <= ecfg_cclk_en;\n\n   // The following does not result in timing failures,\n   //  but doesn't seem glitch-safe\n   assign cclk = cclk_base & enb_sync;\n   \n   end\nendgenerate\n   \n   // xilinx OBUFDS instantiation\n   //\n   OBUFDS\n"]], "Diff Content": {"Delete": [[161, "   wire      rxi_cclk_out;\n"], [162, "   reg [8:1] cclk_pattern;\n"], [163, "   reg [3:0] clk_div_sync;\n"], [164, "   reg       enb_sync;\n"], [166, "   always @ (posedge cclk_p) begin  // Might need x-clock TIG here\n"], [168, "      clk_div_sync <= ecfg_cclk_div;\n"], [169, "      enb_sync     <= ecfg_cclk_en;\n"], [171, "      if(enb_sync)\n"], [172, "        case(clk_div_sync)\n"], [173, "          4'h0:    cclk_pattern <= 8'd0;         // Clock OFF\n"], [174, "          4'h7:    cclk_pattern <= 8'b10101010;  // Divide by 1\n"], [175, "          4'h6:    cclk_pattern <= 8'b11001100;  // Divide by 2\n"], [176, "          4'h5:    cclk_pattern <= 8'b11110000;  // Divide by 4\n"], [177, "          default: cclk_pattern <= {8{~cclk_pattern[1]}}; // /8\n"], [178, "        endcase\n"], [180, "        cclk_pattern <= 8'b00000000;\n"], [182, "   end // always @ (posedge lclk_p)\n"], [186, "       .DATA_RATE_OQ(\"DDR\"),  // DDR, SDR\n"], [187, "       .DATA_RATE_TQ(\"SDR\"),  // DDR, BUF, SDR\n"], [188, "       .DATA_WIDTH(8),        // Parallel data width (2-8,10,14)\n"], [189, "       .INIT_OQ(1'b0),        // Initial value of OQ output (1'b0,1'b1)\n"], [190, "       .INIT_TQ(1'b0),        // Initial value of TQ output (1'b0,1'b1)\n"], [191, "       .SERDES_MODE(\"MASTER\"), // MASTER, SLAVE\n"], [192, "       .SRVAL_OQ(1'b0),       // OQ output value when SR is used (1'b0,1'b1)\n"], [193, "       .SRVAL_TQ(1'b0),       // TQ output value when SR is used (1'b0,1'b1)\n"], [194, "       .TBYTE_CTL(\"FALSE\"),   // Enable tristate byte operation (FALSE, TRUE)\n"], [195, "       .TBYTE_SRC(\"FALSE\"),   // Tristate byte source (FALSE, TRUE)\n"], [196, "       .TRISTATE_WIDTH(1)     // 3-state converter width (1,4)\n"], [199, "        .OFB(),             // 1-bit output: Feedback path for data\n"], [200, "        .OQ(cclk),          // 1-bit output: Data path output\n"], [201, "        .SHIFTOUT1(),       // SHIFTOUTn: 1-bit (each): Data output expansion\n"], [203, "        .TBYTEOUT(),        // 1-bit output: Byte group tristate\n"], [204, "        .TFB(),             // 1-bit output: 3-state control\n"], [205, "        .TQ(),              // 1-bit output: 3-state control\n"], [206, "        .CLK(cclk_base),    // 1-bit input: High speed clock\n"], [207, "        .CLKDIV(cclk_p),    // 1-bit input: Divided clock\n"], [208, "        .D1(cclk_pattern[1]), // D1 - D8: Parallel data inputs (1-bit each)\n"], [216, "        .OCE(1'b1),         // 1-bit input: Output data clock enable\n"], [217, "        .RST(reset),        // 1-bit input: Reset\n"], [218, "        .SHIFTIN1(1'b0),    // SHIFTINn: Data input expansion (1-bit each)\n"], [220, "        .T1(1'b0),          // T1 - T4: Parallel 3-state inputs\n"], [224, "        .TBYTEIN(1'b0),     // 1-bit input: Byte group tristate\n"], [225, "        .TCE(1'b0)          // 1-bit input: 3-state clock enable\n"], [228, "   end else begin : gen_fixed_cclk // Non-dividable CCLK\n"], [230, "   reg       enb_sync;\n"], [232, "   always @ (posedge cclk_p)\n"], [233, "      enb_sync     <= ecfg_cclk_en;\n"], [237, "   assign cclk = cclk_base & enb_sync;\n"], [239, "   end\n"]], "Add": [[164, "      wire      rxi_cclk_out;\n"], [164, "      reg [8:1] cclk_pattern;\n"], [164, "      reg [3:0] clk_div_sync;\n"], [164, "      reg       enb_sync;\n"], [178, "      always @ (posedge cclk_div) begin  // Might need x-clock TIG here\n"], [178, "\t clk_div_sync <= ecfg_cclk_div;\n"], [178, "\t enb_sync     <= ecfg_cclk_en;\n"], [178, "\t if(enb_sync)\n"], [178, "           case(clk_div_sync)\n"], [178, "             4'h0:    cclk_pattern <= 8'd0;         // Clock OFF\n"], [178, "             4'h7:    cclk_pattern <= 8'b10101010;  // Divide by 1\n"], [178, "             4'h6:    cclk_pattern <= 8'b11001100;  // Divide by 2\n"], [178, "             4'h5:    cclk_pattern <= 8'b11110000;  // Divide by 4\n"], [178, "             default: cclk_pattern <= {8{~cclk_pattern[1]}}; // /8\n"], [178, "           endcase\n"], [182, "        cclk_pattern <= 8'b00000000;\t \n"], [182, "      end // always @ (posedge cclk_div)\n"], [196, "       .DATA_RATE_OQ(\"DDR\"),     // DDR, SDR\n"], [196, "       .DATA_RATE_TQ(\"SDR\"),     // DDR, BUF, SDR\n"], [196, "       .DATA_WIDTH(8),           // Parallel data width (2-8,10,14)\n"], [196, "       .INIT_OQ(1'b0),           // Initial value of OQ output (1'b0,1'b1)\n"], [196, "       .INIT_TQ(1'b0),           // Initial value of TQ output (1'b0,1'b1)\n"], [196, "       .SERDES_MODE(\"MASTER\"),   // MASTER, SLAVE\n"], [196, "       .SRVAL_OQ(1'b0),          // OQ output value when SR is used (1'b0,1'b1)\n"], [196, "       .SRVAL_TQ(1'b0),          // TQ output value when SR is used (1'b0,1'b1)\n"], [196, "       .TBYTE_CTL(\"FALSE\"),      // Enable tristate byte operation (FALSE, TRUE)\n"], [196, "       .TBYTE_SRC(\"FALSE\"),      // Tristate byte source (FALSE, TRUE)\n"], [196, "       .TRISTATE_WIDTH(1)        // 3-state converter width (1,4)\n"], [201, "        .OFB(),                  // Feedback path for data\n"], [201, "        .OQ(cclk),               // Data path output\n"], [201, "        .SHIFTOUT1(),            \n"], [208, "        .TBYTEOUT(),             // Byte group tristate\n"], [208, "        .TFB(),                  // 1-bit output: 3-state control\n"], [208, "        .TQ(),                   // 3-state control\n"], [208, "        .CLK(cclk_base),         // High speed clock\n"], [208, "        .CLKDIV(cclk_div),       // Divided clock\n"], [208, "        .D1(cclk_pattern[1]),    // Parallel data inputs\n"], [218, "        .OCE(1'b1),             // Output data clock enable TODO: gating?\n"], [218, "        .RST(reset),            // Reset\n"], [218, "        .SHIFTIN1(1'b0),        // Data input expansion (1-bit each)\n"], [220, "        .T1(1'b0),              // Parallel 3-state inputs\n"], [225, "        .TBYTEIN(1'b0),         // Byte group tristate\n"], [225, "        .TCE(1'b0)              // 3-state clock enable\n"], [239, "   end else \n"], [239, "     begin : gen_fixed_cclk // Non-dividable CCLK\n"], [239, "\treg       enb_sync;\n"], [239, "\talways @ (posedge cclk_div)\n"], [239, "\t  enb_sync     <= ecfg_cclk_en;\n"], [239, "\tassign cclk = cclk_base & enb_sync;\n"], [239, "     end   \n"]]}}