{"Source Block": ["oh/asiclib/hdl/asic_csa32.v@15:39@HdlStmIf", "     output [N-1:0] s,   // sum\n     output [N-1:0] c    // carry\n     );\n\n   generate\n      if(SYN == \"TRUE\") begin\n\t assign s[N-1:0] = in0[N-1:0] ^ in1[N-1:0] ^ in2[N-1:0];\n\n\t assign c[N-1:0] = (in0[N-1:0] & in1[N-1:0]) |\n\t\t\t   (in1[N-1:0] & in2[N-1:0]) |\n\t\t\t   (in2[N-1:0] & in0[N-1:0] );\n      end\n      else begin\n\t genvar \t     i;\n\t for (i=0;i<N;i=i+1) begin\n\t    asic_csa32 #(.TYPE(TYPE))\n\t    asic_csa32  (.s(s[i]),\n\t\t\t .c(c[i]),\n\t\t\t .in2(in2[i]),\n\t\t\t .in1(in1[i]),\n\t\t\t .in0(in0[i]));\n\t end\n      end\n   endgenerate\nendmodule\n"], "Clone Blocks": [["oh/common/hdl/oh_csa32.v@16:40", "     output [N-1:0] s,   // sum\n     output [N-1:0] c    // carry\n     );\n\n   generate\n      if(SYN == \"TRUE\") begin\n\t assign s[N-1:0] = in0[N-1:0] ^ in1[N-1:0] ^ in2[N-1:0];\n\n\t assign c[N-1:0] = (in0[N-1:0] & in1[N-1:0]) |\n\t\t\t   (in1[N-1:0] & in2[N-1:0]) |\n\t\t\t   (in2[N-1:0] & in0[N-1:0] );\n      end\n      else begin\n\t genvar \t     i;\n\t for (i=0;i<N;i=i+1) begin\n\t    asic_csa32 #(.TYPE(TYPE))\n\t    asic_csa32  (.s(s[i]),\n\t\t\t .c(c[i]),\n\t\t\t .in2(in2[i]),\n\t\t\t .in1(in1[i]),\n\t\t\t .in0(in0[i]));\n\t end\n      end\n   endgenerate\nendmodule\n"], ["oh/common/hdl/oh_clockmux2.v@17:40", "    input [N-1:0]  clkin1, // clock input\n    output [N-1:0] clkout // clock output\n    );\n\n   generate\n      if(SYN == \"TRUE\") begin\n\t assign clkout[N-1:0] = (en0[N-1:0] & clkin0[N-1:0]) |\n\t\t\t\t(en1[N-1:0] & clkin1);\n      end\n      else begin\n\t genvar \t     i;\n\t for (i=0;i<N;i=i+1) begin\n\t    asic_clockmux2 #(.TYPE(TYPE))\n\t    asic_clockmux2(// Outputs\n\t\t\t   .clkout\t(clkout[N-1:0]),\n\t\t\t   // Inputs\n\t\t\t   .en0\t\t(en0[N-1:0]),\n\t\t\t   .en1\t\t(en1[N-1:0]),\n\t\t\t   .clkin0\t(clkin0[N-1:0]),\n\t\t\t   .clkin1\t(clkin1[N-1:0]));\n\t end\n      end\n   endgenerate\nendmodule\n"]], "Diff Content": {"Delete": [[20, "      if(SYN == \"TRUE\") begin\n"], [21, "\t assign s[N-1:0] = in0[N-1:0] ^ in1[N-1:0] ^ in2[N-1:0];\n"], [23, "\t assign c[N-1:0] = (in0[N-1:0] & in1[N-1:0]) |\n"], [24, "\t\t\t   (in1[N-1:0] & in2[N-1:0]) |\n"], [25, "\t\t\t   (in2[N-1:0] & in0[N-1:0] );\n"], [26, "      end\n"], [27, "      else begin\n"], [28, "\t genvar \t     i;\n"], [29, "\t for (i=0;i<N;i=i+1) begin\n"], [30, "\t    asic_csa32 #(.TYPE(TYPE))\n"], [31, "\t    asic_csa32  (.s(s[i]),\n"], [32, "\t\t\t .c(c[i]),\n"], [33, "\t\t\t .in2(in2[i]),\n"], [34, "\t\t\t .in1(in1[i]),\n"], [35, "\t\t\t .in0(in0[i]));\n"], [36, "\t end\n"], [37, "      end\n"]], "Add": [[21, "   assign s = a ^ b ^ c;\n"], [21, "   assign c = (a & b) | (b & c) | (c & a);\n"]]}}