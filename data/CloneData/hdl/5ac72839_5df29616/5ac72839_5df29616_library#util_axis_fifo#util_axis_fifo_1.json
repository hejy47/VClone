{"Source Block": ["hdl/library/util_axis_fifo/util_axis_fifo.v@55:248@HdlStmIf", "  input [DATA_WIDTH-1:0] s_axis_data,\n  output s_axis_empty,\n  output [ADDRESS_WIDTH:0] s_axis_room\n);\n\ngenerate if (ADDRESS_WIDTH == 0) begin\n\n  reg [DATA_WIDTH-1:0] cdc_sync_fifo_ram;\n  reg s_axis_waddr = 1'b0;\n  reg m_axis_raddr = 1'b0;\n\n  wire m_axis_waddr;\n  wire s_axis_raddr;\n\n  sync_bits #(\n    .NUM_OF_BITS(1),\n    .ASYNC_CLK(ASYNC_CLK)\n  ) i_waddr_sync (\n    .out_clk(m_axis_aclk),\n    .out_resetn(m_axis_aresetn),\n    .in_bits(s_axis_waddr),\n    .out_bits(m_axis_waddr)\n  );\n\n  sync_bits #(\n    .NUM_OF_BITS(1),\n    .ASYNC_CLK(ASYNC_CLK)\n  ) i_raddr_sync (\n    .out_clk(s_axis_aclk),\n    .out_resetn(s_axis_aresetn),\n    .in_bits(m_axis_raddr),\n    .out_bits(s_axis_raddr)\n  );\n\n  assign m_axis_valid = m_axis_raddr != m_axis_waddr;\n  assign m_axis_level = m_axis_valid;\n  assign s_axis_ready = s_axis_raddr == s_axis_waddr;\n  assign s_axis_empty = s_axis_ready;\n  assign s_axis_room = s_axis_ready;\n\n  always @(posedge s_axis_aclk) begin\n    if (s_axis_ready == 1'b1 && s_axis_valid == 1'b1)\n      cdc_sync_fifo_ram <= s_axis_data;\n  end\n\n  always @(posedge s_axis_aclk) begin\n    if (s_axis_aresetn == 1'b0) begin\n      s_axis_waddr <= 1'b0;\n    end else begin\n      if (s_axis_ready & s_axis_valid) begin\n        s_axis_waddr <= s_axis_waddr + 1'b1;\n      end\n    end\n  end\n\n  always @(posedge m_axis_aclk) begin\n    if (m_axis_aresetn == 1'b0) begin\n      m_axis_raddr <= 1'b0;\n    end else begin\n      if (m_axis_valid & m_axis_ready)\n        m_axis_raddr <= m_axis_raddr + 1'b1;\n    end\n  end\n\n  assign m_axis_data = cdc_sync_fifo_ram;\n\nend else begin\n\n  reg [DATA_WIDTH-1:0] ram[0:2**ADDRESS_WIDTH-1];\n\n  wire [ADDRESS_WIDTH-1:0] s_axis_waddr;\n  wire [ADDRESS_WIDTH-1:0] m_axis_raddr;\n  wire _m_axis_ready;\n  wire _m_axis_valid;\n  wire [ADDRESS_WIDTH:0] _m_axis_level;\n\n  wire s_mem_write;\n  wire m_mem_read;\n\n  reg valid;\n\n  always @(posedge m_axis_aclk) begin\n    if (m_axis_aresetn == 1'b0) begin\n      valid <= 1'b0;\n    end else begin\n      if (_m_axis_valid)\n        valid <= 1'b1;\n      else if (m_axis_ready)\n        valid <= 1'b0;\n    end\n  end\n\n  assign s_mem_write = s_axis_ready & s_axis_valid;\n  assign m_mem_read = (~valid || m_axis_ready) && _m_axis_valid;\n\n  if (ASYNC_CLK == 1) begin\n\n    // The assumption is that in this mode the S_AXIS_REGISTERED is 1\n\n    fifo_address_gray_pipelined #(\n      .ADDRESS_WIDTH(ADDRESS_WIDTH)\n    ) i_address_gray (\n      .m_axis_aclk(m_axis_aclk),\n      .m_axis_aresetn(m_axis_aresetn),\n      .m_axis_ready(_m_axis_ready),\n      .m_axis_valid(_m_axis_valid),\n      .m_axis_raddr(m_axis_raddr),\n      .m_axis_level(_m_axis_level),\n\n      .s_axis_aclk(s_axis_aclk),\n      .s_axis_aresetn(s_axis_aresetn),\n      .s_axis_ready(s_axis_ready),\n      .s_axis_valid(s_axis_valid),\n      .s_axis_empty(s_axis_empty),\n      .s_axis_waddr(s_axis_waddr),\n      .s_axis_room(s_axis_room)\n    );\n\n    // When the clocks are asynchronous instantiate a block RAM\n    // regardless of the requested size to make sure we threat the\n    // clock crossing correctly\n    ad_mem #(\n      .DATA_WIDTH (DATA_WIDTH),\n      .ADDRESS_WIDTH (ADDRESS_WIDTH))\n    i_mem (\n      .clka(s_axis_aclk),\n      .wea(s_mem_write),\n      .addra(s_axis_waddr),\n      .dina(s_axis_data),\n      .clkb(m_axis_aclk),\n      .reb(m_mem_read),\n      .addrb(m_axis_raddr),\n      .doutb(m_axis_data)\n    );\n\n    assign _m_axis_ready = ~valid || m_axis_ready;\n    assign m_axis_valid = valid;\n    // the util_axis_fifo is functioning in 'first write fall through' mode,\n    // which means that we need to assure that the value of the level reflects\n    // the actual FIFO level plus the available data, which sits on the bus\n    assign m_axis_level =  (m_axis_valid) ? _m_axis_level + 1'b1 : _m_axis_level;\n\n  end else begin\n\n    fifo_address_sync #(\n      .ADDRESS_WIDTH(ADDRESS_WIDTH)\n    ) i_address_sync (\n      .clk(m_axis_aclk),\n      .resetn(m_axis_aresetn),\n      .m_axis_ready(_m_axis_ready),\n      .m_axis_valid(_m_axis_valid),\n      .m_axis_raddr(m_axis_raddr),\n      .m_axis_level(m_axis_level),\n\n      .s_axis_ready(s_axis_ready),\n      .s_axis_valid(s_axis_valid),\n      .s_axis_empty(s_axis_empty),\n      .s_axis_waddr(s_axis_waddr),\n      .s_axis_room(s_axis_room)\n    );\n\n    // When the clocks are synchronous use behavioral modeling for the SDP RAM\n    // Let the synthesizer decide what to infer (distributed or block RAM)\n    always @(posedge s_axis_aclk) begin\n      if (s_mem_write)\n        ram[s_axis_waddr] <= s_axis_data;\n    end\n\n    if (S_AXIS_REGISTERED == 1) begin\n\n      reg [DATA_WIDTH-1:0] data;\n\n      always @(posedge m_axis_aclk) begin\n        if (m_mem_read)\n          data <= ram[m_axis_raddr];\n      end\n\n      assign _m_axis_ready = ~valid || m_axis_ready;\n      assign m_axis_data = data;\n      assign m_axis_valid = valid;\n\n    end else begin\n\n      assign _m_axis_ready = m_axis_ready;\n      assign m_axis_valid = _m_axis_valid;\n      assign m_axis_data = ram[m_axis_raddr];\n\n    end\n\n  end\n\nend endgenerate\n\nendmodule\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[60, "generate if (ADDRESS_WIDTH == 0) begin\n"], [62, "  reg [DATA_WIDTH-1:0] cdc_sync_fifo_ram;\n"], [63, "  reg s_axis_waddr = 1'b0;\n"], [64, "  reg m_axis_raddr = 1'b0;\n"], [66, "  wire m_axis_waddr;\n"], [67, "  wire s_axis_raddr;\n"], [69, "  sync_bits #(\n"], [70, "    .NUM_OF_BITS(1),\n"], [71, "    .ASYNC_CLK(ASYNC_CLK)\n"], [72, "  ) i_waddr_sync (\n"], [73, "    .out_clk(m_axis_aclk),\n"], [74, "    .out_resetn(m_axis_aresetn),\n"], [75, "    .in_bits(s_axis_waddr),\n"], [76, "    .out_bits(m_axis_waddr)\n"], [77, "  );\n"], [79, "  sync_bits #(\n"], [80, "    .NUM_OF_BITS(1),\n"], [81, "    .ASYNC_CLK(ASYNC_CLK)\n"], [82, "  ) i_raddr_sync (\n"], [83, "    .out_clk(s_axis_aclk),\n"], [84, "    .out_resetn(s_axis_aresetn),\n"], [85, "    .in_bits(m_axis_raddr),\n"], [86, "    .out_bits(s_axis_raddr)\n"], [87, "  );\n"], [89, "  assign m_axis_valid = m_axis_raddr != m_axis_waddr;\n"], [90, "  assign m_axis_level = m_axis_valid;\n"], [91, "  assign s_axis_ready = s_axis_raddr == s_axis_waddr;\n"], [92, "  assign s_axis_empty = s_axis_ready;\n"], [93, "  assign s_axis_room = s_axis_ready;\n"], [95, "  always @(posedge s_axis_aclk) begin\n"], [96, "    if (s_axis_ready == 1'b1 && s_axis_valid == 1'b1)\n"], [97, "      cdc_sync_fifo_ram <= s_axis_data;\n"], [98, "  end\n"], [100, "  always @(posedge s_axis_aclk) begin\n"], [101, "    if (s_axis_aresetn == 1'b0) begin\n"], [102, "      s_axis_waddr <= 1'b0;\n"], [103, "    end else begin\n"], [104, "      if (s_axis_ready & s_axis_valid) begin\n"], [105, "        s_axis_waddr <= s_axis_waddr + 1'b1;\n"], [108, "  end\n"], [110, "  always @(posedge m_axis_aclk) begin\n"], [111, "    if (m_axis_aresetn == 1'b0) begin\n"], [112, "      m_axis_raddr <= 1'b0;\n"], [113, "    end else begin\n"], [114, "      if (m_axis_valid & m_axis_ready)\n"], [115, "        m_axis_raddr <= m_axis_raddr + 1'b1;\n"], [116, "    end\n"], [117, "  end\n"], [119, "  assign m_axis_data = cdc_sync_fifo_ram;\n"], [121, "end else begin\n"], [123, "  reg [DATA_WIDTH-1:0] ram[0:2**ADDRESS_WIDTH-1];\n"], [129, "  wire [ADDRESS_WIDTH:0] _m_axis_level;\n"], [134, "  reg valid;\n"], [150, "  if (ASYNC_CLK == 1) begin\n"], [154, "    fifo_address_gray_pipelined #(\n"], [155, "      .ADDRESS_WIDTH(ADDRESS_WIDTH)\n"], [156, "    ) i_address_gray (\n"], [157, "      .m_axis_aclk(m_axis_aclk),\n"], [158, "      .m_axis_aresetn(m_axis_aresetn),\n"], [159, "      .m_axis_ready(_m_axis_ready),\n"], [160, "      .m_axis_valid(_m_axis_valid),\n"], [161, "      .m_axis_raddr(m_axis_raddr),\n"], [162, "      .m_axis_level(_m_axis_level),\n"], [164, "      .s_axis_aclk(s_axis_aclk),\n"], [165, "      .s_axis_aresetn(s_axis_aresetn),\n"], [166, "      .s_axis_ready(s_axis_ready),\n"], [167, "      .s_axis_valid(s_axis_valid),\n"], [168, "      .s_axis_empty(s_axis_empty),\n"], [169, "      .s_axis_waddr(s_axis_waddr),\n"], [170, "      .s_axis_room(s_axis_room)\n"], [171, "    );\n"], [195, "    assign m_axis_level =  (m_axis_valid) ? _m_axis_level + 1'b1 : _m_axis_level;\n"], [197, "  end else begin\n"], [199, "    fifo_address_sync #(\n"], [200, "      .ADDRESS_WIDTH(ADDRESS_WIDTH)\n"], [201, "    ) i_address_sync (\n"], [202, "      .clk(m_axis_aclk),\n"], [203, "      .resetn(m_axis_aresetn),\n"], [204, "      .m_axis_ready(_m_axis_ready),\n"], [205, "      .m_axis_valid(_m_axis_valid),\n"], [206, "      .m_axis_raddr(m_axis_raddr),\n"], [207, "      .m_axis_level(m_axis_level),\n"], [209, "      .s_axis_ready(s_axis_ready),\n"], [210, "      .s_axis_valid(s_axis_valid),\n"], [211, "      .s_axis_empty(s_axis_empty),\n"], [212, "      .s_axis_waddr(s_axis_waddr),\n"], [213, "      .s_axis_room(s_axis_room)\n"], [214, "    );\n"], [223, "    if (S_AXIS_REGISTERED == 1) begin\n"], [246, "end endgenerate\n"]], "Add": [[64, "generate if (ADDRESS_WIDTH == 0) begin : zerodeep /* it's not a real FIFO, just a 1 stage pipeline */\n"], [64, "  if (ASYNC_CLK) begin\n"], [64, "      reg [DATA_WIDTH-1:0] cdc_sync_fifo_ram;\n"], [64, "      reg s_axis_waddr = 1'b0;\n"], [64, "      reg m_axis_raddr = 1'b0;\n"], [64, "      wire m_axis_waddr;\n"], [64, "      wire s_axis_raddr;\n"], [64, "      sync_bits #(\n"], [64, "        .NUM_OF_BITS(1),\n"], [64, "        .ASYNC_CLK(ASYNC_CLK)\n"], [64, "      ) i_waddr_sync (\n"], [64, "        .out_clk(m_axis_aclk),\n"], [64, "        .out_resetn(m_axis_aresetn),\n"], [64, "        .in_bits(s_axis_waddr),\n"], [64, "        .out_bits(m_axis_waddr)\n"], [64, "      );\n"], [64, "      sync_bits #(\n"], [64, "        .NUM_OF_BITS(1),\n"], [64, "        .ASYNC_CLK(ASYNC_CLK)\n"], [64, "      ) i_raddr_sync (\n"], [64, "        .out_clk(s_axis_aclk),\n"], [64, "        .out_resetn(s_axis_aresetn),\n"], [64, "        .in_bits(m_axis_raddr),\n"], [64, "        .out_bits(s_axis_raddr)\n"], [64, "      );\n"], [64, "      assign m_axis_valid = m_axis_raddr != m_axis_waddr;\n"], [64, "      assign m_axis_level = ~m_axis_ready;\n"], [64, "      assign s_axis_ready = s_axis_raddr == s_axis_waddr;\n"], [64, "      assign s_axis_empty = ~s_axis_valid;\n"], [64, "      assign s_axis_room = s_axis_ready;\n"], [64, "      always @(posedge s_axis_aclk) begin\n"], [64, "        if (s_axis_ready == 1'b1 && s_axis_valid == 1'b1)\n"], [64, "          cdc_sync_fifo_ram <= s_axis_data;\n"], [64, "      end\n"], [67, "      always @(posedge s_axis_aclk) begin\n"], [67, "        if (s_axis_aresetn == 1'b0) begin\n"], [67, "          s_axis_waddr <= 1'b0;\n"], [67, "        end else if (s_axis_ready & s_axis_valid) begin\n"], [67, "          s_axis_waddr <= s_axis_waddr + 1'b1;\n"], [67, "        end\n"], [67, "      end\n"], [77, "      always @(posedge m_axis_aclk) begin\n"], [77, "        if (m_axis_aresetn == 1'b0) begin\n"], [77, "          m_axis_raddr <= 1'b0;\n"], [77, "        end else begin\n"], [77, "        if (m_axis_valid & m_axis_ready)\n"], [77, "          m_axis_raddr <= m_axis_raddr + 1'b1;\n"], [77, "        end\n"], [77, "      end\n"], [87, "      assign m_axis_data = cdc_sync_fifo_ram;\n"], [93, "  end else begin /* !ASYNC_CLK */\n"], [98, "    reg [DATA_WIDTH-1:0] axis_data_d;\n"], [98, "    reg                  axis_valid_d;\n"], [105, "    always @(posedge s_axis_aclk) begin\n"], [105, "      if (!s_axis_aresetn) begin\n"], [105, "        axis_data_d <= {DATA_WIDTH{1'b0}};\n"], [105, "        axis_valid_d <= 1'b0;\n"], [105, "      end else if (s_axis_ready) begin\n"], [105, "        axis_data_d <= s_axis_data;\n"], [105, "        axis_valid_d <= s_axis_valid;\n"], [119, "    assign m_axis_data = axis_data_d;\n"], [119, "    assign m_axis_valid = axis_valid_d;\n"], [119, "    assign s_axis_ready = m_axis_ready | ~m_axis_valid;\n"], [119, "    assign m_axis_empty = 1'b0;\n"], [119, "    assign m_axis_level = 1'b0;\n"], [119, "    assign s_axis_full  = 1'b0;\n"], [119, "    assign s_axis_room  = 1'b0;\n"], [121, "  end\n"], [123, "end else begin : fifo /* ADDRESS_WIDTH != 0 - this is a real FIFO implementation */\n"], [134, "  reg valid = 1'b0;\n"], [134, "  /* Control for first falls through */\n"], [171, "  util_axis_fifo_address_generator #(\n"], [171, "    .ASYNC_CLK(ASYNC_CLK),\n"], [171, "    .ADDRESS_WIDTH(ADDRESS_WIDTH))\n"], [171, "  i_address_gray (\n"], [171, "    .m_axis_aclk(m_axis_aclk),\n"], [171, "    .m_axis_aresetn(m_axis_aresetn),\n"], [171, "    .m_axis_ready(_m_axis_ready),\n"], [171, "    .m_axis_valid(_m_axis_valid),\n"], [171, "    .m_axis_raddr(m_axis_raddr),\n"], [171, "    .m_axis_level(m_axis_level),\n"], [171, "    .m_axis_empty(m_axis_empty),\n"], [171, "    .s_axis_aclk(s_axis_aclk),\n"], [171, "    .s_axis_aresetn(s_axis_aresetn),\n"], [171, "    .s_axis_ready(s_axis_ready),\n"], [171, "    .s_axis_valid(s_axis_valid),\n"], [171, "    .s_axis_full(s_axis_full),\n"], [171, "    .s_axis_waddr(s_axis_waddr),\n"], [171, "    .s_axis_room(s_axis_room)\n"], [171, "  );\n"], [171, "  if (ASYNC_CLK == 1) begin : async_clocks /* Asynchronous WRITE/READ clocks */\n"], [214, "  end else begin : sync_clocks /* Synchronous WRITE/READ clocks */\n"], [214, "    reg [DATA_WIDTH-1:0] ram[0:2**ADDRESS_WIDTH-1];\n"], [223, "    if (M_AXIS_REGISTERED == 1) begin\n"], [246, "end /* fifo */\n"], [246, "endgenerate\n"]]}}