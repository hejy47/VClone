{"Source Block": ["hdl/library/axi_ad5766/axi_ad5766.v@161:234@HdlStmIf", "  assign sdo_data = sdo_mem[spi_sdo_rd_addr];\n  assign sync_ready = 1'b1;\n\n  assign sdi_data_ready = 1'b0;\n\n  generate if (ASYNC_SPI_CLK) begin\n\n    /*\n     * The synchronization circuit takes care that there are no glitches on the\n     * ctrl_enabled signal. ctrl_do_enable is asserted whenever ctrl_enable is\n     * asserted, but only deasserted once the signal has been synchronized back from\n     * the SPI domain. This makes sure that we can't end up in a state where the\n     * enable signal in the SPI domain is asserted, but neither enable nor enabled\n     * is asserted in the control domain.\n     */\n\n    reg ctrl_do_enable = 1'b0;\n    wire ctrl_is_enabled;\n    reg spi_enabled = 1'b0;\n\n    always @(posedge ctrl_clk) begin\n        if (ctrl_enable == 1'b1) begin\n                ctrl_do_enable <= 1'b1;\n        end else if (ctrl_is_enabled == 1'b1) begin\n                ctrl_do_enable <= 1'b0;\n        end\n    end\n\n    assign ctrl_enabled = ctrl_is_enabled | ctrl_do_enable;\n\n    always @(posedge spi_clk) begin\n        spi_enabled <= spi_enable_s | spi_active;\n    end\n\n    sync_bits # (\n        .NUM_OF_BITS(1),\n        .ASYNC_CLK(1)\n    ) i_sync_enable (\n        .in_bits(ctrl_do_enable),\n        .out_clk(spi_clk),\n        .out_resetn(1'b1),\n        .out_bits(spi_enable_s)\n    );\n\n    sync_bits # (\n        .NUM_OF_BITS(1),\n        .ASYNC_CLK(1)\n    ) i_sync_enabled (\n        .in_bits(spi_enabled),\n        .out_clk(ctrl_clk),\n        .out_resetn(1'b1),\n        .out_bits(ctrl_is_enabled)\n    );\n\n    sync_bits # (\n        .NUM_OF_BITS(1),\n        .ASYNC_CLK(1)\n    ) i_sync_mem_reset (\n        .in_bits(ctrl_mem_reset),\n        .out_clk(spi_clk),\n        .out_resetn(1'b1),\n        .out_bits(spi_mem_reset_s)\n    );\n\n  end else begin\n    assign spi_enable_s = ctrl_enable;\n    assign ctrl_enabled = spi_enable_s | spi_active;\n    assign spi_mem_reset_s = ctrl_mem_reset;\n  end endgenerate\n\n  assign spi_cmd_rd_addr_next = spi_cmd_rd_addr + 1;\n\n  always @(posedge spi_clk) begin\n    if (spi_resetn == 1'b0) begin\n"], "Clone Blocks": [["hdl/library/spi_engine/spi_engine_offload/spi_engine_offload.v@182:244", "\nassign status_sync_data = sync_data;\nassign status_sync_valid = sync_valid;\nassign sync_ready = status_sync_ready;\n\ngenerate if (ASYNC_SPI_CLK) begin\n\n/*\n * The synchronization circuit takes care that there are no glitches on the\n * ctrl_enabled signal. ctrl_do_enable is asserted whenever ctrl_enable is\n * asserted, but only deasserted once the signal has been synchronized back from\n * the SPI domain. This makes sure that we can't end up in a state where the\n * enable signal in the SPI domain is asserted, but neither enable nor enabled\n * is asserted in the control domain.\n */\n\nreg ctrl_do_enable = 1'b0;\nwire ctrl_is_enabled;\nreg spi_enabled = 1'b0;\n\nalways @(posedge ctrl_clk) begin\n  if (ctrl_enable == 1'b1) begin\n    ctrl_do_enable <= 1'b1;\n  end else if (ctrl_is_enabled == 1'b1) begin\n    ctrl_do_enable <= 1'b0;\n  end\nend\n\nassign ctrl_enabled = ctrl_is_enabled | ctrl_do_enable;\n\nalways @(posedge spi_clk) begin\n  spi_enabled <= spi_enable | spi_active;\nend\n\nsync_bits # (\n    .NUM_OF_BITS(1),\n    .ASYNC_CLK(1)\n) i_sync_enable (\n    .in_bits(ctrl_do_enable),\n    .out_clk(spi_clk),\n    .out_resetn(1'b1),\n    .out_bits(spi_enable)\n);\n\nsync_bits # (\n    .NUM_OF_BITS(1),\n    .ASYNC_CLK(1)\n) i_sync_enabled (\n    .in_bits(spi_enabled),\n    .out_clk(ctrl_clk),\n    .out_resetn(1'b1),\n    .out_bits(ctrl_is_enabled)\n);\n\nend else begin\nassign spi_enable = ctrl_enable;\nassign ctrl_enabled = spi_enable | spi_active;\nend endgenerate\n\nassign spi_cmd_rd_addr_next = spi_cmd_rd_addr + 1;\n\nwire trigger_s;\nsync_bits #(\n"]], "Diff Content": {"Delete": [[195, "    sync_bits # (\n"], [196, "        .NUM_OF_BITS(1),\n"], [197, "        .ASYNC_CLK(1)\n"], [199, "        .in_bits(ctrl_do_enable),\n"], [200, "        .out_clk(spi_clk),\n"], [201, "        .out_resetn(1'b1),\n"], [202, "        .out_bits(spi_enable_s)\n"], [203, "    );\n"], [205, "    sync_bits # (\n"], [206, "        .NUM_OF_BITS(1),\n"], [207, "        .ASYNC_CLK(1)\n"], [209, "        .in_bits(spi_enabled),\n"], [210, "        .out_clk(ctrl_clk),\n"], [211, "        .out_resetn(1'b1),\n"], [212, "        .out_bits(ctrl_is_enabled)\n"], [213, "    );\n"], [215, "    sync_bits # (\n"], [216, "        .NUM_OF_BITS(1),\n"], [217, "        .ASYNC_CLK(1)\n"], [219, "        .in_bits(ctrl_mem_reset),\n"], [220, "        .out_clk(spi_clk),\n"], [221, "        .out_resetn(1'b1),\n"], [222, "        .out_bits(spi_mem_reset_s)\n"], [223, "    );\n"]], "Add": [[197, "    sync_bits #(\n"], [197, "      .NUM_OF_BITS(1),\n"], [197, "      .ASYNC_CLK(1)\n"], [207, "      .in_bits(ctrl_do_enable),\n"], [207, "      .out_clk(spi_clk),\n"], [207, "      .out_resetn(1'b1),\n"], [207, "      .out_bits(spi_enable_s));\n"], [207, "    sync_bits #(\n"], [207, "      .NUM_OF_BITS(1),\n"], [207, "      .ASYNC_CLK(1)\n"], [217, "      .in_bits(spi_enabled),\n"], [217, "      .out_clk(ctrl_clk),\n"], [217, "      .out_resetn(1'b1),\n"], [217, "      .out_bits(ctrl_is_enabled));\n"], [217, "    sync_bits #(\n"], [217, "      .NUM_OF_BITS(1),\n"], [217, "      .ASYNC_CLK(1)\n"], [223, "      .in_bits(ctrl_mem_reset),\n"], [223, "      .out_clk(spi_clk),\n"], [223, "      .out_resetn(1'b1),\n"], [223, "      .out_bits(spi_mem_reset_s));\n"]]}}