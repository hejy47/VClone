{"Source Block": ["hdl/library/util_axis_fifo/util_axis_fifo.v@74:363@HdlStmIf", "                                              (DATA_WIDTH);\n\nwire [MEM_WORD-1:0] s_axis_data_int_s;\nwire [MEM_WORD-1:0] m_axis_data_int_s;\n\ngenerate if (ADDRESS_WIDTH == 0) begin : zerodeep /* it's not a real FIFO, just a 1 stage pipeline */\n\n  if (ASYNC_CLK) begin\n\n      (* KEEP = \"yes\" *) reg [DATA_WIDTH-1:0] cdc_sync_fifo_ram;\n      reg s_axis_waddr = 1'b0;\n      reg m_axis_raddr = 1'b0;\n\n      wire m_axis_waddr;\n      wire s_axis_raddr;\n\n      sync_bits #(\n        .NUM_OF_BITS(1),\n        .ASYNC_CLK(ASYNC_CLK)\n      ) i_waddr_sync (\n        .out_clk(m_axis_aclk),\n        .out_resetn(m_axis_aresetn),\n        .in_bits(s_axis_waddr),\n        .out_bits(m_axis_waddr)\n      );\n\n      sync_bits #(\n        .NUM_OF_BITS(1),\n        .ASYNC_CLK(ASYNC_CLK)\n      ) i_raddr_sync (\n        .out_clk(s_axis_aclk),\n        .out_resetn(s_axis_aresetn),\n        .in_bits(m_axis_raddr),\n        .out_bits(s_axis_raddr)\n      );\n\n      assign m_axis_valid = m_axis_raddr != m_axis_waddr;\n      assign m_axis_level = ~m_axis_ready;\n      assign m_axis_empty = 0;\n      assign m_axis_almost_empty = 0;\n      assign s_axis_ready = s_axis_raddr == s_axis_waddr;\n      assign s_axis_full = 0;\n      assign s_axis_almost_full = 0;\n      assign s_axis_room = s_axis_ready;\n\n      always @(posedge s_axis_aclk) begin\n        if (s_axis_ready == 1'b1 && s_axis_valid == 1'b1)\n          cdc_sync_fifo_ram <= s_axis_data;\n      end\n\n      always @(posedge s_axis_aclk) begin\n        if (s_axis_aresetn == 1'b0) begin\n          s_axis_waddr <= 1'b0;\n        end else if (s_axis_ready & s_axis_valid) begin\n          s_axis_waddr <= s_axis_waddr + 1'b1;\n        end\n      end\n\n      always @(posedge m_axis_aclk) begin\n        if (m_axis_aresetn == 1'b0) begin\n          m_axis_raddr <= 1'b0;\n        end else begin\n        if (m_axis_valid & m_axis_ready)\n          m_axis_raddr <= m_axis_raddr + 1'b1;\n        end\n      end\n\n      assign m_axis_data = cdc_sync_fifo_ram;\n\n      // TLAST support\n      if (TLAST_EN) begin\n\n        reg axis_tlast_d;\n\n        always @(posedge s_axis_aclk) begin\n          if (s_axis_ready == 1'b1 && s_axis_valid == 1'b1)\n            axis_tlast_d <= s_axis_tlast;\n        end\n        assign m_axis_tlast = axis_tlast_d;\n\n      end\n\n      // TKEEP support\n      if (TKEEP_EN) begin\n\n        reg axis_tkeep_d;\n\n        always @(posedge s_axis_aclk) begin\n          if (s_axis_ready == 1'b1 && s_axis_valid == 1'b1)\n            axis_tkeep_d <= s_axis_tkeep;\n        end\n        assign m_axis_tkeep = axis_tkeep_d;\n\n      end\n\n\n  end /* zerodeep */\n  else\n  begin /* !ASYNC_CLK */\n\n    // Note: In this mode, the write and read interface must have a symmetric\n    // aspect ratio\n    reg [DATA_WIDTH-1:0] axis_data_d;\n    reg                  axis_valid_d;\n\n    always @(posedge s_axis_aclk) begin\n      if (!s_axis_aresetn) begin\n        axis_data_d <= {DATA_WIDTH{1'b0}};\n        axis_valid_d <= 1'b0;\n      end else if (s_axis_ready) begin\n        axis_data_d <= s_axis_data;\n        axis_valid_d <= s_axis_valid;\n      end\n    end\n\n    assign m_axis_data = axis_data_d;\n    assign m_axis_valid = axis_valid_d;\n    assign s_axis_ready = m_axis_ready | ~m_axis_valid;\n    assign m_axis_empty = 1'b0;\n    assign m_axis_almost_empty = 1'b0;\n    assign m_axis_level = 1'b0;\n    assign s_axis_full  = 1'b0;\n    assign s_axis_almost_full  = 1'b0;\n    assign s_axis_room  = 1'b0;\n\n    // TLAST support\n    if (TLAST_EN) begin\n      reg  axis_tlast_d;\n\n      always @(posedge s_axis_aclk) begin\n        if (!s_axis_aresetn) begin\n          axis_tlast_d <= 1'b0;\n        end else if (s_axis_ready) begin\n          axis_tlast_d <= s_axis_tlast;\n        end\n      end\n      assign m_axis_tlast = axis_tlast_d;\n    end\n\n    // TKEEP support\n    if (TKEEP_EN) begin\n      reg  axis_tkeep_d;\n\n      always @(posedge s_axis_aclk) begin\n        if (!s_axis_aresetn) begin\n          axis_tkeep_d <= 1'b0;\n        end else if (s_axis_ready) begin\n          axis_tkeep_d <= s_axis_tkeep;\n        end\n      end\n      assign m_axis_tkeep = axis_tkeep_d;\n\n    end\n\n   end /* !ASYNC_CLK */\n\nend else begin : fifo /* ADDRESS_WIDTH != 0 - this is a real FIFO implementation */\n\n  wire [ADDRESS_WIDTH-1:0] s_axis_waddr;\n  wire [ADDRESS_WIDTH-1:0] m_axis_raddr;\n  wire _m_axis_ready;\n  wire _m_axis_valid;\n\n  wire s_mem_write;\n  wire m_mem_read;\n\n  reg valid = 1'b0;\n\n  /* Control for first falls through */\n  always @(posedge m_axis_aclk) begin\n    if (m_axis_aresetn == 1'b0) begin\n      valid <= 1'b0;\n    end else begin\n      if (_m_axis_valid)\n        valid <= 1'b1;\n      else if (m_axis_ready)\n        valid <= 1'b0;\n    end\n  end\n\n  if (REMOVE_NULL_BEAT_EN) begin\n    // remove NULL bytes from the stream - NOTE: TKEEP is all-LOW or all-HIGH\n    assign s_mem_write = s_axis_ready & s_axis_valid & (&s_axis_tkeep);\n  end else begin\n    assign s_mem_write = s_axis_ready & s_axis_valid;\n  end\n  assign m_mem_read = (~valid || m_axis_ready) && _m_axis_valid;\n\n  util_axis_fifo_address_generator #(\n    .ASYNC_CLK(ASYNC_CLK),\n    .ADDRESS_WIDTH(ADDRESS_WIDTH),\n    .ALMOST_EMPTY_THRESHOLD (ALMOST_EMPTY_THRESHOLD),\n    .ALMOST_FULL_THRESHOLD (ALMOST_FULL_THRESHOLD))\n  i_address_gray (\n    .m_axis_aclk(m_axis_aclk),\n    .m_axis_aresetn(m_axis_aresetn),\n    .m_axis_ready(_m_axis_ready),\n    .m_axis_valid(_m_axis_valid),\n    .m_axis_raddr(m_axis_raddr),\n    .m_axis_level(m_axis_level),\n    .m_axis_empty(m_axis_empty),\n    .m_axis_almost_empty(m_axis_almost_empty),\n    .s_axis_aclk(s_axis_aclk),\n    .s_axis_aresetn(s_axis_aresetn),\n    .s_axis_ready(s_axis_ready),\n    .s_axis_valid(s_axis_valid),\n    .s_axis_full(s_axis_full),\n    .s_axis_almost_full(s_axis_almost_full),\n    .s_axis_waddr(s_axis_waddr),\n    .s_axis_room(s_axis_room)\n  );\n\n  // TLAST and TKEEP support\n  if (TLAST_EN & TKEEP_EN) begin\n    assign s_axis_data_int_s = {s_axis_tkeep, s_axis_tlast, s_axis_data};\n    assign m_axis_tkeep = m_axis_data_int_s[MEM_WORD-1-:DATA_WIDTH/8];\n    assign m_axis_tlast = m_axis_data_int_s[DATA_WIDTH];\n    assign m_axis_data = m_axis_data_int_s[DATA_WIDTH-1:0];\n  end else if (TKEEP_EN) begin\n    assign s_axis_data_int_s = {s_axis_tkeep, s_axis_data};\n    assign m_axis_tkeep = m_axis_data_int_s[MEM_WORD-1-:DATA_WIDTH/8];\n    assign m_axis_data = m_axis_data_int_s[DATA_WIDTH-1:0];\n  end else if (TLAST_EN) begin\n    assign s_axis_data_int_s = {s_axis_tlast, s_axis_data};\n    assign m_axis_tlast = m_axis_data_int_s[DATA_WIDTH];\n    assign m_axis_data = m_axis_data_int_s[DATA_WIDTH-1:0];\n  end else begin\n    assign s_axis_data_int_s = {s_axis_data};\n    assign m_axis_data = m_axis_data_int_s[DATA_WIDTH-1:0];\n  end\n\n  if (ASYNC_CLK == 1) begin : async_clocks /* Asynchronous WRITE/READ clocks */\n\n    // The assumption is that in this mode the M_AXIS_REGISTERED is 1\n    // When the clocks are asynchronous instantiate a block RAM\n    // regardless of the requested size to make sure we threat the\n    // clock crossing correctly\n    ad_mem #(\n      .DATA_WIDTH (MEM_WORD),\n      .ADDRESS_WIDTH (ADDRESS_WIDTH))\n    i_mem (\n      .clka(s_axis_aclk),\n      .wea(s_mem_write),\n      .addra(s_axis_waddr),\n      .dina(s_axis_data_int_s),\n      .clkb(m_axis_aclk),\n      .reb(m_mem_read),\n      .addrb(m_axis_raddr),\n      .doutb(m_axis_data_int_s)\n    );\n\n    assign _m_axis_ready = ~valid || m_axis_ready;\n    assign m_axis_valid = valid;\n\n  end else begin : sync_clocks /* Synchronous WRITE/READ clocks */\n\n    reg [MEM_WORD-1:0] ram[0:2**ADDRESS_WIDTH-1];\n\n    // When the clocks are synchronous use behavioral modeling for the SDP RAM\n    // Let the synthesizer decide what to infer (distributed or block RAM)\n    always @(posedge s_axis_aclk) begin\n      if (s_mem_write)\n        ram[s_axis_waddr] <= s_axis_data_int_s;\n    end\n\n    if (M_AXIS_REGISTERED == 1) begin\n\n      reg [MEM_WORD-1:0] data;\n\n      always @(posedge m_axis_aclk) begin\n        if (m_mem_read)\n          data <= ram[m_axis_raddr];\n      end\n\n      assign _m_axis_ready = ~valid || m_axis_ready;\n      assign m_axis_data_int_s = data;\n      assign m_axis_valid = valid;\n\n    end else begin\n\n      assign _m_axis_ready = m_axis_ready;\n      assign m_axis_valid = _m_axis_valid;\n      assign m_axis_data_int_s = ram[m_axis_raddr];\n\n    end\n  end\nend /* fifo */\nendgenerate\n\nendmodule\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[79, "generate if (ADDRESS_WIDTH == 0) begin : zerodeep /* it's not a real FIFO, just a 1 stage pipeline */\n"], [81, "  if (ASYNC_CLK) begin\n"], [83, "      (* KEEP = \"yes\" *) reg [DATA_WIDTH-1:0] cdc_sync_fifo_ram;\n"], [84, "      reg s_axis_waddr = 1'b0;\n"], [85, "      reg m_axis_raddr = 1'b0;\n"], [87, "      wire m_axis_waddr;\n"], [88, "      wire s_axis_raddr;\n"], [90, "      sync_bits #(\n"], [91, "        .NUM_OF_BITS(1),\n"], [92, "        .ASYNC_CLK(ASYNC_CLK)\n"], [93, "      ) i_waddr_sync (\n"], [94, "        .out_clk(m_axis_aclk),\n"], [95, "        .out_resetn(m_axis_aresetn),\n"], [96, "        .in_bits(s_axis_waddr),\n"], [97, "        .out_bits(m_axis_waddr)\n"], [98, "      );\n"], [100, "      sync_bits #(\n"], [101, "        .NUM_OF_BITS(1),\n"], [102, "        .ASYNC_CLK(ASYNC_CLK)\n"], [103, "      ) i_raddr_sync (\n"], [104, "        .out_clk(s_axis_aclk),\n"], [105, "        .out_resetn(s_axis_aresetn),\n"], [106, "        .in_bits(m_axis_raddr),\n"], [107, "        .out_bits(s_axis_raddr)\n"], [108, "      );\n"], [110, "      assign m_axis_valid = m_axis_raddr != m_axis_waddr;\n"], [111, "      assign m_axis_level = ~m_axis_ready;\n"], [112, "      assign m_axis_empty = 0;\n"], [113, "      assign m_axis_almost_empty = 0;\n"], [114, "      assign s_axis_ready = s_axis_raddr == s_axis_waddr;\n"], [115, "      assign s_axis_full = 0;\n"], [116, "      assign s_axis_almost_full = 0;\n"], [117, "      assign s_axis_room = s_axis_ready;\n"], [119, "      always @(posedge s_axis_aclk) begin\n"], [120, "        if (s_axis_ready == 1'b1 && s_axis_valid == 1'b1)\n"], [121, "          cdc_sync_fifo_ram <= s_axis_data;\n"], [122, "      end\n"], [124, "      always @(posedge s_axis_aclk) begin\n"], [125, "        if (s_axis_aresetn == 1'b0) begin\n"], [126, "          s_axis_waddr <= 1'b0;\n"], [127, "        end else if (s_axis_ready & s_axis_valid) begin\n"], [128, "          s_axis_waddr <= s_axis_waddr + 1'b1;\n"], [130, "      end\n"], [132, "      always @(posedge m_axis_aclk) begin\n"], [133, "        if (m_axis_aresetn == 1'b0) begin\n"], [134, "          m_axis_raddr <= 1'b0;\n"], [135, "        end else begin\n"], [136, "        if (m_axis_valid & m_axis_ready)\n"], [137, "          m_axis_raddr <= m_axis_raddr + 1'b1;\n"], [141, "      assign m_axis_data = cdc_sync_fifo_ram;\n"], [146, "        reg axis_tlast_d;\n"], [149, "          if (s_axis_ready == 1'b1 && s_axis_valid == 1'b1)\n"], [159, "        reg axis_tkeep_d;\n"], [162, "          if (s_axis_ready == 1'b1 && s_axis_valid == 1'b1)\n"], [170, "  end /* zerodeep */\n"], [171, "  else\n"], [172, "  begin /* !ASYNC_CLK */\n"], [176, "    reg [DATA_WIDTH-1:0] axis_data_d;\n"], [177, "    reg                  axis_valid_d;\n"], [179, "    always @(posedge s_axis_aclk) begin\n"], [180, "      if (!s_axis_aresetn) begin\n"], [181, "        axis_data_d <= {DATA_WIDTH{1'b0}};\n"], [182, "        axis_valid_d <= 1'b0;\n"], [183, "      end else if (s_axis_ready) begin\n"], [184, "        axis_data_d <= s_axis_data;\n"], [185, "        axis_valid_d <= s_axis_valid;\n"], [186, "      end\n"], [187, "    end\n"], [189, "    assign m_axis_data = axis_data_d;\n"], [190, "    assign m_axis_valid = axis_valid_d;\n"], [191, "    assign s_axis_ready = m_axis_ready | ~m_axis_valid;\n"], [192, "    assign m_axis_empty = 1'b0;\n"], [193, "    assign m_axis_almost_empty = 1'b0;\n"], [194, "    assign m_axis_level = 1'b0;\n"], [195, "    assign s_axis_full  = 1'b0;\n"], [196, "    assign s_axis_almost_full  = 1'b0;\n"], [197, "    assign s_axis_room  = 1'b0;\n"], [200, "    if (TLAST_EN) begin\n"], [201, "      reg  axis_tlast_d;\n"], [203, "      always @(posedge s_axis_aclk) begin\n"], [204, "        if (!s_axis_aresetn) begin\n"], [205, "          axis_tlast_d <= 1'b0;\n"], [206, "        end else if (s_axis_ready) begin\n"], [207, "          axis_tlast_d <= s_axis_tlast;\n"], [208, "        end\n"], [210, "      assign m_axis_tlast = axis_tlast_d;\n"], [214, "    if (TKEEP_EN) begin\n"], [215, "      reg  axis_tkeep_d;\n"], [217, "      always @(posedge s_axis_aclk) begin\n"], [218, "        if (!s_axis_aresetn) begin\n"], [219, "          axis_tkeep_d <= 1'b0;\n"], [220, "        end else if (s_axis_ready) begin\n"], [221, "          axis_tkeep_d <= s_axis_tkeep;\n"], [222, "        end\n"], [223, "      end\n"], [224, "      assign m_axis_tkeep = axis_tkeep_d;\n"], [228, "   end /* !ASYNC_CLK */\n"], [230, "end else begin : fifo /* ADDRESS_WIDTH != 0 - this is a real FIFO implementation */\n"], [232, "  wire [ADDRESS_WIDTH-1:0] s_axis_waddr;\n"], [233, "  wire [ADDRESS_WIDTH-1:0] m_axis_raddr;\n"], [234, "  wire _m_axis_ready;\n"], [235, "  wire _m_axis_valid;\n"], [237, "  wire s_mem_write;\n"], [238, "  wire m_mem_read;\n"], [240, "  reg valid = 1'b0;\n"], [242, "  /* Control for first falls through */\n"], [243, "  always @(posedge m_axis_aclk) begin\n"], [244, "    if (m_axis_aresetn == 1'b0) begin\n"], [245, "      valid <= 1'b0;\n"], [246, "    end else begin\n"], [247, "      if (_m_axis_valid)\n"], [248, "        valid <= 1'b1;\n"], [249, "      else if (m_axis_ready)\n"], [250, "        valid <= 1'b0;\n"], [251, "    end\n"], [252, "  end\n"], [254, "  if (REMOVE_NULL_BEAT_EN) begin\n"], [256, "    assign s_mem_write = s_axis_ready & s_axis_valid & (&s_axis_tkeep);\n"], [257, "  end else begin\n"], [258, "    assign s_mem_write = s_axis_ready & s_axis_valid;\n"], [259, "  end\n"], [260, "  assign m_mem_read = (~valid || m_axis_ready) && _m_axis_valid;\n"], [262, "  util_axis_fifo_address_generator #(\n"], [263, "    .ASYNC_CLK(ASYNC_CLK),\n"], [264, "    .ADDRESS_WIDTH(ADDRESS_WIDTH),\n"], [265, "    .ALMOST_EMPTY_THRESHOLD (ALMOST_EMPTY_THRESHOLD),\n"], [266, "    .ALMOST_FULL_THRESHOLD (ALMOST_FULL_THRESHOLD))\n"], [267, "  i_address_gray (\n"], [268, "    .m_axis_aclk(m_axis_aclk),\n"], [269, "    .m_axis_aresetn(m_axis_aresetn),\n"], [270, "    .m_axis_ready(_m_axis_ready),\n"], [271, "    .m_axis_valid(_m_axis_valid),\n"], [272, "    .m_axis_raddr(m_axis_raddr),\n"], [273, "    .m_axis_level(m_axis_level),\n"], [274, "    .m_axis_empty(m_axis_empty),\n"], [275, "    .m_axis_almost_empty(m_axis_almost_empty),\n"], [276, "    .s_axis_aclk(s_axis_aclk),\n"], [277, "    .s_axis_aresetn(s_axis_aresetn),\n"], [278, "    .s_axis_ready(s_axis_ready),\n"], [279, "    .s_axis_valid(s_axis_valid),\n"], [280, "    .s_axis_full(s_axis_full),\n"], [281, "    .s_axis_almost_full(s_axis_almost_full),\n"], [282, "    .s_axis_waddr(s_axis_waddr),\n"], [283, "    .s_axis_room(s_axis_room)\n"], [284, "  );\n"], [287, "  if (TLAST_EN & TKEEP_EN) begin\n"], [288, "    assign s_axis_data_int_s = {s_axis_tkeep, s_axis_tlast, s_axis_data};\n"], [289, "    assign m_axis_tkeep = m_axis_data_int_s[MEM_WORD-1-:DATA_WIDTH/8];\n"], [290, "    assign m_axis_tlast = m_axis_data_int_s[DATA_WIDTH];\n"], [291, "    assign m_axis_data = m_axis_data_int_s[DATA_WIDTH-1:0];\n"], [292, "  end else if (TKEEP_EN) begin\n"], [293, "    assign s_axis_data_int_s = {s_axis_tkeep, s_axis_data};\n"], [294, "    assign m_axis_tkeep = m_axis_data_int_s[MEM_WORD-1-:DATA_WIDTH/8];\n"], [295, "    assign m_axis_data = m_axis_data_int_s[DATA_WIDTH-1:0];\n"], [296, "  end else if (TLAST_EN) begin\n"], [297, "    assign s_axis_data_int_s = {s_axis_tlast, s_axis_data};\n"], [298, "    assign m_axis_tlast = m_axis_data_int_s[DATA_WIDTH];\n"], [299, "    assign m_axis_data = m_axis_data_int_s[DATA_WIDTH-1:0];\n"], [300, "  end else begin\n"], [301, "    assign s_axis_data_int_s = {s_axis_data};\n"], [302, "    assign m_axis_data = m_axis_data_int_s[DATA_WIDTH-1:0];\n"], [303, "  end\n"], [305, "  if (ASYNC_CLK == 1) begin : async_clocks /* Asynchronous WRITE/READ clocks */\n"], [311, "    ad_mem #(\n"], [312, "      .DATA_WIDTH (MEM_WORD),\n"], [313, "      .ADDRESS_WIDTH (ADDRESS_WIDTH))\n"], [314, "    i_mem (\n"], [315, "      .clka(s_axis_aclk),\n"], [316, "      .wea(s_mem_write),\n"], [317, "      .addra(s_axis_waddr),\n"], [318, "      .dina(s_axis_data_int_s),\n"], [319, "      .clkb(m_axis_aclk),\n"], [320, "      .reb(m_mem_read),\n"], [321, "      .addrb(m_axis_raddr),\n"], [322, "      .doutb(m_axis_data_int_s)\n"], [323, "    );\n"], [325, "    assign _m_axis_ready = ~valid || m_axis_ready;\n"], [326, "    assign m_axis_valid = valid;\n"], [328, "  end else begin : sync_clocks /* Synchronous WRITE/READ clocks */\n"], [330, "    reg [MEM_WORD-1:0] ram[0:2**ADDRESS_WIDTH-1];\n"], [334, "    always @(posedge s_axis_aclk) begin\n"], [335, "      if (s_mem_write)\n"], [336, "        ram[s_axis_waddr] <= s_axis_data_int_s;\n"], [337, "    end\n"], [339, "    if (M_AXIS_REGISTERED == 1) begin\n"], [341, "      reg [MEM_WORD-1:0] data;\n"], [343, "      always @(posedge m_axis_aclk) begin\n"], [344, "        if (m_mem_read)\n"], [345, "          data <= ram[m_axis_raddr];\n"], [346, "      end\n"], [348, "      assign _m_axis_ready = ~valid || m_axis_ready;\n"], [349, "      assign m_axis_data_int_s = data;\n"], [350, "      assign m_axis_valid = valid;\n"], [352, "    end else begin\n"], [354, "      assign _m_axis_ready = m_axis_ready;\n"], [355, "      assign m_axis_valid = _m_axis_valid;\n"], [356, "      assign m_axis_data_int_s = ram[m_axis_raddr];\n"], [359, "  end\n"], [360, "end /* fifo */\n"]], "Add": [[117, "  localparam MEM_WORD = (TKEEP_EN & TLAST_EN) ? (DATA_WIDTH+DATA_WIDTH/8+1) :\n"], [117, "                        (TKEEP_EN)            ? (DATA_WIDTH+DATA_WIDTH/8)   :\n"], [117, "                        (TLAST_EN)            ? (DATA_WIDTH+1)              :\n"], [117, "                                                (DATA_WIDTH);\n"], [117, "  wire [MEM_WORD-1:0] s_axis_data_int_s;\n"], [117, "  wire [MEM_WORD-1:0] m_axis_data_int_s;\n"], [117, "  generate if (ADDRESS_WIDTH == 0) begin : zerodeep /* it's not a real FIFO, just a 1 stage pipeline */\n"], [117, "    if (ASYNC_CLK) begin\n"], [117, "        (* KEEP = \"yes\" *) reg [DATA_WIDTH-1:0] cdc_sync_fifo_ram;\n"], [117, "        reg s_axis_waddr = 1'b0;\n"], [117, "        reg m_axis_raddr = 1'b0;\n"], [117, "        wire m_axis_waddr;\n"], [117, "        wire s_axis_raddr;\n"], [117, "        sync_bits #(\n"], [117, "          .NUM_OF_BITS(1),\n"], [117, "          .ASYNC_CLK(ASYNC_CLK)\n"], [117, "        ) i_waddr_sync (\n"], [117, "          .out_clk(m_axis_aclk),\n"], [117, "          .out_resetn(m_axis_aresetn),\n"], [117, "          .in_bits(s_axis_waddr),\n"], [117, "          .out_bits(m_axis_waddr));\n"], [117, "        sync_bits #(\n"], [117, "          .NUM_OF_BITS(1),\n"], [117, "          .ASYNC_CLK(ASYNC_CLK)\n"], [117, "        ) i_raddr_sync (\n"], [117, "          .out_clk(s_axis_aclk),\n"], [117, "          .out_resetn(s_axis_aresetn),\n"], [117, "          .in_bits(m_axis_raddr),\n"], [117, "          .out_bits(s_axis_raddr));\n"], [117, "        assign m_axis_valid = m_axis_raddr != m_axis_waddr;\n"], [117, "        assign m_axis_level = ~m_axis_ready;\n"], [117, "        assign m_axis_empty = 0;\n"], [117, "        assign m_axis_almost_empty = 0;\n"], [117, "        assign s_axis_ready = s_axis_raddr == s_axis_waddr;\n"], [117, "        assign s_axis_full = 0;\n"], [117, "        assign s_axis_almost_full = 0;\n"], [117, "        assign s_axis_room = s_axis_ready;\n"], [122, "        always @(posedge s_axis_aclk) begin\n"], [122, "          if (s_axis_ready == 1'b1 && s_axis_valid == 1'b1)\n"], [122, "            cdc_sync_fifo_ram <= s_axis_data;\n"], [122, "        end\n"], [122, "        always @(posedge s_axis_aclk) begin\n"], [122, "          if (s_axis_aresetn == 1'b0) begin\n"], [122, "            s_axis_waddr <= 1'b0;\n"], [122, "          end else if (s_axis_ready & s_axis_valid) begin\n"], [122, "            s_axis_waddr <= s_axis_waddr + 1'b1;\n"], [122, "          end\n"], [122, "        end\n"], [122, "        always @(posedge m_axis_aclk) begin\n"], [122, "          if (m_axis_aresetn == 1'b0) begin\n"], [122, "            m_axis_raddr <= 1'b0;\n"], [122, "          end else begin\n"], [122, "          if (m_axis_valid & m_axis_ready)\n"], [122, "            m_axis_raddr <= m_axis_raddr + 1'b1;\n"], [122, "          end\n"], [122, "        end\n"], [122, "        assign m_axis_data = cdc_sync_fifo_ram;\n"], [122, "        if (TLAST_EN) begin\n"], [122, "          reg axis_tlast_d;\n"], [122, "          always @(posedge s_axis_aclk) begin\n"], [122, "            if (s_axis_ready == 1'b1 && s_axis_valid == 1'b1)\n"], [122, "              axis_tlast_d <= s_axis_tlast;\n"], [122, "          end\n"], [122, "          assign m_axis_tlast = axis_tlast_d;\n"], [137, "        if (TKEEP_EN) begin\n"], [137, "          reg axis_tkeep_d;\n"], [137, "          always @(posedge s_axis_aclk) begin\n"], [137, "            if (s_axis_ready == 1'b1 && s_axis_valid == 1'b1)\n"], [137, "              axis_tkeep_d <= s_axis_tkeep;\n"], [137, "          end\n"], [137, "          assign m_axis_tkeep = axis_tkeep_d;\n"], [137, "        end\n"], [137, "    end /* zerodeep */\n"], [137, "    else\n"], [137, "    begin /* !ASYNC_CLK */\n"], [137, "      reg [DATA_WIDTH-1:0] axis_data_d;\n"], [137, "      reg                  axis_valid_d;\n"], [137, "      always @(posedge s_axis_aclk) begin\n"], [137, "        if (!s_axis_aresetn) begin\n"], [137, "          axis_data_d <= {DATA_WIDTH{1'b0}};\n"], [137, "          axis_valid_d <= 1'b0;\n"], [137, "        end else if (s_axis_ready) begin\n"], [137, "          axis_data_d <= s_axis_data;\n"], [137, "          axis_valid_d <= s_axis_valid;\n"], [141, "      assign m_axis_data = axis_data_d;\n"], [141, "      assign m_axis_valid = axis_valid_d;\n"], [141, "      assign s_axis_ready = m_axis_ready | ~m_axis_valid;\n"], [141, "      assign m_axis_empty = 1'b0;\n"], [141, "      assign m_axis_almost_empty = 1'b0;\n"], [141, "      assign m_axis_level = 1'b0;\n"], [141, "      assign s_axis_full  = 1'b0;\n"], [141, "      assign s_axis_almost_full  = 1'b0;\n"], [141, "      assign s_axis_room  = 1'b0;\n"], [146, "        reg  axis_tlast_d;\n"], [149, "          if (!s_axis_aresetn) begin\n"], [149, "            axis_tlast_d <= 1'b0;\n"], [149, "          end else if (s_axis_ready) begin\n"], [150, "          end\n"], [159, "        reg  axis_tkeep_d;\n"], [162, "          if (!s_axis_aresetn) begin\n"], [162, "            axis_tkeep_d <= 1'b0;\n"], [162, "          end else if (s_axis_ready) begin\n"], [163, "          end\n"], [167, "     end /* !ASYNC_CLK */\n"], [177, "  end else begin : fifo /* ADDRESS_WIDTH != 0 - this is a real FIFO implementation */\n"], [187, "    wire [ADDRESS_WIDTH-1:0] s_axis_waddr;\n"], [187, "    wire [ADDRESS_WIDTH-1:0] m_axis_raddr;\n"], [187, "    wire _m_axis_ready;\n"], [187, "    wire _m_axis_valid;\n"], [197, "    wire s_mem_write;\n"], [197, "    wire m_mem_read;\n"], [201, "    reg valid = 1'b0;\n"], [208, "    /* Control for first falls through */\n"], [208, "    always @(posedge m_axis_aclk) begin\n"], [208, "      if (m_axis_aresetn == 1'b0) begin\n"], [208, "        valid <= 1'b0;\n"], [208, "      end else begin\n"], [208, "        if (_m_axis_valid)\n"], [208, "          valid <= 1'b1;\n"], [208, "        else if (m_axis_ready)\n"], [208, "          valid <= 1'b0;\n"], [224, "    if (REMOVE_NULL_BEAT_EN) begin\n"], [224, "      assign s_mem_write = s_axis_ready & s_axis_valid & (&s_axis_tkeep);\n"], [224, "    end else begin\n"], [224, "      assign s_mem_write = s_axis_ready & s_axis_valid;\n"], [224, "    end\n"], [224, "    assign m_mem_read = (~valid || m_axis_ready) && _m_axis_valid;\n"], [224, "    util_axis_fifo_address_generator #(\n"], [224, "      .ASYNC_CLK(ASYNC_CLK),\n"], [224, "      .ADDRESS_WIDTH(ADDRESS_WIDTH),\n"], [224, "      .ALMOST_EMPTY_THRESHOLD (ALMOST_EMPTY_THRESHOLD),\n"], [224, "      .ALMOST_FULL_THRESHOLD (ALMOST_FULL_THRESHOLD)\n"], [224, "    ) i_address_gray (\n"], [224, "      .m_axis_aclk(m_axis_aclk),\n"], [224, "      .m_axis_aresetn(m_axis_aresetn),\n"], [224, "      .m_axis_ready(_m_axis_ready),\n"], [224, "      .m_axis_valid(_m_axis_valid),\n"], [224, "      .m_axis_raddr(m_axis_raddr),\n"], [224, "      .m_axis_level(m_axis_level),\n"], [224, "      .m_axis_empty(m_axis_empty),\n"], [224, "      .m_axis_almost_empty(m_axis_almost_empty),\n"], [224, "      .s_axis_aclk(s_axis_aclk),\n"], [224, "      .s_axis_aresetn(s_axis_aresetn),\n"], [224, "      .s_axis_ready(s_axis_ready),\n"], [224, "      .s_axis_valid(s_axis_valid),\n"], [224, "      .s_axis_full(s_axis_full),\n"], [224, "      .s_axis_almost_full(s_axis_almost_full),\n"], [224, "      .s_axis_waddr(s_axis_waddr),\n"], [224, "      .s_axis_room(s_axis_room));\n"], [224, "    if (TLAST_EN & TKEEP_EN) begin\n"], [224, "      assign s_axis_data_int_s = {s_axis_tkeep, s_axis_tlast, s_axis_data};\n"], [224, "      assign m_axis_tkeep = m_axis_data_int_s[MEM_WORD-1-:DATA_WIDTH/8];\n"], [224, "      assign m_axis_tlast = m_axis_data_int_s[DATA_WIDTH];\n"], [224, "      assign m_axis_data = m_axis_data_int_s[DATA_WIDTH-1:0];\n"], [224, "    end else if (TKEEP_EN) begin\n"], [224, "      assign s_axis_data_int_s = {s_axis_tkeep, s_axis_data};\n"], [224, "      assign m_axis_tkeep = m_axis_data_int_s[MEM_WORD-1-:DATA_WIDTH/8];\n"], [224, "      assign m_axis_data = m_axis_data_int_s[DATA_WIDTH-1:0];\n"], [224, "    end else if (TLAST_EN) begin\n"], [224, "      assign s_axis_data_int_s = {s_axis_tlast, s_axis_data};\n"], [224, "      assign m_axis_tlast = m_axis_data_int_s[DATA_WIDTH];\n"], [224, "      assign m_axis_data = m_axis_data_int_s[DATA_WIDTH-1:0];\n"], [224, "    end else begin\n"], [224, "      assign s_axis_data_int_s = {s_axis_data};\n"], [224, "      assign m_axis_data = m_axis_data_int_s[DATA_WIDTH-1:0];\n"], [230, "    if (ASYNC_CLK == 1) begin : async_clocks /* Asynchronous WRITE/READ clocks */\n"], [230, "      ad_mem #(\n"], [230, "        .DATA_WIDTH (MEM_WORD),\n"], [230, "        .ADDRESS_WIDTH (ADDRESS_WIDTH)\n"], [230, "      ) i_mem (\n"], [230, "        .clka(s_axis_aclk),\n"], [230, "        .wea(s_mem_write),\n"], [230, "        .addra(s_axis_waddr),\n"], [230, "        .dina(s_axis_data_int_s),\n"], [230, "        .clkb(m_axis_aclk),\n"], [230, "        .reb(m_mem_read),\n"], [230, "        .addrb(m_axis_raddr),\n"], [230, "        .doutb(m_axis_data_int_s));\n"], [235, "      assign _m_axis_ready = ~valid || m_axis_ready;\n"], [235, "      assign m_axis_valid = valid;\n"], [238, "    end else begin : sync_clocks /* Synchronous WRITE/READ clocks */\n"], [240, "      reg [MEM_WORD-1:0] ram[0:2**ADDRESS_WIDTH-1];\n"], [337, "      always @(posedge s_axis_aclk) begin\n"], [337, "        if (s_mem_write)\n"], [337, "          ram[s_axis_waddr] <= s_axis_data_int_s;\n"], [337, "      end\n"], [339, "      if (M_AXIS_REGISTERED == 1) begin\n"], [341, "        reg [MEM_WORD-1:0] data;\n"], [346, "        always @(posedge m_axis_aclk) begin\n"], [346, "          if (m_mem_read)\n"], [346, "            data <= ram[m_axis_raddr];\n"], [346, "        end\n"], [350, "        assign _m_axis_ready = ~valid || m_axis_ready;\n"], [350, "        assign m_axis_data_int_s = data;\n"], [350, "        assign m_axis_valid = valid;\n"], [352, "      end else begin\n"], [356, "        assign _m_axis_ready = m_axis_ready;\n"], [356, "        assign m_axis_valid = _m_axis_valid;\n"], [356, "        assign m_axis_data_int_s = ram[m_axis_raddr];\n"], [356, "      end\n"]]}}