{"Source Block": ["hdl/library/util_pack/util_pack_common/pack_interconnect.v@71:131@HdlStmFor", "    localparam z = 2**MUX_ORDER;\n    localparam w = PORT_DATA_WIDTH;\n    localparam NUM_SWITCHES = NUM_PORTS / z;\n\n    /* Do perfect shuffle, either in forward or reverse direction */\n    for (i = 0; i < NUM_STAGES; i = i + 1) begin: gen_stages\n      /* Pack network are in the opposite direction */\n      localparam ctrl_stage = PACK ? NUM_STAGES - i - 1 : i;\n      wire [TOTAL_DATA_WIDTH-1:0] shuffle_in;\n      wire [TOTAL_DATA_WIDTH-1:0] shuffle_out;\n      wire [TOTAL_DATA_WIDTH-1:0] mux_in;\n      wire [TOTAL_DATA_WIDTH-1:0] mux_out;\n\n      /* Unpack uses forward shuffle and pack a reverse shuffle */\n      ad_perfect_shuffle #(\n        .NUM_GROUPS (PACK ? NUM_SWITCHES : z),\n        .WORDS_PER_GROUP (PACK ? z : NUM_SWITCHES),\n        .WORD_WIDTH (w)\n      ) i_shuffle (\n        .data_in (shuffle_in),\n        .data_out (shuffle_out)\n      );\n\n      for (j = 0; j < NUM_PORTS; j = j + 1) begin: gen_ports\n        localparam ctrl_base = (ctrl_stage * NUM_PORTS + j) * MUX_ORDER;\n        localparam sel_base = j & ~(z-1); /* base increments in 2**MUX_ORDER steps */\n\n        /*\n         * To be able to better share MUX control signals and reduce overall\n         * resource consumption the control signal gets rotated by the offset of\n         * MUX in a switch.\n         *\n         * E.g. a control signal of 0 for the first MUX means that the first\n         * input should be selected. A control signal of 0 for the second switch\n         * means that the second input will be used. To implement this (j % z)\n         * is added to the control signal when selecting the input bits. This\n         * addition does not result in additional resources being used. It just\n         * results in a different look-up table.\n         */\n\n        wire [MUX_ORDER-1:0] sel = ctrl[ctrl_base+:MUX_ORDER];// + j % z;\n        assign mux_out[j*w+:w] = mux_in[(sel_base+sel)*w+:w];\n      end\n\n      /*\n       * Pack is MUX followed by shuffle.\n       * Unpack is shuffle followed by MUX.\n       */\n      if (PACK) begin\n        assign mux_in = interconnect[i];\n        assign shuffle_in = mux_out;\n        assign interconnect[i+1] = shuffle_out;\n      end else begin\n        assign shuffle_in = interconnect[i];\n        assign mux_in = shuffle_out;\n        assign interconnect[i+1] = mux_out;\n      end\n  end\n  endgenerate\n\nendmodule\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[77, "      /* Pack network are in the opposite direction */\n"], [84, "      /* Unpack uses forward shuffle and pack a reverse shuffle */\n"], [91, "        .data_out (shuffle_out)\n"], [92, "      );\n"], [96, "        localparam sel_base = j & ~(z-1); /* base increments in 2**MUX_ORDER steps */\n"]], "Add": [[92, "        .data_out (shuffle_out));\n"], [96, "        localparam sel_base = j & ~(z-1); // base increments in 2**MUX_ORDER steps\n"]]}}