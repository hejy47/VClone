{"Source Block": ["hdl/library/util_axis_fifo_asym/util_axis_fifo_asym.v@197:250@HdlStmIf", "\nendgenerate\n\n// read or slave logic\ngenerate\n  if (RATIO_TYPE) begin : small_master\n\n    for (i=0; i<RATIO; i=i+1) begin\n      assign m_axis_ready_int_s[i] = (m_axis_counter == i) ? m_axis_ready : 1'b0;\n    end\n\n    assign m_axis_data = m_axis_data_int_s >> (m_axis_counter*A_WIDTH) ;\n    assign m_axis_tkeep = m_axis_tkeep_int_s >> (m_axis_counter*A_WIDTH/8) ;\n\n    // VALID/EMPTY/ALMOST_EMPTY is driven by the current atomic instance\n    assign m_axis_valid = m_axis_valid_int_s >> m_axis_counter;\n\n    // the FIFO has the same level as the last atomic instance\n    // (NOTE: this is not the real level value, rather the value will be updated\n    // after every RATIO number of reads)\n    assign m_axis_level = {m_axis_level_int_s[A_ADDRESS-1:0], {$clog2(RATIO){1'b0}}};\n    assign m_axis_almost_empty = m_axis_almost_empty_int_s[RATIO-1];\n    assign m_axis_empty = m_axis_empty_int_s[RATIO-1];\n\n  end else begin : big_master\n\n    for (i=0; i<RATIO; i=i+1) begin\n      assign m_axis_ready_int_s[i] = m_axis_ready;\n    end\n\n    for (i=0; i<RATIO; i=i+1) begin\n      assign m_axis_tkeep[i*A_WIDTH/8+:A_WIDTH/8] = (m_axis_tlast_int_s[i:0] == 0) ||\n                                                    (m_axis_tlast_int_s[i]) ?\n                                                  m_axis_tkeep_int_s[i*A_WIDTH/8+:A_WIDTH/8] :\n                                                  {(A_WIDTH/8){1'b0}};\n    end\n\n    assign m_axis_data = m_axis_data_int_s;\n    // if every instance has a valid data, the interface has valid data,\n    // otherwise valid is asserted only if TLAST is asserted\n    assign m_axis_valid = (|m_axis_tlast_int_s) ? |m_axis_valid_int_s : &m_axis_valid_int_s;\n    // if one of the atomic instance is empty, m_axis_empty should be asserted\n    assign m_axis_empty = |m_axis_empty_int_s;\n    assign m_axis_almost_empty = |m_axis_almost_empty_int_s;\n\n    // the FIFO has the same room as the atomic FIFO\n    assign m_axis_level = m_axis_level_int_s[A_ADDRESS-1:0];\n\n  end\n\n  assign m_axis_tlast = (m_axis_valid) ? |m_axis_tlast_int_s : 1'b0;\n\nendgenerate\n\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[202, "  if (RATIO_TYPE) begin : small_master\n"], [204, "    for (i=0; i<RATIO; i=i+1) begin\n"], [205, "      assign m_axis_ready_int_s[i] = (m_axis_counter == i) ? m_axis_ready : 1'b0;\n"], [208, "    assign m_axis_data = m_axis_data_int_s >> (m_axis_counter*A_WIDTH) ;\n"], [209, "    assign m_axis_tkeep = m_axis_tkeep_int_s >> (m_axis_counter*A_WIDTH/8) ;\n"], [212, "    assign m_axis_valid = m_axis_valid_int_s >> m_axis_counter;\n"], [217, "    assign m_axis_level = {m_axis_level_int_s[A_ADDRESS-1:0], {$clog2(RATIO){1'b0}}};\n"], [218, "    assign m_axis_almost_empty = m_axis_almost_empty_int_s[RATIO-1];\n"], [219, "    assign m_axis_empty = m_axis_empty_int_s[RATIO-1];\n"], [221, "  end else begin : big_master\n"], [223, "    for (i=0; i<RATIO; i=i+1) begin\n"], [224, "      assign m_axis_ready_int_s[i] = m_axis_ready;\n"], [225, "    end\n"], [227, "    for (i=0; i<RATIO; i=i+1) begin\n"], [228, "      assign m_axis_tkeep[i*A_WIDTH/8+:A_WIDTH/8] = (m_axis_tlast_int_s[i:0] == 0) ||\n"], [229, "                                                    (m_axis_tlast_int_s[i]) ?\n"], [230, "                                                  m_axis_tkeep_int_s[i*A_WIDTH/8+:A_WIDTH/8] :\n"], [231, "                                                  {(A_WIDTH/8){1'b0}};\n"], [232, "    end\n"], [234, "    assign m_axis_data = m_axis_data_int_s;\n"], [237, "    assign m_axis_valid = (|m_axis_tlast_int_s) ? |m_axis_valid_int_s : &m_axis_valid_int_s;\n"], [239, "    assign m_axis_empty = |m_axis_empty_int_s;\n"], [240, "    assign m_axis_almost_empty = |m_axis_almost_empty_int_s;\n"], [243, "    assign m_axis_level = m_axis_level_int_s[A_ADDRESS-1:0];\n"], [245, "  end\n"]], "Add": [[202, "      assign s_axis_full = s_axis_full_int_s[RATIO-1];\n"], [202, "      assign s_axis_room = {s_axis_room_int_s[A_ADDRESS*(RATIO-1)+:A_ADDRESS], {$clog2(RATIO){1'b1}}};\n"], [209, "  endgenerate\n"], [212, "  generate\n"], [212, "    if (RATIO_TYPE) begin : small_master\n"], [219, "      for (i=0; i<RATIO; i=i+1) begin\n"], [219, "        assign m_axis_ready_int_s[i] = (m_axis_counter == i) ? m_axis_ready : 1'b0;\n"], [219, "      end\n"], [221, "      assign m_axis_data = m_axis_data_int_s >> (m_axis_counter*A_WIDTH) ;\n"], [221, "      assign m_axis_tkeep = m_axis_tkeep_int_s >> (m_axis_counter*A_WIDTH/8) ;\n"], [225, "      assign m_axis_valid = m_axis_valid_int_s >> m_axis_counter;\n"], [232, "      assign m_axis_level = {m_axis_level_int_s[A_ADDRESS-1:0], {$clog2(RATIO){1'b0}}};\n"], [232, "      assign m_axis_almost_empty = m_axis_almost_empty_int_s[RATIO-1];\n"], [232, "      assign m_axis_empty = m_axis_empty_int_s[RATIO-1];\n"], [240, "    end else begin : big_master\n"], [243, "      for (i=0; i<RATIO; i=i+1) begin\n"], [243, "        assign m_axis_ready_int_s[i] = m_axis_ready;\n"], [243, "      end\n"], [245, "      for (i=0; i<RATIO; i=i+1) begin\n"], [245, "        assign m_axis_tkeep[i*A_WIDTH/8+:A_WIDTH/8] = (m_axis_tlast_int_s[i:0] == 0) ||\n"], [245, "                                                      (m_axis_tlast_int_s[i]) ?\n"], [245, "                                                    m_axis_tkeep_int_s[i*A_WIDTH/8+:A_WIDTH/8] :\n"], [245, "                                                    {(A_WIDTH/8){1'b0}};\n"], [245, "      end\n"]]}}