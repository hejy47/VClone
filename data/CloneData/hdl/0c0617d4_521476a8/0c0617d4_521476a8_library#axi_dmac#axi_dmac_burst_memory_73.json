{"Source Block": ["hdl/library/axi_dmac/axi_dmac_burst_memory.v@285:303@HdlStmProcess", " * dest_data_last when dest_data_valid is not asserted. But clearing the signal\n * here doesn't cost much and can simplify some of the more congested\n * combinatorical logic further up the pipeline since we can assume that\n * fifo_last == 1'b1 implies fifo_valid == 1'b1.\n */\nalways @(posedge dest_clk) begin\n  if (dest_reset == 1'b1) begin\n    dest_mem_data_last <= 1'b0;\n  end else if (dest_beat == 1'b1) begin\n    dest_mem_data_last <= dest_last;\n  end else if (dest_mem_data_ready == 1'b1) begin\n    dest_mem_data_last <= 1'b0;\n  end\nend\n\nalways @(posedge dest_clk) begin\n  if (dest_beat == 1'b1) begin\n    if (dest_last == 1'b1) begin\n      dest_mem_data_strb <= {DATA_WIDTH_MEM_DEST/8{1'b1}} >> ~dest_burst_len_data[BYTES_PER_BEAT_WIDTH_DEST-1:0];\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[290, "always @(posedge dest_clk) begin\n"], [291, "  if (dest_reset == 1'b1) begin\n"], [292, "    dest_mem_data_last <= 1'b0;\n"], [293, "  end else if (dest_beat == 1'b1) begin\n"], [294, "    dest_mem_data_last <= dest_last;\n"], [295, "  end else if (dest_mem_data_ready == 1'b1) begin\n"], [296, "    dest_mem_data_last <= 1'b0;\n"], [298, "end\n"]], "Add": [[296, "  always @(*) begin\n"], [296, "    if (src_last_beat == 1'b1) begin\n"], [296, "      src_id_next = inc_id(src_id);\n"], [296, "    end else begin\n"], [296, "      src_id_next = src_id;\n"], [296, "    end\n"]]}}