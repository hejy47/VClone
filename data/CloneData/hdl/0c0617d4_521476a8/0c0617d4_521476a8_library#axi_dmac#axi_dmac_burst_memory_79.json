{"Source Block": ["hdl/library/axi_dmac/axi_dmac_burst_memory.v@330:346@HdlStmProcess", "    dest_id <= dest_id_next;\n    dest_id_reduced_msb <= dest_id_reduced_msb_next;\n  end\nend\n\nalways @(posedge dest_clk) begin\n  if (dest_reset == 1'b1 || dest_last_beat == 1'b1) begin\n    dest_beat_counter <= 'h00;\n  end else if (dest_beat == 1'b1) begin\n    dest_beat_counter <= dest_beat_counter + 1'b1;\n  end\nend\n\nassign dest_burst_info_length = dest_burst_len_data[BYTES_PER_BURST_WIDTH-1:0];\nassign dest_burst_info_partial = dest_burst_len_data[BYTES_PER_BURST_WIDTH];\nassign dest_burst_info_id = dest_id;\n\n"], "Clone Blocks": [["hdl/library/axi_dmac/axi_dmac_burst_memory.v@338:348", "  end else if (dest_beat == 1'b1) begin\n    dest_beat_counter <= dest_beat_counter + 1'b1;\n  end\nend\n\nassign dest_burst_info_length = dest_burst_len_data[BYTES_PER_BURST_WIDTH-1:0];\nassign dest_burst_info_partial = dest_burst_len_data[BYTES_PER_BURST_WIDTH];\nassign dest_burst_info_id = dest_id;\n\nalways @(posedge dest_clk) begin\n  dest_burst_info_write <= (dest_burst_valid == 1'b1 && dest_burst_ready == 1'b1);\n"]], "Diff Content": {"Delete": [[335, "always @(posedge dest_clk) begin\n"], [336, "  if (dest_reset == 1'b1 || dest_last_beat == 1'b1) begin\n"], [337, "    dest_beat_counter <= 'h00;\n"], [338, "  end else if (dest_beat == 1'b1) begin\n"], [339, "    dest_beat_counter <= dest_beat_counter + 1'b1;\n"], [341, "end\n"]], "Add": [[339, "  /*\n"], [339, "   * This clears dest_data_last after the last beat. Strictly speaking this is not\n"], [339, "   * necessary if this followed AXI handshaking rules since dest_data_last would\n"], [339, "   * be qualified by dest_data_valid and it is OK to retain the previous value of\n"], [339, "   * dest_data_last when dest_data_valid is not asserted. But clearing the signal\n"], [339, "   * here doesn't cost much and can simplify some of the more congested\n"], [339, "   * combinatorical logic further up the pipeline since we can assume that\n"], [339, "   * fifo_last == 1'b1 implies fifo_valid == 1'b1.\n"], [339, "   */\n"], [339, "  always @(posedge dest_clk) begin\n"], [339, "    if (dest_reset == 1'b1) begin\n"], [339, "      dest_mem_data_last <= 1'b0;\n"], [339, "    end else if (dest_beat == 1'b1) begin\n"], [339, "      dest_mem_data_last <= dest_last;\n"], [339, "    end else if (dest_mem_data_ready == 1'b1) begin\n"], [339, "      dest_mem_data_last <= 1'b0;\n"], [339, "    end\n"]]}}