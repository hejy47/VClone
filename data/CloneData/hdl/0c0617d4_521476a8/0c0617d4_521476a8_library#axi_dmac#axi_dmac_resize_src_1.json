{"Source Block": ["hdl/library/axi_dmac/axi_dmac_resize_src.v@60:146@HdlStmIf", "  output mem_data_last,\n  output [BYTES_PER_BEAT_WIDTH_MEM-1:0] mem_data_valid_bytes,\n  output mem_data_partial_burst\n);\n\ngenerate if (DATA_WIDTH_SRC == DATA_WIDTH_MEM)  begin\n  assign mem_data_valid = src_data_valid;\n  assign mem_data = src_data;\n  assign mem_data_last = src_data_last;\n  assign mem_data_valid_bytes = src_data_valid_bytes;\n  assign mem_data_partial_burst = src_data_partial_burst;\nend else begin\n\n  localparam RATIO = DATA_WIDTH_MEM / DATA_WIDTH_SRC;\n  localparam RATIO_WIDTH = RATIO > 64 ? 7 :\n                           RATIO > 32 ? 6 :\n                           RATIO > 16 ? 5 :\n                           RATIO > 8 ? 4 :\n                           RATIO > 4 ? 3 :\n                           RATIO > 2 ? 2 : 1;\n\n  reg [RATIO-1:0] mask = 'h1;\n  reg valid = 1'b0;\n  reg last = 1'b0;\n  reg [DATA_WIDTH_MEM-1:0] data = 'h0;\n  reg [BYTES_PER_BEAT_WIDTH_SRC-1:0] valid_bytes = 'h00;\n  reg partial_burst = 1'b0;\n  reg [RATIO_WIDTH-1:0] num_beats = {RATIO_WIDTH{1'b1}};\n\n  always @(posedge clk) begin\n    if (reset == 1'b1) begin\n      valid <= 1'b0;\n      mask <= 'h1;\n    end else if (src_data_valid == 1'b1) begin\n      valid <= mask[RATIO-1] || src_data_last;\n      if (src_data_last) begin\n        mask <= 'h1;\n      end else begin\n        mask <= {mask[RATIO-2:0],mask[RATIO-1]};\n      end\n    end else begin\n      valid <= 1'b0;\n    end\n  end\n\n  // This counter will hold the number of source beat in a destination beat\n  // minus one\n  always @(posedge clk) begin\n    if (reset == 1'b1) begin\n      num_beats <= {RATIO_WIDTH{1'b1}};\n    end else if (valid == 1'b1 && last == 1'b1) begin\n      if (src_data_valid == 1'b1) begin\n        num_beats <= {RATIO_WIDTH{1'b0}};\n      end else begin\n        num_beats <= {RATIO_WIDTH{1'b1}};\n      end\n    end else if (src_data_valid == 1'b1) begin\n      num_beats <= num_beats + 1'b1;\n    end\n  end\n\n  integer i;\n\n  always @(posedge clk) begin\n    for (i = 0; i < RATIO; i = i+1) begin\n      if (mask[i] == 1'b1) begin\n        data[i*DATA_WIDTH_SRC+:DATA_WIDTH_SRC] <= src_data;\n      end\n    end\n\n    // Compensate for the one clock cycle pipeline delay of the data\n    last <= src_data_last;\n    if (src_data_valid == 1'b1) begin\n      valid_bytes <= src_data_valid_bytes;\n      partial_burst <= src_data_partial_burst;\n    end\n  end\n\n  assign mem_data_valid = valid;\n  assign mem_data = data;\n  assign mem_data_last = last;\n  assign mem_data_valid_bytes = {num_beats,valid_bytes};\n  assign mem_data_partial_burst = partial_burst;\n\nend endgenerate\n\nendmodule\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[65, "generate if (DATA_WIDTH_SRC == DATA_WIDTH_MEM)  begin\n"], [66, "  assign mem_data_valid = src_data_valid;\n"], [67, "  assign mem_data = src_data;\n"], [68, "  assign mem_data_last = src_data_last;\n"], [69, "  assign mem_data_valid_bytes = src_data_valid_bytes;\n"], [70, "  assign mem_data_partial_burst = src_data_partial_burst;\n"], [71, "end else begin\n"], [73, "  localparam RATIO = DATA_WIDTH_MEM / DATA_WIDTH_SRC;\n"], [74, "  localparam RATIO_WIDTH = RATIO > 64 ? 7 :\n"], [75, "                           RATIO > 32 ? 6 :\n"], [76, "                           RATIO > 16 ? 5 :\n"], [77, "                           RATIO > 8 ? 4 :\n"], [78, "                           RATIO > 4 ? 3 :\n"], [79, "                           RATIO > 2 ? 2 : 1;\n"], [81, "  reg [RATIO-1:0] mask = 'h1;\n"], [82, "  reg valid = 1'b0;\n"], [83, "  reg last = 1'b0;\n"], [84, "  reg [DATA_WIDTH_MEM-1:0] data = 'h0;\n"], [85, "  reg [BYTES_PER_BEAT_WIDTH_SRC-1:0] valid_bytes = 'h00;\n"], [86, "  reg partial_burst = 1'b0;\n"], [87, "  reg [RATIO_WIDTH-1:0] num_beats = {RATIO_WIDTH{1'b1}};\n"], [89, "  always @(posedge clk) begin\n"], [90, "    if (reset == 1'b1) begin\n"], [91, "      valid <= 1'b0;\n"], [92, "      mask <= 'h1;\n"], [93, "    end else if (src_data_valid == 1'b1) begin\n"], [94, "      valid <= mask[RATIO-1] || src_data_last;\n"], [95, "      if (src_data_last) begin\n"], [98, "        mask <= {mask[RATIO-2:0],mask[RATIO-1]};\n"], [100, "    end else begin\n"], [101, "      valid <= 1'b0;\n"], [103, "  end\n"], [107, "  always @(posedge clk) begin\n"], [108, "    if (reset == 1'b1) begin\n"], [109, "      num_beats <= {RATIO_WIDTH{1'b1}};\n"], [110, "    end else if (valid == 1'b1 && last == 1'b1) begin\n"], [111, "      if (src_data_valid == 1'b1) begin\n"], [112, "        num_beats <= {RATIO_WIDTH{1'b0}};\n"], [113, "      end else begin\n"], [116, "    end else if (src_data_valid == 1'b1) begin\n"], [117, "      num_beats <= num_beats + 1'b1;\n"], [119, "  end\n"], [121, "  integer i;\n"], [123, "  always @(posedge clk) begin\n"], [124, "    for (i = 0; i < RATIO; i = i+1) begin\n"], [125, "      if (mask[i] == 1'b1) begin\n"], [126, "        data[i*DATA_WIDTH_SRC+:DATA_WIDTH_SRC] <= src_data;\n"], [128, "    end\n"], [131, "    last <= src_data_last;\n"], [132, "    if (src_data_valid == 1'b1) begin\n"], [133, "      valid_bytes <= src_data_valid_bytes;\n"], [134, "      partial_burst <= src_data_partial_burst;\n"], [136, "  end\n"], [138, "  assign mem_data_valid = valid;\n"], [139, "  assign mem_data = data;\n"], [140, "  assign mem_data_last = last;\n"], [141, "  assign mem_data_valid_bytes = {num_beats,valid_bytes};\n"], [142, "  assign mem_data_partial_burst = partial_burst;\n"], [144, "end endgenerate\n"]], "Add": [[95, "  generate if (DATA_WIDTH_SRC == DATA_WIDTH_MEM)  begin\n"], [95, "    assign mem_data_valid = src_data_valid;\n"], [95, "    assign mem_data = src_data;\n"], [95, "    assign mem_data_last = src_data_last;\n"], [95, "    assign mem_data_valid_bytes = src_data_valid_bytes;\n"], [95, "    assign mem_data_partial_burst = src_data_partial_burst;\n"], [95, "  end else begin\n"], [95, "    localparam RATIO = DATA_WIDTH_MEM / DATA_WIDTH_SRC;\n"], [95, "    localparam RATIO_WIDTH = RATIO > 64 ? 7 :\n"], [95, "                             RATIO > 32 ? 6 :\n"], [95, "                             RATIO > 16 ? 5 :\n"], [95, "                             RATIO > 8 ? 4 :\n"], [95, "                             RATIO > 4 ? 3 :\n"], [95, "                             RATIO > 2 ? 2 : 1;\n"], [95, "    reg [RATIO-1:0] mask = 'h1;\n"], [95, "    reg valid = 1'b0;\n"], [95, "    reg last = 1'b0;\n"], [95, "    reg [DATA_WIDTH_MEM-1:0] data = 'h0;\n"], [95, "    reg [BYTES_PER_BEAT_WIDTH_SRC-1:0] valid_bytes = 'h00;\n"], [95, "    reg partial_burst = 1'b0;\n"], [95, "    reg [RATIO_WIDTH-1:0] num_beats = {RATIO_WIDTH{1'b1}};\n"], [95, "    always @(posedge clk) begin\n"], [95, "      if (reset == 1'b1) begin\n"], [95, "        valid <= 1'b0;\n"], [96, "      end else if (src_data_valid == 1'b1) begin\n"], [96, "        valid <= mask[RATIO-1] || src_data_last;\n"], [96, "        if (src_data_last) begin\n"], [96, "          mask <= 'h1;\n"], [96, "        end else begin\n"], [96, "          mask <= {mask[RATIO-2:0],mask[RATIO-1]};\n"], [96, "        end\n"], [98, "        valid <= 1'b0;\n"], [113, "    always @(posedge clk) begin\n"], [113, "      if (reset == 1'b1) begin\n"], [114, "      end else if (valid == 1'b1 && last == 1'b1) begin\n"], [114, "        if (src_data_valid == 1'b1) begin\n"], [114, "          num_beats <= {RATIO_WIDTH{1'b0}};\n"], [114, "        end else begin\n"], [114, "          num_beats <= {RATIO_WIDTH{1'b1}};\n"], [114, "        end\n"], [114, "      end else if (src_data_valid == 1'b1) begin\n"], [114, "        num_beats <= num_beats + 1'b1;\n"], [121, "    integer i;\n"], [126, "    always @(posedge clk) begin\n"], [126, "      for (i = 0; i < RATIO; i = i+1) begin\n"], [126, "        if (mask[i] == 1'b1) begin\n"], [126, "          data[i*DATA_WIDTH_SRC+:DATA_WIDTH_SRC] <= src_data;\n"], [126, "        end\n"], [134, "      last <= src_data_last;\n"], [134, "      if (src_data_valid == 1'b1) begin\n"], [134, "        valid_bytes <= src_data_valid_bytes;\n"], [134, "        partial_burst <= src_data_partial_burst;\n"], [134, "      end\n"], [142, "    assign mem_data_valid = valid;\n"], [142, "    assign mem_data = data;\n"], [142, "    assign mem_data_last = last;\n"], [142, "    assign mem_data_valid_bytes = {num_beats,valid_bytes};\n"], [142, "    assign mem_data_partial_burst = partial_burst;\n"], [144, "  end endgenerate\n"]]}}