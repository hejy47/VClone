{"Source Block": ["hdl/library/jesd204/jesd204_rx/jesd204_rx_header.v@183:199@HdlStmProcess", "assign valid_eomb = next_state[BIT_EMB_LOCK] && eomb;\nassign valid_eoemb = next_state[BIT_EMB_LOCK] && eoemb;\n\nassign invalid_sequence = (invalid_eoemb || invalid_eomb);\n\nalways @(posedge clk) begin\n  if (reset == 1'b1) begin\n    state <= STATE_EMB_INIT;\n  end else begin\n    state <= next_state;\n  end\nend\n\nassign emb_lock = next_state[BIT_EMB_LOCK];\n\n// Status & error events\nassign status_lane_emb_state = state;\n"], "Clone Blocks": [["hdl/library/jesd204/jesd204_rx/jesd204_rx_header.v@179:189", "end\n\nassign invalid_eoemb = (sh_count == 0 && ~eoemb);\nassign invalid_eomb = (sh_count[4:0] == 0 && ~eomb);\nassign valid_eomb = next_state[BIT_EMB_LOCK] && eomb;\nassign valid_eoemb = next_state[BIT_EMB_LOCK] && eoemb;\n\nassign invalid_sequence = (invalid_eoemb || invalid_eomb);\n\nalways @(posedge clk) begin\n  if (reset == 1'b1) begin\n"], ["hdl/library/jesd204/jesd204_rx/jesd204_rx_header.v@178:188", "  if (sh_lock == 1'b0) next_state = STATE_EMB_INIT;\nend\n\nassign invalid_eoemb = (sh_count == 0 && ~eoemb);\nassign invalid_eomb = (sh_count[4:0] == 0 && ~eomb);\nassign valid_eomb = next_state[BIT_EMB_LOCK] && eomb;\nassign valid_eoemb = next_state[BIT_EMB_LOCK] && eoemb;\n\nassign invalid_sequence = (invalid_eoemb || invalid_eomb);\n\nalways @(posedge clk) begin\n"], ["hdl/library/jesd204/jesd204_rx/jesd204_rx_header.v@181:191", "assign invalid_eoemb = (sh_count == 0 && ~eoemb);\nassign invalid_eomb = (sh_count[4:0] == 0 && ~eomb);\nassign valid_eomb = next_state[BIT_EMB_LOCK] && eomb;\nassign valid_eoemb = next_state[BIT_EMB_LOCK] && eoemb;\n\nassign invalid_sequence = (invalid_eoemb || invalid_eomb);\n\nalways @(posedge clk) begin\n  if (reset == 1'b1) begin\n    state <= STATE_EMB_INIT;\n  end else begin\n"]], "Diff Content": {"Delete": [[188, "always @(posedge clk) begin\n"], [189, "  if (reset == 1'b1) begin\n"], [190, "    state <= STATE_EMB_INIT;\n"], [191, "  end else begin\n"], [192, "    state <= next_state;\n"], [194, "end\n"]], "Add": [[192, "  assign invalid_eoemb = (sh_count == 0 && ~eoemb);\n"], [192, "  assign invalid_eomb = (sh_count[4:0] == 0 && ~eomb);\n"], [192, "  assign valid_eomb = next_state[BIT_EMB_LOCK] && eomb;\n"], [192, "  assign valid_eoemb = next_state[BIT_EMB_LOCK] && eoemb;\n"], [192, "  assign invalid_sequence = (invalid_eoemb || invalid_eomb);\n"], [192, "  always @(posedge clk) begin\n"], [192, "    if (reset == 1'b1) begin\n"], [192, "      state <= STATE_EMB_INIT;\n"], [192, "    end else begin\n"], [192, "      state <= next_state;\n"], [192, "    end\n"]]}}