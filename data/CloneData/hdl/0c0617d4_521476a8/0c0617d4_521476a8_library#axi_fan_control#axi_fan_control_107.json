{"Source Block": ["hdl/library/axi_fan_control/axi_fan_control.v@323:534@HdlStmProcess", "  .load_config (pulse_gen_load_config),\n  .pulse (pulse_gen_out)\n);\n\n//state machine\nalways @(posedge up_clk)\n  if (up_resetn == 1'b0) begin\n    tacho_alarm <= 'h0;\n    drp_den_reg <= 'h0;\n    drp_dwe_reg <= 'h0;\n    drp_di <= 'h0;\n    tacho_avg_cnt <= 'h0;\n    tacho_avg_sum <= 'h0;\n    tacho_meas_ack <= 'h0;\n    pulse_gen_load_config <= 'h0;\n    sysmone_temp <= 'h0;\n    pwm_width_req <= 'h0;\n    pwm_width <= 'h0;\n    up_tacho_avg_sum <= 'h0;\n    temp_increase_alarm <= 'h0;\n    tacho_meas_int <= 1'b0;\n    state <= INIT;\n  end else begin\n\n    case (state)\n\n      INIT : begin\n        if (INTERNAL_SYSMONE == 1) begin\n          drp_daddr <= 8'h40;\n          // performing read\n          drp_den_reg <= 2'h2;\n          if (drp_eoc == 1'b1) begin\n            state <= DRP_WAIT_EOC;\n          end\n        end else begin\n          state <= DRP_READ_TEMP;\n        end\n      end\n\n      DRP_WAIT_EOC : begin\n        if (drp_eoc == 1'b1) begin\n          //Clearing AVG bits for Configreg0\n          drp_di <= drp_do & 16'h03FF;\n          drp_daddr <= 8'h40;\n          drp_den_reg <= 2'h2;\n          // performing write\n          drp_dwe_reg <= 2'h2;\n          state <= DRP_WAIT_DRDY;\n        end else begin\n          drp_den_reg <= {1'b0, drp_den_reg[1]};\n          drp_dwe_reg <= {1'b0, drp_dwe_reg[1]};\n        end\n      end\n\n      DRP_WAIT_DRDY : begin\n        if (drp_drdy == 1'b1) begin\n          state <= DRP_READ_TEMP;\n        end else begin\n          drp_den_reg <= {1'b0, drp_den_reg[1]};\n          drp_dwe_reg <= {1'b0, drp_dwe_reg[1]};\n        end\n      end\n\n      DRP_WAIT_FSM_EN : begin\n        tacho_meas_int <= 1'b0;\n        tacho_alarm <= 1'b0;\n        pulse_gen_load_config <= 1'b0;\n        if (presc_reg[15] == 1'b1) begin\n          state <= DRP_READ_TEMP;\n        end\n      end\n\n      DRP_READ_TEMP : begin\n        if (INTERNAL_SYSMONE == 1) begin\n          drp_daddr <= 8'h00;\n          // performing read\n          drp_den_reg <= 2'h2;\n          if (drp_eos == 1'b1) begin\n            state <= DRP_READ_TEMP_WAIT_DRDY;\n          end\n        end else begin\n          state <= DRP_READ_TEMP_WAIT_DRDY;\n        end\n      end\n\n      DRP_READ_TEMP_WAIT_DRDY : begin\n        if (INTERNAL_SYSMONE == 1) begin\n          if (drp_drdy == 1'b1) begin\n            sysmone_temp <= drp_do;\n            state <= GET_TACHO;\n          end else begin\n            drp_den_reg <= {1'b0, drp_den_reg[1]};\n            drp_dwe_reg <= {1'b0, drp_dwe_reg[1]};\n          end\n        end else begin\n          sysmone_temp <= temp_in;\n          state <= GET_TACHO;\n        end\n      end\n\n      GET_TACHO : begin\n        //adding up tacho measurements in order to obtain a mean value from 32 samples\n        if ((tacho_avg_cnt == AVERAGE_DIV) || (counter_overflow) || (!pwm_change_done)) begin\n          //once a set measurements has been obtained, reset the values\n          tacho_avg_sum <= 1'b0;\n          tacho_avg_cnt <= 1'b0;\n          tacho_meas_ack <= 1'b0;\n        end else if ((tacho_meas_new) && (pwm_change_done)) begin\n          //tacho_meas_new and tacho_meas_ack ensure the value is read at the right time and only once\n          tacho_avg_sum <= tacho_avg_sum + tacho_meas;\n          tacho_avg_cnt <= tacho_avg_cnt + 1'b1;\n          //acknowledge tha the current values has been added\n          tacho_meas_ack <= 1'b1;\n        end else begin\n          tacho_meas_ack <= 1'b0;\n        end\n        state <= EVAL_TEMP;\n      end\n\n      EVAL_TEMP : begin\n        //pwm section\n        //the pwm only has to be changed when passing through these temperature intervals\n        if (sysmone_temp < up_temp_00_h) begin\n          //PWM DUTY should be 0%\n          pwm_width_req <= 1'b0;\n        end else if ((sysmone_temp > up_temp_25_l) && (sysmone_temp < up_temp_25_h)) begin\n          //PWM DUTY should be 25%\n          pwm_width_req <= PWM_ONTIME_25;\n        end else if ((sysmone_temp > up_temp_50_l) && (sysmone_temp < up_temp_50_h)) begin\n          //PWM DUTY should be 50%\n          pwm_width_req <= PWM_ONTIME_50;\n        end else if ((sysmone_temp > up_temp_75_l) && (sysmone_temp < up_temp_75_h)) begin\n          //PWM DUTY should be 75%\n          pwm_width_req <= PWM_ONTIME_75;\n        end else if (sysmone_temp > up_temp_100_l) begin\n          //PWM DUTY should be 100%\n          pwm_width_req <= PWM_PERIOD;\n          //default to 100% duty cycle after reset if not within temperature intervals described above\n        end else if ((sysmone_temp != 'h0) && (pwm_width == 'h0)) begin\n          pwm_width_req <= PWM_PERIOD;\n        end else begin\n          //if no changes are needed make sure to mantain current pwm\n          pwm_width_req <= pwm_width;\n        end\n        state <= SET_PWM;\n      end\n\n      SET_PWM : begin\n        if ((up_pwm_width != pwm_width) && (up_pwm_width >= pwm_width_req) && (up_pwm_width <= PWM_PERIOD) && (pwm_change_done)) begin\n          pwm_width <= up_pwm_width;\n          pulse_gen_load_config <= 1'b1;\n          //clear alarm when pwm duty changes\n        end else if ((pwm_width != pwm_width_req) && (pwm_width_req > up_pwm_width) && (pwm_change_done)) begin\n          pwm_width <= pwm_width_req;\n          pulse_gen_load_config <= 1'b1;\n          temp_increase_alarm <= 1'b1;\n          //clear alarm when pwm duty changes\n        end\n        state <= EVAL_TACHO;\n      end\n\n      EVAL_TACHO : begin\n        temp_increase_alarm <= 1'b0;\n        //tacho section\n        //check if the fan is turning then see if it is turning correctly\n        if(counter_overflow & pwm_change_done) begin\n          //if overflow is 1 then the fan is not turning so do something\n          tacho_alarm <= 1'b1;\n        end else if (tacho_avg_cnt == AVERAGE_DIV) begin\n          //check rpm according to the current pwm duty cycle\n          //tacho_alarm is only asserted for certain known pwm duty cycles and\n          //for timeout\n          up_tacho_avg_sum <= tacho_avg_sum [AVG_POW + 24 : AVG_POW];\n          tacho_meas_int <= 1'b1;\n          if ((pwm_width == PWM_ONTIME_25) && (up_tacho_en == 0)) begin\n            if ((tacho_avg_sum [AVG_POW + 24 : AVG_POW] > up_tacho_25 + up_tacho_25_tol) || (tacho_avg_sum [AVG_POW + 24 : AVG_POW] < up_tacho_25 - up_tacho_25_tol)) begin\n              //the fan is turning but not as expected\n              tacho_alarm <= 1'b1;\n            end\n          end else if ((pwm_width == PWM_ONTIME_50) && (up_tacho_en == 0)) begin\n            if ((tacho_avg_sum [AVG_POW + 24 : AVG_POW] > up_tacho_50 + up_tacho_50_tol) || (tacho_avg_sum [AVG_POW + 24 : AVG_POW] < up_tacho_50 - up_tacho_50_tol)) begin\n              //the fan is turning but not as expected\n              tacho_alarm <= 1'b1;\n            end\n          end else if ((pwm_width == PWM_ONTIME_75) && (up_tacho_en == 0)) begin\n            if ((tacho_avg_sum [AVG_POW + 24 : AVG_POW] > up_tacho_75 + up_tacho_75_tol) || (tacho_avg_sum [AVG_POW + 24 : AVG_POW] < up_tacho_75 - up_tacho_75_tol)) begin\n              //the fan is turning but not as expected\n              tacho_alarm <= 1'b1;\n            end\n          end else if ((pwm_width == PWM_PERIOD) && (up_tacho_en == 0)) begin\n            if ((tacho_avg_sum [AVG_POW + 24 : AVG_POW] > up_tacho_100 + up_tacho_100_tol) || (tacho_avg_sum [AVG_POW + 24 : AVG_POW] < up_tacho_100 - up_tacho_100_tol)) begin\n              //the fan is turning but not as expected\n              tacho_alarm <= 1'b1;\n            end\n          end else if ((pwm_width == up_pwm_width) && up_tacho_en) begin\n            if ((tacho_avg_sum [AVG_POW + 24 : AVG_POW] > up_tacho_val + up_tacho_tol) || (tacho_avg_sum [AVG_POW + 24 : AVG_POW] < up_tacho_val - up_tacho_tol)) begin\n              //the fan is turning but not as expected\n              tacho_alarm <= 1'b1;\n            end\n          end\n        end\n        state <= DRP_WAIT_FSM_EN;\n      end\n      default :\n        state <= DRP_WAIT_FSM_EN;\n    endcase\n  end\n\n//axi registers write\nalways @(posedge up_clk) begin\n  if (up_resetn == 1'b0) begin\n    up_pwm_width <= 'd0;\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[328, "always @(posedge up_clk)\n"], [329, "  if (up_resetn == 1'b0) begin\n"], [330, "    tacho_alarm <= 'h0;\n"], [331, "    drp_den_reg <= 'h0;\n"], [332, "    drp_dwe_reg <= 'h0;\n"], [333, "    drp_di <= 'h0;\n"], [334, "    tacho_avg_cnt <= 'h0;\n"], [335, "    tacho_avg_sum <= 'h0;\n"], [336, "    tacho_meas_ack <= 'h0;\n"], [337, "    pulse_gen_load_config <= 'h0;\n"], [338, "    sysmone_temp <= 'h0;\n"], [339, "    pwm_width_req <= 'h0;\n"], [340, "    pwm_width <= 'h0;\n"], [341, "    up_tacho_avg_sum <= 'h0;\n"], [342, "    temp_increase_alarm <= 'h0;\n"], [343, "    tacho_meas_int <= 1'b0;\n"], [344, "    state <= INIT;\n"], [345, "  end else begin\n"], [347, "    case (state)\n"], [349, "      INIT : begin\n"], [350, "        if (INTERNAL_SYSMONE == 1) begin\n"], [351, "          drp_daddr <= 8'h40;\n"], [353, "          drp_den_reg <= 2'h2;\n"], [354, "          if (drp_eoc == 1'b1) begin\n"], [355, "            state <= DRP_WAIT_EOC;\n"], [357, "        end else begin\n"], [358, "          state <= DRP_READ_TEMP;\n"], [360, "      end\n"], [362, "      DRP_WAIT_EOC : begin\n"], [363, "        if (drp_eoc == 1'b1) begin\n"], [365, "          drp_di <= drp_do & 16'h03FF;\n"], [366, "          drp_daddr <= 8'h40;\n"], [367, "          drp_den_reg <= 2'h2;\n"], [369, "          drp_dwe_reg <= 2'h2;\n"], [370, "          state <= DRP_WAIT_DRDY;\n"], [371, "        end else begin\n"], [372, "          drp_den_reg <= {1'b0, drp_den_reg[1]};\n"], [373, "          drp_dwe_reg <= {1'b0, drp_dwe_reg[1]};\n"], [375, "      end\n"], [377, "      DRP_WAIT_DRDY : begin\n"], [378, "        if (drp_drdy == 1'b1) begin\n"], [379, "          state <= DRP_READ_TEMP;\n"], [380, "        end else begin\n"], [381, "          drp_den_reg <= {1'b0, drp_den_reg[1]};\n"], [382, "          drp_dwe_reg <= {1'b0, drp_dwe_reg[1]};\n"], [384, "      end\n"], [386, "      DRP_WAIT_FSM_EN : begin\n"], [387, "        tacho_meas_int <= 1'b0;\n"], [388, "        tacho_alarm <= 1'b0;\n"], [389, "        pulse_gen_load_config <= 1'b0;\n"], [390, "        if (presc_reg[15] == 1'b1) begin\n"], [391, "          state <= DRP_READ_TEMP;\n"], [393, "      end\n"], [395, "      DRP_READ_TEMP : begin\n"], [396, "        if (INTERNAL_SYSMONE == 1) begin\n"], [397, "          drp_daddr <= 8'h00;\n"], [399, "          drp_den_reg <= 2'h2;\n"], [400, "          if (drp_eos == 1'b1) begin\n"], [403, "        end else begin\n"], [404, "          state <= DRP_READ_TEMP_WAIT_DRDY;\n"], [406, "      end\n"], [408, "      DRP_READ_TEMP_WAIT_DRDY : begin\n"], [409, "        if (INTERNAL_SYSMONE == 1) begin\n"], [410, "          if (drp_drdy == 1'b1) begin\n"], [411, "            sysmone_temp <= drp_do;\n"], [412, "            state <= GET_TACHO;\n"], [414, "            drp_den_reg <= {1'b0, drp_den_reg[1]};\n"], [415, "            drp_dwe_reg <= {1'b0, drp_dwe_reg[1]};\n"], [417, "        end else begin\n"], [418, "          sysmone_temp <= temp_in;\n"], [419, "          state <= GET_TACHO;\n"], [421, "      end\n"], [423, "      GET_TACHO : begin\n"], [425, "        if ((tacho_avg_cnt == AVERAGE_DIV) || (counter_overflow) || (!pwm_change_done)) begin\n"], [427, "          tacho_avg_sum <= 1'b0;\n"], [428, "          tacho_avg_cnt <= 1'b0;\n"], [429, "          tacho_meas_ack <= 1'b0;\n"], [430, "        end else if ((tacho_meas_new) && (pwm_change_done)) begin\n"], [432, "          tacho_avg_sum <= tacho_avg_sum + tacho_meas;\n"], [433, "          tacho_avg_cnt <= tacho_avg_cnt + 1'b1;\n"], [435, "          tacho_meas_ack <= 1'b1;\n"], [436, "        end else begin\n"], [437, "          tacho_meas_ack <= 1'b0;\n"], [439, "        state <= EVAL_TEMP;\n"], [440, "      end\n"], [442, "      EVAL_TEMP : begin\n"], [445, "        if (sysmone_temp < up_temp_00_h) begin\n"], [447, "          pwm_width_req <= 1'b0;\n"], [448, "        end else if ((sysmone_temp > up_temp_25_l) && (sysmone_temp < up_temp_25_h)) begin\n"], [450, "          pwm_width_req <= PWM_ONTIME_25;\n"], [451, "        end else if ((sysmone_temp > up_temp_50_l) && (sysmone_temp < up_temp_50_h)) begin\n"], [453, "          pwm_width_req <= PWM_ONTIME_50;\n"], [454, "        end else if ((sysmone_temp > up_temp_75_l) && (sysmone_temp < up_temp_75_h)) begin\n"], [456, "          pwm_width_req <= PWM_ONTIME_75;\n"], [457, "        end else if (sysmone_temp > up_temp_100_l) begin\n"], [459, "          pwm_width_req <= PWM_PERIOD;\n"], [461, "        end else if ((sysmone_temp != 'h0) && (pwm_width == 'h0)) begin\n"], [462, "          pwm_width_req <= PWM_PERIOD;\n"], [463, "        end else begin\n"], [465, "          pwm_width_req <= pwm_width;\n"], [467, "        state <= SET_PWM;\n"], [468, "      end\n"], [470, "      SET_PWM : begin\n"], [471, "        if ((up_pwm_width != pwm_width) && (up_pwm_width >= pwm_width_req) && (up_pwm_width <= PWM_PERIOD) && (pwm_change_done)) begin\n"], [472, "          pwm_width <= up_pwm_width;\n"], [473, "          pulse_gen_load_config <= 1'b1;\n"], [475, "        end else if ((pwm_width != pwm_width_req) && (pwm_width_req > up_pwm_width) && (pwm_change_done)) begin\n"], [476, "          pwm_width <= pwm_width_req;\n"], [477, "          pulse_gen_load_config <= 1'b1;\n"], [478, "          temp_increase_alarm <= 1'b1;\n"], [481, "        state <= EVAL_TACHO;\n"], [482, "      end\n"], [484, "      EVAL_TACHO : begin\n"], [485, "        temp_increase_alarm <= 1'b0;\n"], [488, "        if(counter_overflow & pwm_change_done) begin\n"], [490, "          tacho_alarm <= 1'b1;\n"], [491, "        end else if (tacho_avg_cnt == AVERAGE_DIV) begin\n"], [495, "          up_tacho_avg_sum <= tacho_avg_sum [AVG_POW + 24 : AVG_POW];\n"], [496, "          tacho_meas_int <= 1'b1;\n"], [497, "          if ((pwm_width == PWM_ONTIME_25) && (up_tacho_en == 0)) begin\n"], [498, "            if ((tacho_avg_sum [AVG_POW + 24 : AVG_POW] > up_tacho_25 + up_tacho_25_tol) || (tacho_avg_sum [AVG_POW + 24 : AVG_POW] < up_tacho_25 - up_tacho_25_tol)) begin\n"], [500, "              tacho_alarm <= 1'b1;\n"], [501, "            end\n"], [502, "          end else if ((pwm_width == PWM_ONTIME_50) && (up_tacho_en == 0)) begin\n"], [503, "            if ((tacho_avg_sum [AVG_POW + 24 : AVG_POW] > up_tacho_50 + up_tacho_50_tol) || (tacho_avg_sum [AVG_POW + 24 : AVG_POW] < up_tacho_50 - up_tacho_50_tol)) begin\n"], [505, "              tacho_alarm <= 1'b1;\n"], [506, "            end\n"], [507, "          end else if ((pwm_width == PWM_ONTIME_75) && (up_tacho_en == 0)) begin\n"], [508, "            if ((tacho_avg_sum [AVG_POW + 24 : AVG_POW] > up_tacho_75 + up_tacho_75_tol) || (tacho_avg_sum [AVG_POW + 24 : AVG_POW] < up_tacho_75 - up_tacho_75_tol)) begin\n"], [510, "              tacho_alarm <= 1'b1;\n"], [511, "            end\n"], [512, "          end else if ((pwm_width == PWM_PERIOD) && (up_tacho_en == 0)) begin\n"], [513, "            if ((tacho_avg_sum [AVG_POW + 24 : AVG_POW] > up_tacho_100 + up_tacho_100_tol) || (tacho_avg_sum [AVG_POW + 24 : AVG_POW] < up_tacho_100 - up_tacho_100_tol)) begin\n"], [515, "              tacho_alarm <= 1'b1;\n"], [516, "            end\n"], [517, "          end else if ((pwm_width == up_pwm_width) && up_tacho_en) begin\n"], [518, "            if ((tacho_avg_sum [AVG_POW + 24 : AVG_POW] > up_tacho_val + up_tacho_tol) || (tacho_avg_sum [AVG_POW + 24 : AVG_POW] < up_tacho_val - up_tacho_tol)) begin\n"], [520, "              tacho_alarm <= 1'b1;\n"], [524, "        state <= DRP_WAIT_FSM_EN;\n"], [526, "      default :\n"], [527, "        state <= DRP_WAIT_FSM_EN;\n"], [528, "    endcase\n"]], "Add": [[355, "  localparam [31:0] CORE_VERSION            = {16'h0001,     /* MAJOR */\n"], [355, "                                                8'h00,       /* MINOR */\n"], [355, "                                                8'h61};      /* PATCH */ // 0.0.0\n"], [355, "  localparam [31:0] CORE_MAGIC              = 32'h46414E43;    // FANC\n"], [355, "  localparam        CLK_FREQUENCY           = 100000000;\n"], [355, "  localparam        PWM_PERIOD              = CLK_FREQUENCY / PWM_FREQUENCY_HZ;\n"], [355, "  localparam        OVERFLOW_LIM            = CLK_FREQUENCY * 5;\n"], [355, "  localparam        AVERAGE_DIV             = 2**AVG_POW;\n"], [355, "  localparam        THRESH_PWM_000          = (INTERNAL_SYSMONE == 1) ? (((TEMP_00_H + 280.2308787) * 65535) / 509.3140064) : ((TEMP_00_H * 41 + 11195) / 20);\n"], [355, "  localparam        THRESH_PWM_025_L        = (INTERNAL_SYSMONE == 1) ? (((TEMP_25_L + 280.2308787) * 65535) / 509.3140064) : ((TEMP_25_L * 41 + 11195) / 20);\n"], [355, "  localparam        THRESH_PWM_025_H        = (INTERNAL_SYSMONE == 1) ? (((TEMP_25_H + 280.2308787) * 65535) / 509.3140064) : ((TEMP_25_H * 41 + 11195) / 20);\n"], [355, "  localparam        THRESH_PWM_050_L        = (INTERNAL_SYSMONE == 1) ? (((TEMP_50_L + 280.2308787) * 65535) / 509.3140064) : ((TEMP_50_L * 41 + 11195) / 20);\n"], [355, "  localparam        THRESH_PWM_050_H        = (INTERNAL_SYSMONE == 1) ? (((TEMP_50_H + 280.2308787) * 65535) / 509.3140064) : ((TEMP_50_H * 41 + 11195) / 20);\n"], [355, "  localparam        THRESH_PWM_075_L        = (INTERNAL_SYSMONE == 1) ? (((TEMP_75_L + 280.2308787) * 65535) / 509.3140064) : ((TEMP_75_L * 41 + 11195) / 20);\n"], [355, "  localparam        THRESH_PWM_075_H        = (INTERNAL_SYSMONE == 1) ? (((TEMP_75_H + 280.2308787) * 65535) / 509.3140064) : ((TEMP_75_H * 41 + 11195) / 20);\n"], [355, "  localparam        THRESH_PWM_100          = (INTERNAL_SYSMONE == 1) ? (((TEMP_00_L + 280.2308787) * 65535) / 509.3140064) : ((TEMP_00_L * 41 + 11195) / 20);\n"], [355, "  localparam        PWM_ONTIME_25           = PWM_PERIOD / 4;\n"], [355, "  localparam        PWM_ONTIME_50           = PWM_PERIOD / 2;\n"], [355, "  localparam        PWM_ONTIME_75           = PWM_PERIOD * 3 / 4;\n"], [355, "  localparam        TACHO_T25_TOL           = TACHO_T25 * TACHO_TOL_PERCENT / 100;\n"], [355, "  localparam        TACHO_T50_TOL           = TACHO_T50 * TACHO_TOL_PERCENT / 100;\n"], [355, "  localparam        TACHO_T75_TOL           = TACHO_T75 * TACHO_TOL_PERCENT / 100;\n"], [355, "  localparam        TACHO_T100_TOL          = TACHO_T100 * TACHO_TOL_PERCENT / 100;\n"], [355, "  localparam        INIT                    = 8'h00;\n"], [355, "  localparam        DRP_WAIT_EOC            = 8'h01;\n"], [355, "  localparam        DRP_WAIT_DRDY           = 8'h02;\n"], [355, "  localparam        DRP_WAIT_FSM_EN         = 8'h03;\n"], [355, "  localparam        DRP_READ_TEMP           = 8'h04;\n"], [355, "  localparam        DRP_READ_TEMP_WAIT_DRDY = 8'h05;\n"], [355, "  localparam        GET_TACHO               = 8'h06;\n"], [355, "  localparam        EVAL_TEMP               = 8'h07;\n"], [355, "  localparam        SET_PWM                 = 8'h08;\n"], [355, "  localparam        EVAL_TACHO              = 8'h09;\n"], [355, "  reg   [31:0]  up_scratch = 'd0;\n"], [355, "  reg   [7:0]   state = INIT;\n"], [355, "  reg   [7:0]   drp_daddr = 'h0;\n"], [355, "  reg   [15:0]  drp_di = 'h0;\n"], [355, "  reg   [1:0]   drp_den_reg = 'h0;\n"], [355, "  reg   [1:0]   drp_dwe_reg = 'h0;\n"], [355, "  reg   [15:0]  sysmone_temp = 'h0;\n"], [355, "  reg           temp_increase_alarm = 'h0;\n"], [355, "  reg           tacho_alarm = 'h0;\n"], [355, "  reg   [31:0]  up_tacho_val = 'h0;\n"], [355, "  reg   [31:0]  up_tacho_tol = 'h0;\n"], [355, "  reg           up_tacho_en = 'h0;\n"], [355, "  reg   [7:0]   tacho_avg_cnt = 'h0;\n"], [355, "  reg   [31:0]  tacho_avg_sum = 'h0;\n"], [355, "  reg   [31:0]  tacho_meas = 'h0;\n"], [355, "  reg           tacho_delayed = 'h0;\n"], [355, "  reg           tacho_meas_new = 'h0;\n"], [355, "  reg           tacho_meas_ack = 'h0;\n"], [355, "  reg           tacho_edge_det = 'h0;\n"], [355, "  reg   [31:0]  up_tacho_avg_sum = 'h0;\n"], [355, "  reg   [31:0]  counter_reg = 'h0;\n"], [355, "  reg   [31:0]  pwm_width = 'h0;\n"], [355, "  reg   [31:0]  pwm_width_req = 'h0;\n"], [355, "  reg           counter_overflow = 'h0;\n"], [355, "  reg           pwm_change_done = 1'b1;\n"], [355, "  reg           pulse_gen_load_config = 'h0;\n"], [355, "  reg           tacho_meas_int = 'h0;\n"], [355, "  reg   [15:0]  presc_reg = 'h0;\n"], [355, "  reg   [31:0]  up_pwm_width = 'd0;\n"], [355, "  reg   [31:0]  up_temp_00_h  = THRESH_PWM_000  ;\n"], [355, "  reg   [31:0]  up_temp_25_l  = THRESH_PWM_025_L;\n"], [355, "  reg   [31:0]  up_temp_25_h  = THRESH_PWM_025_H;\n"], [355, "  reg   [31:0]  up_temp_50_l  = THRESH_PWM_050_L;\n"], [355, "  reg   [31:0]  up_temp_50_h  = THRESH_PWM_050_H;\n"], [355, "  reg   [31:0]  up_temp_75_l  = THRESH_PWM_075_L;\n"], [355, "  reg   [31:0]  up_temp_75_h  = THRESH_PWM_075_H;\n"], [355, "  reg   [31:0]  up_temp_100_l = THRESH_PWM_100  ;\n"], [355, "  reg   [31:0]  up_tacho_25 = TACHO_T25;\n"], [355, "  reg   [31:0]  up_tacho_50 = TACHO_T50;\n"], [355, "  reg   [31:0]  up_tacho_75 = TACHO_T75;\n"], [355, "  reg   [31:0]  up_tacho_100 = TACHO_T100;\n"], [355, "  reg   [31:0]  up_tacho_25_tol = TACHO_T25 * TACHO_TOL_PERCENT / 100;\n"], [355, "  reg   [31:0]  up_tacho_50_tol = TACHO_T50 * TACHO_TOL_PERCENT / 100;\n"], [355, "  reg   [31:0]  up_tacho_75_tol = TACHO_T75 * TACHO_TOL_PERCENT / 100;\n"], [355, "  reg   [31:0]  up_tacho_100_tol = TACHO_T100 * TACHO_TOL_PERCENT / 100;\n"], [355, "  reg           up_wack = 'd0;\n"], [355, "  reg   [31:0]  up_rdata = 'd0;\n"], [355, "  reg           up_rack = 'd0;\n"], [355, "  reg           up_resetn = 1'b0;\n"], [355, "  reg   [3:0]   up_irq_mask = 4'b1111;\n"], [355, "  reg   [3:0]   up_irq_source = 4'h0;\n"], [355, "  wire          counter_resetn;\n"], [355, "  wire  [15:0]  drp_do;\n"], [355, "  wire          drp_drdy;\n"], [355, "  wire          drp_eoc;\n"], [355, "  wire          drp_eos;\n"], [355, "  wire          pwm_change_done_int;\n"], [355, "  wire          pulse_gen_out;\n"], [355, "  wire          up_clk;\n"], [355, "  wire          up_rreq_s;\n"], [355, "  wire  [7:0]   up_raddr_s;\n"], [355, "  wire          up_wreq_s;\n"], [355, "  wire  [7:0]   up_waddr_s;\n"], [355, "  wire  [31:0]  up_wdata_s;\n"], [355, "  wire  [3:0]   up_irq_pending;\n"], [355, "  wire  [3:0]   up_irq_trigger;\n"], [355, "  wire  [3:0]   up_irq_source_clear;\n"], [355, "  assign up_clk = s_axi_aclk;\n"], [355, "  assign pwm = ~pulse_gen_out & up_resetn; //reverse polarity because the board is also reversing it\n"], [355, "  assign pwm_change_done_int = counter_overflow & !pwm_change_done;\n"], [355, "  assign up_irq_pending = ~up_irq_mask & up_irq_source;\n"], [355, "  assign up_irq_trigger  = {tacho_meas_int, temp_increase_alarm, tacho_alarm, pwm_change_done_int};\n"], [355, "  assign up_irq_source_clear = (up_wreq_s == 1'b1 && up_waddr_s == 8'h11) ? up_wdata_s[3:0] : 4'b0000;\n"], [355, "  assign counter_resetn = (pwm_change_done ) ? (!tacho_edge_det) : ((!pwm_change_done) & (!counter_overflow));\n"], [355, "  up_axi #(\n"], [355, "    .AXI_ADDRESS_WIDTH(10)\n"], [355, "  ) i_up_axi (\n"], [355, "    .up_rstn (s_axi_aresetn),\n"], [355, "    .up_clk (up_clk),\n"], [355, "    .up_axi_awvalid (s_axi_awvalid),\n"], [355, "    .up_axi_awaddr (s_axi_awaddr),\n"], [355, "    .up_axi_awready (s_axi_awready),\n"], [355, "    .up_axi_wvalid (s_axi_wvalid),\n"], [355, "    .up_axi_wdata (s_axi_wdata),\n"], [355, "    .up_axi_wstrb (s_axi_wstrb),\n"], [355, "    .up_axi_wready (s_axi_wready),\n"], [355, "    .up_axi_bvalid (s_axi_bvalid),\n"], [355, "    .up_axi_bresp (s_axi_bresp),\n"], [355, "    .up_axi_bready (s_axi_bready),\n"], [355, "    .up_axi_arvalid (s_axi_arvalid),\n"], [355, "    .up_axi_araddr (s_axi_araddr),\n"], [355, "    .up_axi_arready (s_axi_arready),\n"], [355, "    .up_axi_rvalid (s_axi_rvalid),\n"], [355, "    .up_axi_rresp (s_axi_rresp),\n"], [355, "    .up_axi_rdata (s_axi_rdata),\n"], [355, "    .up_axi_rready (s_axi_rready),\n"], [355, "    .up_wreq (up_wreq_s),\n"], [355, "    .up_waddr (up_waddr_s),\n"], [355, "    .up_wdata (up_wdata_s),\n"], [355, "    .up_wack (up_wack),\n"], [355, "    .up_rreq (up_rreq_s),\n"], [355, "    .up_raddr (up_raddr_s),\n"], [355, "    .up_rdata (up_rdata),\n"], [355, "    .up_rack (up_rack));\n"], [355, "  generate\n"], [355, "  if (INTERNAL_SYSMONE == 1) begin\n"], [355, "    SYSMONE4 #(\n"], [355, "      .COMMON_N_SOURCE(16'hFFFF),\n"], [355, "      .INIT_40(16'h1000), // config reg 0\n"], [355, "      .INIT_41(16'h2F9F), // config reg 1\n"], [355, "      .INIT_42(16'h1400), // config reg 2\n"], [355, "      .INIT_43(16'h200F), // config reg 3\n"], [355, "      .INIT_44(16'h0000), // config reg 4\n"], [355, "      .INIT_45(16'hE200), // Analog Bus Register\n"], [355, "      .INIT_46(16'h0000), // Sequencer Channel selection (Vuser0-3)\n"], [355, "      .INIT_47(16'h0000), // Sequencer Average selection (Vuser0-3)\n"], [355, "      .INIT_48(16'h0101), // Sequencer channel selection\n"], [355, "      .INIT_49(16'h0000), // Sequencer channel selection\n"], [355, "      .INIT_4A(16'h0000), // Sequencer Average selection\n"], [355, "      .INIT_4B(16'h0000), // Sequencer Average selection\n"], [355, "      .INIT_4C(16'h0000), // Sequencer Bipolar selection\n"], [355, "      .INIT_4D(16'h0000), // Sequencer Bipolar selection\n"], [355, "      .INIT_4E(16'h0000), // Sequencer Acq time selection\n"], [355, "      .INIT_4F(16'h0000), // Sequencer Acq time selection\n"], [355, "      .INIT_50(16'hB794), // Temp alarm trigger\n"], [355, "      .INIT_51(16'h4E81), // Vccint upper alarm limit\n"], [355, "      .INIT_52(16'hA147), // Vccaux upper alarm limit\n"], [355, "      .INIT_53(16'hBF13), // Temp alarm OT upper\n"], [355, "      .INIT_54(16'hAB02), // Temp alarm reset\n"], [355, "      .INIT_55(16'h4963), // Vccint lower alarm limit\n"], [355, "      .INIT_56(16'h9555), // Vccaux lower alarm limit\n"], [355, "      .INIT_57(16'hB00A), // Temp alarm OT reset\n"], [355, "      .INIT_58(16'h4E81), // VCCBRAM upper alarm limit\n"], [355, "      .INIT_5C(16'h4963), // VCCBRAM lower alarm limit\n"], [355, "      .INIT_59(16'h4963), // vccpsintlp upper alarm limit\n"], [355, "      .INIT_5D(16'h451E), // vccpsintlp lower alarm limit\n"], [355, "      .INIT_5A(16'h4963), // vccpsintfp upper alarm limit\n"], [355, "      .INIT_5E(16'h451E), // vccpsintfp lower alarm limit\n"], [355, "      .INIT_5B(16'h9A74), // vccpsaux upper alarm limit\n"], [355, "      .INIT_5F(16'h91EB), // vccpsaux lower alarm limit\n"], [355, "      .INIT_60(16'h4D39), // Vuser0 upper alarm limit\n"], [355, "      .INIT_61(16'h4DA7), // Vuser1 upper alarm limit\n"], [355, "      .INIT_62(16'h9A74), // Vuser2 upper alarm limit\n"], [355, "      .INIT_63(16'h9A74), // Vuser3 upper alarm limit\n"], [355, "      .INIT_68(16'h4C5E), // Vuser0 lower alarm limit\n"], [355, "      .INIT_69(16'h4BF2), // Vuser1 lower alarm limit\n"], [355, "      .INIT_6A(16'h98BF), // Vuser2 lower alarm limit\n"], [355, "      .INIT_6B(16'h98BF), // Vuser3 lower alarm limit\n"], [355, "      .INIT_7A(16'h0000), // DUAL0 Register\n"], [355, "      .INIT_7B(16'h0000), // DUAL1 Register\n"], [355, "      .INIT_7C(16'h0000), // DUAL2 Register\n"], [355, "      .INIT_7D(16'h0000), // DUAL3 Register\n"], [355, "      .SIM_DEVICE(\"ZYNQ_ULTRASCALE\"),\n"], [355, "      .SIM_MONITOR_FILE(\"design.txt\")\n"], [355, "    ) inst_sysmon (\n"], [355, "      .DADDR(drp_daddr),\n"], [355, "      .DCLK(up_clk),\n"], [355, "      .DEN(drp_den_reg[0]),\n"], [355, "      .DI(drp_di),\n"], [355, "      .DWE(drp_dwe_reg[0]),\n"], [355, "      .RESET(!up_resetn),\n"], [355, "      .DO(drp_do),\n"], [355, "      .DRDY(drp_drdy),\n"], [355, "      .EOC(drp_eoc),\n"], [355, "      .EOS(drp_eos));\n"], [355, "  end\n"], [355, "  endgenerate\n"], [355, "  util_pulse_gen #(\n"], [355, "    .PULSE_WIDTH(0),\n"], [355, "    .PULSE_PERIOD(0)\n"], [355, "  ) util_pulse_gen_i(\n"], [355, "    .clk (up_clk),\n"], [355, "    .rstn (up_resetn),\n"], [355, "    .pulse_width (pwm_width),\n"], [355, "    .pulse_period (PWM_PERIOD),\n"], [355, "    .load_config (pulse_gen_load_config),\n"], [355, "    .pulse (pulse_gen_out));\n"], [355, "  always @(posedge up_clk)\n"], [355, "    if (up_resetn == 1'b0) begin\n"], [355, "      tacho_alarm <= 'h0;\n"], [355, "      drp_den_reg <= 'h0;\n"], [355, "      drp_dwe_reg <= 'h0;\n"], [355, "      drp_di <= 'h0;\n"], [355, "      tacho_avg_cnt <= 'h0;\n"], [355, "      tacho_avg_sum <= 'h0;\n"], [355, "      tacho_meas_ack <= 'h0;\n"], [355, "      pulse_gen_load_config <= 'h0;\n"], [355, "      sysmone_temp <= 'h0;\n"], [355, "      pwm_width_req <= 'h0;\n"], [355, "      pwm_width <= 'h0;\n"], [355, "      up_tacho_avg_sum <= 'h0;\n"], [355, "      temp_increase_alarm <= 'h0;\n"], [355, "      tacho_meas_int <= 1'b0;\n"], [355, "      state <= INIT;\n"], [355, "    end else begin\n"], [355, "      case (state)\n"], [355, "        INIT : begin\n"], [355, "          if (INTERNAL_SYSMONE == 1) begin\n"], [355, "            drp_daddr <= 8'h40;\n"], [355, "            drp_den_reg <= 2'h2;\n"], [355, "            if (drp_eoc == 1'b1) begin\n"], [355, "              state <= DRP_WAIT_EOC;\n"], [355, "            end\n"], [355, "          end else begin\n"], [355, "            state <= DRP_READ_TEMP;\n"], [373, "        DRP_WAIT_EOC : begin\n"], [373, "          if (drp_eoc == 1'b1) begin\n"], [373, "            drp_di <= drp_do & 16'h03FF;\n"], [373, "            drp_daddr <= 8'h40;\n"], [373, "            drp_den_reg <= 2'h2;\n"], [373, "            drp_dwe_reg <= 2'h2;\n"], [373, "            state <= DRP_WAIT_DRDY;\n"], [373, "          end else begin\n"], [373, "            drp_den_reg <= {1'b0, drp_den_reg[1]};\n"], [373, "            drp_dwe_reg <= {1'b0, drp_dwe_reg[1]};\n"], [373, "          end\n"], [382, "        DRP_WAIT_DRDY : begin\n"], [382, "          if (drp_drdy == 1'b1) begin\n"], [382, "            state <= DRP_READ_TEMP;\n"], [382, "          end else begin\n"], [382, "            drp_den_reg <= {1'b0, drp_den_reg[1]};\n"], [382, "            drp_dwe_reg <= {1'b0, drp_dwe_reg[1]};\n"], [382, "          end\n"], [391, "        DRP_WAIT_FSM_EN : begin\n"], [391, "          tacho_meas_int <= 1'b0;\n"], [391, "          tacho_alarm <= 1'b0;\n"], [391, "          pulse_gen_load_config <= 1'b0;\n"], [391, "          if (presc_reg[15] == 1'b1) begin\n"], [391, "            state <= DRP_READ_TEMP;\n"], [391, "          end\n"], [400, "        DRP_READ_TEMP : begin\n"], [400, "          if (INTERNAL_SYSMONE == 1) begin\n"], [400, "            drp_daddr <= 8'h00;\n"], [400, "            drp_den_reg <= 2'h2;\n"], [400, "            if (drp_eos == 1'b1) begin\n"], [400, "              state <= DRP_READ_TEMP_WAIT_DRDY;\n"], [400, "            end\n"], [400, "          end else begin\n"], [412, "        DRP_READ_TEMP_WAIT_DRDY : begin\n"], [412, "          if (INTERNAL_SYSMONE == 1) begin\n"], [412, "            if (drp_drdy == 1'b1) begin\n"], [412, "              sysmone_temp <= drp_do;\n"], [412, "              state <= GET_TACHO;\n"], [412, "            end else begin\n"], [412, "              drp_den_reg <= {1'b0, drp_den_reg[1]};\n"], [412, "              drp_dwe_reg <= {1'b0, drp_dwe_reg[1]};\n"], [412, "            end\n"], [415, "            sysmone_temp <= temp_in;\n"], [415, "            state <= GET_TACHO;\n"], [437, "        GET_TACHO : begin\n"], [437, "          if ((tacho_avg_cnt == AVERAGE_DIV) || (counter_overflow) || (!pwm_change_done)) begin\n"], [437, "            tacho_avg_sum <= 1'b0;\n"], [437, "            tacho_avg_cnt <= 1'b0;\n"], [437, "            tacho_meas_ack <= 1'b0;\n"], [437, "          end else if ((tacho_meas_new) && (pwm_change_done)) begin\n"], [437, "            tacho_avg_sum <= tacho_avg_sum + tacho_meas;\n"], [437, "            tacho_avg_cnt <= tacho_avg_cnt + 1'b1;\n"], [437, "            tacho_meas_ack <= 1'b1;\n"], [437, "          end else begin\n"], [437, "            tacho_meas_ack <= 1'b0;\n"], [437, "          end\n"], [437, "          state <= EVAL_TEMP;\n"], [465, "        EVAL_TEMP : begin\n"], [465, "          if (sysmone_temp < up_temp_00_h) begin\n"], [465, "            pwm_width_req <= 1'b0;\n"], [465, "          end else if ((sysmone_temp > up_temp_25_l) && (sysmone_temp < up_temp_25_h)) begin\n"], [465, "            pwm_width_req <= PWM_ONTIME_25;\n"], [465, "          end else if ((sysmone_temp > up_temp_50_l) && (sysmone_temp < up_temp_50_h)) begin\n"], [465, "            pwm_width_req <= PWM_ONTIME_50;\n"], [465, "          end else if ((sysmone_temp > up_temp_75_l) && (sysmone_temp < up_temp_75_h)) begin\n"], [465, "            pwm_width_req <= PWM_ONTIME_75;\n"], [465, "          end else if (sysmone_temp > up_temp_100_l) begin\n"], [465, "            pwm_width_req <= PWM_PERIOD;\n"], [465, "          end else if ((sysmone_temp != 'h0) && (pwm_width == 'h0)) begin\n"], [465, "            pwm_width_req <= PWM_PERIOD;\n"], [465, "          end else begin\n"], [465, "            pwm_width_req <= pwm_width;\n"], [465, "          end\n"], [465, "          state <= SET_PWM;\n"], [478, "        SET_PWM : begin\n"], [478, "          if ((up_pwm_width != pwm_width) && (up_pwm_width >= pwm_width_req) && (up_pwm_width <= PWM_PERIOD) && (pwm_change_done)) begin\n"], [478, "            pwm_width <= up_pwm_width;\n"], [478, "            pulse_gen_load_config <= 1'b1;\n"], [478, "          end else if ((pwm_width != pwm_width_req) && (pwm_width_req > up_pwm_width) && (pwm_change_done)) begin\n"], [478, "            pwm_width <= pwm_width_req;\n"], [478, "            pulse_gen_load_config <= 1'b1;\n"], [478, "            temp_increase_alarm <= 1'b1;\n"], [478, "          end\n"], [478, "          state <= EVAL_TACHO;\n"], [520, "        EVAL_TACHO : begin\n"], [520, "          temp_increase_alarm <= 1'b0;\n"], [520, "          if(counter_overflow & pwm_change_done) begin\n"], [520, "            tacho_alarm <= 1'b1;\n"], [520, "          end else if (tacho_avg_cnt == AVERAGE_DIV) begin\n"], [520, "            up_tacho_avg_sum <= tacho_avg_sum [AVG_POW + 24 : AVG_POW];\n"], [520, "            tacho_meas_int <= 1'b1;\n"], [520, "            if ((pwm_width == PWM_ONTIME_25) && (up_tacho_en == 0)) begin\n"], [520, "              if ((tacho_avg_sum [AVG_POW + 24 : AVG_POW] > up_tacho_25 + up_tacho_25_tol) || (tacho_avg_sum [AVG_POW + 24 : AVG_POW] < up_tacho_25 - up_tacho_25_tol)) begin\n"], [520, "                tacho_alarm <= 1'b1;\n"], [520, "              end\n"], [520, "            end else if ((pwm_width == PWM_ONTIME_50) && (up_tacho_en == 0)) begin\n"], [520, "              if ((tacho_avg_sum [AVG_POW + 24 : AVG_POW] > up_tacho_50 + up_tacho_50_tol) || (tacho_avg_sum [AVG_POW + 24 : AVG_POW] < up_tacho_50 - up_tacho_50_tol)) begin\n"], [520, "                tacho_alarm <= 1'b1;\n"], [520, "              end\n"], [520, "            end else if ((pwm_width == PWM_ONTIME_75) && (up_tacho_en == 0)) begin\n"], [520, "              if ((tacho_avg_sum [AVG_POW + 24 : AVG_POW] > up_tacho_75 + up_tacho_75_tol) || (tacho_avg_sum [AVG_POW + 24 : AVG_POW] < up_tacho_75 - up_tacho_75_tol)) begin\n"], [520, "                tacho_alarm <= 1'b1;\n"], [520, "              end\n"], [520, "            end else if ((pwm_width == PWM_PERIOD) && (up_tacho_en == 0)) begin\n"], [520, "              if ((tacho_avg_sum [AVG_POW + 24 : AVG_POW] > up_tacho_100 + up_tacho_100_tol) || (tacho_avg_sum [AVG_POW + 24 : AVG_POW] < up_tacho_100 - up_tacho_100_tol)) begin\n"], [520, "                tacho_alarm <= 1'b1;\n"], [520, "              end\n"], [520, "            end else if ((pwm_width == up_pwm_width) && up_tacho_en) begin\n"], [520, "              if ((tacho_avg_sum [AVG_POW + 24 : AVG_POW] > up_tacho_val + up_tacho_tol) || (tacho_avg_sum [AVG_POW + 24 : AVG_POW] < up_tacho_val - up_tacho_tol)) begin\n"], [520, "                tacho_alarm <= 1'b1;\n"], [520, "              end\n"], [522, "          state <= DRP_WAIT_FSM_EN;\n"], [524, "        default :\n"], [524, "          state <= DRP_WAIT_FSM_EN;\n"], [524, "      endcase\n"], [524, "    end\n"], [524, "  always @(posedge up_clk) begin\n"], [524, "    if (up_resetn == 1'b0) begin\n"], [524, "      up_pwm_width <= 'd0;\n"], [524, "      up_tacho_val <= 'd0;\n"], [524, "      up_tacho_tol <= 'd0;\n"], [524, "      up_tacho_en <= 'd0;\n"], [524, "      up_scratch <= 'd0;\n"], [524, "      up_temp_00_h <= THRESH_PWM_000;\n"], [524, "      up_temp_25_l <= THRESH_PWM_025_L;\n"], [524, "      up_temp_25_h <= THRESH_PWM_025_H;\n"], [524, "      up_temp_50_l <= THRESH_PWM_050_L;\n"], [524, "      up_temp_50_h <= THRESH_PWM_050_H;\n"], [524, "      up_temp_75_l <= THRESH_PWM_075_L;\n"], [524, "      up_temp_75_h <= THRESH_PWM_075_H;\n"], [524, "      up_temp_100_l <= THRESH_PWM_100;\n"], [524, "      up_tacho_25 <= TACHO_T25;\n"], [524, "      up_tacho_50 <= TACHO_T50;\n"], [524, "      up_tacho_75 <= TACHO_T75;\n"], [524, "      up_tacho_100 <= TACHO_T100;\n"], [524, "      up_tacho_25_tol <= TACHO_T25 * TACHO_TOL_PERCENT / 100;\n"], [524, "      up_tacho_50_tol <= TACHO_T50 * TACHO_TOL_PERCENT / 100;\n"], [524, "      up_tacho_75_tol <= TACHO_T75 * TACHO_TOL_PERCENT / 100;\n"], [524, "      up_tacho_100_tol <= TACHO_T100 * TACHO_TOL_PERCENT / 100;\n"], [524, "      up_irq_mask <= 4'b1111;\n"], [524, "    end else begin\n"], [524, "      if ((up_wreq_s == 1'b1) && (up_waddr_s == 8'h02)) begin\n"], [524, "        up_scratch <= up_wdata_s;\n"], [524, "      end\n"], [524, "      if ((up_wreq_s == 1'b1) && (up_waddr_s == 8'h21)) begin\n"], [524, "        up_pwm_width <= up_wdata_s;\n"], [524, "        up_tacho_en <= 1'b0;\n"], [524, "      end\n"], [524, "      if ((up_wreq_s == 1'b1) && (up_waddr_s == 8'h22)) begin\n"], [524, "        up_tacho_val <= up_wdata_s;\n"], [524, "      end\n"], [524, "      if ((up_wreq_s == 1'b1) && (up_waddr_s == 8'h23)) begin\n"], [524, "        up_tacho_tol <= up_wdata_s;\n"], [524, "        up_tacho_en <= 1'b1;\n"], [524, "      end else if (temp_increase_alarm) begin\n"], [524, "        up_tacho_en <= 1'b0;\n"], [524, "      end\n"], [524, "      if ((up_wreq_s == 1'b1) && (up_waddr_s == 8'h40)) begin\n"], [524, "        up_temp_00_h <= up_wdata_s;\n"], [524, "      end\n"], [524, "      if ((up_wreq_s == 1'b1) && (up_waddr_s == 8'h41)) begin\n"], [524, "        up_temp_25_l <= up_wdata_s;\n"], [528, "      if ((up_wreq_s == 1'b1) && (up_waddr_s == 8'h42)) begin\n"], [528, "        up_temp_25_h <= up_wdata_s;\n"], [528, "      end\n"], [528, "      if ((up_wreq_s == 1'b1) && (up_waddr_s == 8'h43)) begin\n"], [528, "        up_temp_50_l <= up_wdata_s;\n"], [528, "      end\n"], [528, "      if ((up_wreq_s == 1'b1) && (up_waddr_s == 8'h44)) begin\n"], [528, "        up_temp_50_h <= up_wdata_s;\n"], [528, "      end\n"], [528, "      if ((up_wreq_s == 1'b1) && (up_waddr_s == 8'h45)) begin\n"], [528, "        up_temp_75_l <= up_wdata_s;\n"], [528, "      end\n"], [528, "      if ((up_wreq_s == 1'b1) && (up_waddr_s == 8'h46)) begin\n"], [528, "        up_temp_75_h <= up_wdata_s;\n"], [528, "      end\n"], [528, "      if ((up_wreq_s == 1'b1) && (up_waddr_s == 8'h47)) begin\n"], [528, "        up_temp_100_l <= up_wdata_s;\n"], [528, "      end\n"], [528, "      if ((up_wreq_s == 1'b1) && (up_waddr_s == 8'h50)) begin\n"], [528, "        up_tacho_25 <= up_wdata_s;\n"], [528, "      end\n"], [528, "      if ((up_wreq_s == 1'b1) && (up_waddr_s == 8'h51)) begin\n"], [528, "        up_tacho_50 <= up_wdata_s;\n"], [528, "      end\n"], [528, "      if ((up_wreq_s == 1'b1) && (up_waddr_s == 8'h52)) begin\n"], [528, "        up_tacho_75 <= up_wdata_s;\n"], [528, "      end\n"], [528, "      if ((up_wreq_s == 1'b1) && (up_waddr_s == 8'h53)) begin\n"], [528, "        up_tacho_100 <= up_wdata_s;\n"], [528, "      end\n"], [528, "      if ((up_wreq_s == 1'b1) && (up_waddr_s == 8'h54)) begin\n"], [528, "        up_tacho_25_tol <= up_wdata_s;\n"], [528, "      end\n"], [528, "      if ((up_wreq_s == 1'b1) && (up_waddr_s == 8'h55)) begin\n"], [528, "        up_tacho_50_tol <= up_wdata_s;\n"], [528, "      end\n"], [528, "      if ((up_wreq_s == 1'b1) && (up_waddr_s == 8'h56)) begin\n"], [528, "        up_tacho_75_tol <= up_wdata_s;\n"], [528, "      end\n"], [528, "      if ((up_wreq_s == 1'b1) && (up_waddr_s == 8'h57)) begin\n"], [528, "        up_tacho_100_tol <= up_wdata_s;\n"], [528, "      end\n"], [528, "      if ((up_wreq_s == 1'b1) && (up_waddr_s == 8'h10)) begin\n"], [528, "        up_irq_mask <= up_wdata_s[3:0];\n"], [528, "      end\n"], [528, "    end\n"]]}}