{"Source Block": ["hdl/library/common/ad_iqcor.v@97:199@HdlStmFor", "    iqcor_coeff_2_r <= iqcor_coeff_2;\n  end\n\n  genvar i;\n  generate\n    for (i=0; i<DPW; i=i+1) begin : g_loop\n      wire    [CR-1:0]  data_i_s;\n      wire    [CR-1:0]  data_q_s;\n      wire    [CR-1:0]  p1_data_i_s;\n      wire              p1_valid_s;\n      wire    [33:0]  p1_data_p_i_s;\n      wire    [33:0]  p1_data_p_q_s;\n\n      wire    [CR-1:0]  p1_data_q_s;\n      wire    [CR-1:0]  p1_data_i_int;\n      wire    [CR-1:0]  p1_data_q_int;\n\n      reg             p1_valid = 'd0;\n      reg     [33:0]  p1_data_p = 'd0;\n      reg             valid_int = 'd0;\n      reg     [CR-1:0]  data_int = 'd0;\n\n      // swap i & q\n      assign data_i_s = (Q_OR_I_N == 1 && SCALE_ONLY == 1'b0) ? data_iq[i*CR+:CR] : data_in[i*CR+:CR];\n      assign data_q_s = (Q_OR_I_N == 1) ? data_in[i*CR+:CR] : data_iq[i*CR+:CR];\n\n      // scaling functions - i\n\n      ad_mul #(.DELAY_DATA_WIDTH(CR+1)) i_mul_i (\n        .clk (clk),\n        .data_a ({data_i_s[CR-1], data_i_s, {16-CR{1'b0}}}),\n        .data_b ({iqcor_coeff_1_r[15], iqcor_coeff_1_r}),\n        .data_p (p1_data_p_i_s),\n        .ddata_in ({valid, data_i_s}),\n        .ddata_out ({p1_valid_s, p1_data_i_s}));\n\n      if (SCALE_ONLY == 0) begin\n        // scaling functions - q\n\n        ad_mul #(.DELAY_DATA_WIDTH(CR)) i_mul_q (\n          .clk (clk),\n          .data_a ({data_q_s[CR-1], data_q_s, {16-CR{1'b0}}}),\n          .data_b ({iqcor_coeff_2_r[15], iqcor_coeff_2_r}),\n          .data_p (p1_data_p_q_s),\n          .ddata_in (data_q_s),\n          .ddata_out (p1_data_q_s));\n\n      // sum\n      end else begin\n        assign p1_data_p_q_s = 34'h0;\n        assign p1_data_q_s = {CR{1'b0}};\n      end\n\n\n      if (Q_OR_I_N == 1 && SCALE_ONLY == 0) begin\n        reg [CR-1:0]  p1_data_q = 'd0;\n\n        always @(posedge clk) begin\n          p1_data_q <= p1_data_q_s;\n        end\n\n        assign p1_data_i_int = {CR{1'b0}};\n        assign p1_data_q_int = p1_data_q;\n\n      // sum\n      end else begin\n        reg [CR-1:0]  p1_data_i = 'd0;\n\n        always @(posedge clk) begin\n          p1_data_i <= p1_data_i_s;\n        end\n\n        assign p1_data_i_int = p1_data_i;\n        assign p1_data_q_int = {CR{1'b0}};\n      end\n\n      always @(posedge clk) begin\n        p1_valid <= p1_valid_s;\n        p1_data_p <= p1_data_p_i_s + p1_data_p_q_s;\n      end\n\n      // output registers\n\n      always @(posedge clk) begin\n        valid_int <= p1_valid;\n        if (iqcor_enable == 1'b1) begin\n          data_int <= p1_data_p[29-:CR];\n        end else if (Q_OR_I_N == 1 && SCALE_ONLY == 0) begin\n          data_int <= p1_data_q_int;\n        end else begin\n          data_int <= p1_data_i_int;\n        end\n      end\n\n      assign valid_int_loc[i] = valid_int;\n      assign data_int_loc[i*CR+:CR] = data_int;\n\n    end\n  endgenerate\n\nendmodule\n\n// ***************************************************************************\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[125, "      ad_mul #(.DELAY_DATA_WIDTH(CR+1)) i_mul_i (\n"], [136, "        ad_mul #(.DELAY_DATA_WIDTH(CR)) i_mul_q (\n"]], "Add": [[125, "      ad_mul #(\n"], [125, "        .DELAY_DATA_WIDTH(CR+1)\n"], [125, "      ) i_mul_i (\n"], [136, "        ad_mul #(\n"], [136, "          .DELAY_DATA_WIDTH(CR)\n"], [136, "        ) i_mul_q (\n"]]}}