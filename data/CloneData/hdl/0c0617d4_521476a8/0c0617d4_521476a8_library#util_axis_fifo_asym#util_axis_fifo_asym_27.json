{"Source Block": ["hdl/library/util_axis_fifo_asym/util_axis_fifo_asym.v@141:201@HdlStmIf", "endgenerate\n\n// write or slave logic\ngenerate\n\n  if (RATIO_TYPE) begin : big_slave\n\n\n    for (i=0; i<RATIO; i=i+1) begin\n      assign s_axis_valid_int_s[i] = s_axis_valid & s_axis_ready;\n      assign s_axis_tlast_int_s[i] = s_axis_tlast;\n    end\n\n    assign s_axis_tkeep_int_s = s_axis_tkeep;\n    assign s_axis_data_int_s = s_axis_data;\n    // if every instance is ready, the interface is ready\n    assign s_axis_ready = &(s_axis_ready_int_s);\n    // if one of the atomic instance is full, s_axis_full is asserted\n    assign s_axis_full = |s_axis_full_int_s;\n    assign s_axis_almost_full = |s_axis_almost_full_int_s;\n    // the FIFO has the same room as the atomic FIFO\n    assign s_axis_room = s_axis_room_int_s[A_ADDRESS-1:0];\n\n  end else begin : small_slave\n\n    reg [RATIO-1:0] s_axis_valid_int_d = {RATIO{1'b0}};\n\n    for (i=0; i<RATIO; i=i+1) begin\n      assign s_axis_data_int_s[A_WIDTH*i+:A_WIDTH] = s_axis_data;\n      assign s_axis_tkeep_int_s[A_WIDTH/8*i+:A_WIDTH/8] = (s_axis_counter == i) ? s_axis_tkeep : {A_WIDTH/8{1'b0}};\n      assign s_axis_tlast_int_s[i] = (s_axis_counter == i) ? s_axis_tlast : 1'b0;\n    end\n\n    // insert invalid writes (TKEEP==0) in case if the TLAST arrives before the RATIO\n    // boundary\n    always @(*) begin\n      case ({s_axis_valid, s_axis_tlast})\n        2'b00 : s_axis_valid_int_d = {RATIO{1'b0}};\n        2'b01 : s_axis_valid_int_d = {RATIO{1'b0}};\n        2'b10 : s_axis_valid_int_d = {{RATIO-1{1'b0}}, 1'b1} << s_axis_counter;\n        2'b11 : s_axis_valid_int_d = {RATIO{1'b1}} << s_axis_counter;\n      endcase\n    end\n    assign s_axis_valid_int_s = s_axis_valid_int_d;\n\n    // READY/FULL/ALMOST_FULL is driven by the current atomic instance\n    assign s_axis_ready = s_axis_ready_int_s >> s_axis_counter;\n    assign s_axis_almost_full = s_axis_almost_full_int_s >> s_axis_counter;\n\n    // the FIFO has the same room as the last atomic instance\n    // (NOTE: this is not the real room value, rather the value will be updated\n    // after every RATIO number of writes)\n    assign s_axis_full = s_axis_full_int_s[RATIO-1];\n    assign s_axis_room = {s_axis_room_int_s[A_ADDRESS*(RATIO-1)+:A_ADDRESS], {$clog2(RATIO){1'b1}}};\n\n  end\n\nendgenerate\n\n// read or slave logic\ngenerate\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[146, "  if (RATIO_TYPE) begin : big_slave\n"], [150, "      assign s_axis_valid_int_s[i] = s_axis_valid & s_axis_ready;\n"], [151, "      assign s_axis_tlast_int_s[i] = s_axis_tlast;\n"], [154, "    assign s_axis_tkeep_int_s = s_axis_tkeep;\n"], [155, "    assign s_axis_data_int_s = s_axis_data;\n"], [157, "    assign s_axis_ready = &(s_axis_ready_int_s);\n"], [159, "    assign s_axis_full = |s_axis_full_int_s;\n"], [160, "    assign s_axis_almost_full = |s_axis_almost_full_int_s;\n"], [162, "    assign s_axis_room = s_axis_room_int_s[A_ADDRESS-1:0];\n"], [164, "  end else begin : small_slave\n"], [166, "    reg [RATIO-1:0] s_axis_valid_int_d = {RATIO{1'b0}};\n"], [168, "    for (i=0; i<RATIO; i=i+1) begin\n"], [169, "      assign s_axis_data_int_s[A_WIDTH*i+:A_WIDTH] = s_axis_data;\n"], [170, "      assign s_axis_tkeep_int_s[A_WIDTH/8*i+:A_WIDTH/8] = (s_axis_counter == i) ? s_axis_tkeep : {A_WIDTH/8{1'b0}};\n"], [171, "      assign s_axis_tlast_int_s[i] = (s_axis_counter == i) ? s_axis_tlast : 1'b0;\n"], [172, "    end\n"], [176, "    always @(*) begin\n"], [177, "      case ({s_axis_valid, s_axis_tlast})\n"], [178, "        2'b00 : s_axis_valid_int_d = {RATIO{1'b0}};\n"], [179, "        2'b01 : s_axis_valid_int_d = {RATIO{1'b0}};\n"], [180, "        2'b10 : s_axis_valid_int_d = {{RATIO-1{1'b0}}, 1'b1} << s_axis_counter;\n"], [181, "        2'b11 : s_axis_valid_int_d = {RATIO{1'b1}} << s_axis_counter;\n"], [182, "      endcase\n"], [183, "    end\n"], [184, "    assign s_axis_valid_int_s = s_axis_valid_int_d;\n"], [187, "    assign s_axis_ready = s_axis_ready_int_s >> s_axis_counter;\n"], [188, "    assign s_axis_almost_full = s_axis_almost_full_int_s >> s_axis_counter;\n"], [193, "    assign s_axis_full = s_axis_full_int_s[RATIO-1];\n"], [194, "    assign s_axis_room = {s_axis_room_int_s[A_ADDRESS*(RATIO-1)+:A_ADDRESS], {$clog2(RATIO){1'b1}}};\n"], [196, "  end\n"]], "Add": [[146, "  localparam RATIO_TYPE = (S_DATA_WIDTH >= M_DATA_WIDTH) ? 1 : 0;\n"], [146, "  localparam RATIO = (RATIO_TYPE) ? S_DATA_WIDTH/M_DATA_WIDTH : M_DATA_WIDTH/S_DATA_WIDTH;\n"], [146, "  localparam A_WIDTH = (RATIO_TYPE) ? M_DATA_WIDTH : S_DATA_WIDTH;\n"], [146, "  localparam A_ADDRESS = (RATIO_TYPE) ? S_ADDRESS_WIDTH : (S_ADDRESS_WIDTH-$clog2(RATIO));\n"], [146, "  localparam A_ALMOST_FULL_THRESHOLD = (RATIO_TYPE) ? ALMOST_FULL_THRESHOLD : (ALMOST_FULL_THRESHOLD/RATIO);\n"], [146, "  localparam A_ALMOST_EMPTY_THRESHOLD = (RATIO_TYPE) ? (ALMOST_EMPTY_THRESHOLD/RATIO) : ALMOST_EMPTY_THRESHOLD;\n"], [146, "  reg [$clog2(RATIO)-1:0] s_axis_counter;\n"], [146, "  reg [$clog2(RATIO)-1:0] m_axis_counter;\n"], [146, "  wire [RATIO-1:0] m_axis_ready_int_s;\n"], [146, "  wire [RATIO-1:0] m_axis_valid_int_s;\n"], [146, "  wire [RATIO*A_WIDTH-1:0] m_axis_data_int_s;\n"], [146, "  wire [RATIO*A_WIDTH/8-1:0] m_axis_tkeep_int_s;\n"], [146, "  wire [RATIO-1:0] m_axis_tlast_int_s;\n"], [146, "  wire [RATIO-1:0] m_axis_empty_int_s;\n"], [146, "  wire [RATIO-1:0] m_axis_almost_empty_int_s;\n"], [146, "  wire [RATIO*A_ADDRESS-1:0] m_axis_level_int_s;\n"], [146, "  wire [RATIO-1:0] s_axis_ready_int_s;\n"], [146, "  wire [RATIO-1:0] s_axis_valid_int_s;\n"], [146, "  wire [RATIO*A_WIDTH-1:0] s_axis_data_int_s;\n"], [146, "  wire [RATIO*A_WIDTH/8-1:0] s_axis_tkeep_int_s;\n"], [146, "  wire [RATIO-1:0] s_axis_tlast_int_s;\n"], [146, "  wire [RATIO-1:0] s_axis_full_int_s;\n"], [146, "  wire [RATIO-1:0] s_axis_almost_full_int_s;\n"], [146, "  wire [RATIO*A_ADDRESS-1:0] s_axis_room_int_s;\n"], [146, "  genvar i;\n"], [146, "  generate\n"], [151, "      util_axis_fifo #(\n"], [151, "        .DATA_WIDTH (A_WIDTH),\n"], [151, "        .ADDRESS_WIDTH (A_ADDRESS),\n"], [151, "        .ASYNC_CLK (ASYNC_CLK),\n"], [151, "        .M_AXIS_REGISTERED (M_AXIS_REGISTERED),\n"], [151, "        .ALMOST_EMPTY_THRESHOLD (A_ALMOST_EMPTY_THRESHOLD),\n"], [151, "        .ALMOST_FULL_THRESHOLD (A_ALMOST_FULL_THRESHOLD),\n"], [151, "        .TKEEP_EN (TKEEP_EN),\n"], [151, "        .TLAST_EN (TLAST_EN)\n"], [151, "      ) i_fifo (\n"], [151, "        .m_axis_aclk    (m_axis_aclk),\n"], [151, "        .m_axis_aresetn (m_axis_aresetn),\n"], [151, "        .m_axis_ready   (m_axis_ready_int_s[i]),\n"], [151, "        .m_axis_valid   (m_axis_valid_int_s[i]),\n"], [151, "        .m_axis_data    (m_axis_data_int_s[A_WIDTH*i+:A_WIDTH]),\n"], [151, "        .m_axis_tlast   (m_axis_tlast_int_s[i]),\n"], [151, "        .m_axis_tkeep   (m_axis_tkeep_int_s[A_WIDTH/8*i+:A_WIDTH/8]),\n"], [151, "        .m_axis_level   (m_axis_level_int_s[A_ADDRESS*i+:A_ADDRESS]),\n"], [151, "        .m_axis_empty   (m_axis_empty_int_s[i]),\n"], [151, "        .m_axis_almost_empty (m_axis_almost_empty_int_s[i]),\n"], [151, "        .s_axis_aclk    (s_axis_aclk),\n"], [151, "        .s_axis_aresetn (s_axis_aresetn),\n"], [151, "        .s_axis_ready   (s_axis_ready_int_s[i]),\n"], [151, "        .s_axis_valid   (s_axis_valid_int_s[i]),\n"], [151, "        .s_axis_data    (s_axis_data_int_s[A_WIDTH*i+:A_WIDTH]),\n"], [151, "        .s_axis_tkeep   (s_axis_tkeep_int_s[A_WIDTH/8*i+:A_WIDTH/8]),\n"], [151, "        .s_axis_tlast   (s_axis_tlast_int_s[i]),\n"], [151, "        .s_axis_room    (s_axis_room_int_s[A_ADDRESS*i+:A_ADDRESS]),\n"], [151, "        .s_axis_full    (s_axis_full_int_s[i]),\n"], [151, "        .s_axis_almost_full (s_axis_almost_full_int_s[i]));\n"], [152, "  endgenerate\n"], [162, "  generate\n"], [164, "    if (RATIO_TYPE) begin : big_slave\n"], [166, "      for (i=0; i<RATIO; i=i+1) begin\n"], [166, "        assign s_axis_valid_int_s[i] = s_axis_valid & s_axis_ready;\n"], [166, "        assign s_axis_tlast_int_s[i] = s_axis_tlast;\n"], [166, "      end\n"], [172, "      assign s_axis_tkeep_int_s = s_axis_tkeep;\n"], [172, "      assign s_axis_data_int_s = s_axis_data;\n"], [172, "      assign s_axis_ready = &(s_axis_ready_int_s);\n"], [172, "      assign s_axis_full = |s_axis_full_int_s;\n"], [172, "      assign s_axis_almost_full = |s_axis_almost_full_int_s;\n"], [172, "      assign s_axis_room = s_axis_room_int_s[A_ADDRESS-1:0];\n"], [184, "    end else begin : small_slave\n"], [188, "      reg [RATIO-1:0] s_axis_valid_int_d = {RATIO{1'b0}};\n"], [194, "      for (i=0; i<RATIO; i=i+1) begin\n"], [194, "        assign s_axis_data_int_s[A_WIDTH*i+:A_WIDTH] = s_axis_data;\n"], [194, "        assign s_axis_tkeep_int_s[A_WIDTH/8*i+:A_WIDTH/8] = (s_axis_counter == i) ? s_axis_tkeep : {A_WIDTH/8{1'b0}};\n"], [194, "        assign s_axis_tlast_int_s[i] = (s_axis_counter == i) ? s_axis_tlast : 1'b0;\n"], [194, "      end\n"], [196, "      always @(*) begin\n"], [196, "        case ({s_axis_valid, s_axis_tlast})\n"], [196, "          2'b00 : s_axis_valid_int_d = {RATIO{1'b0}};\n"], [196, "          2'b01 : s_axis_valid_int_d = {RATIO{1'b0}};\n"], [196, "          2'b10 : s_axis_valid_int_d = {{RATIO-1{1'b0}}, 1'b1} << s_axis_counter;\n"], [196, "          2'b11 : s_axis_valid_int_d = {RATIO{1'b1}} << s_axis_counter;\n"], [196, "        endcase\n"], [196, "      end\n"], [196, "      assign s_axis_valid_int_s = s_axis_valid_int_d;\n"]]}}