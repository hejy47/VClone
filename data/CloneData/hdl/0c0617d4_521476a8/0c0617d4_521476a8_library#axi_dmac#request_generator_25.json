{"Source Block": ["hdl/library/axi_dmac/request_generator.v@107:125@HdlStmProcess", "assign request_id = id;\n\nassign incr_en = (response_id != id_next) && (enable == 1'b1);\nassign incr_id = (state == STATE_GEN_ID) && (incr_en == 1'b1);\n\nalways @(posedge clk) begin\n  if (state == STATE_IDLE) begin\n    burst_count <= req_burst_count;\n  end else if (state == STATE_REWIND_ID) begin\n    burst_count <= cur_burst_length;\n  end else if (incr_id == 1'b1) begin\n    burst_count <= burst_count - 1'b1;\n  end\nend\nalways @(posedge clk) begin\n  if (req_ready == 1'b1 & req_valid == 1'b1) begin\n    cur_req_xlast <= req_xlast;\n    cur_burst_length <= req_burst_count;\n  end\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[112, "always @(posedge clk) begin\n"], [113, "  if (state == STATE_IDLE) begin\n"], [114, "    burst_count <= req_burst_count;\n"], [115, "  end else if (state == STATE_REWIND_ID) begin\n"], [116, "    burst_count <= cur_burst_length;\n"], [117, "  end else if (incr_id == 1'b1) begin\n"], [118, "    burst_count <= burst_count - 1'b1;\n"], [120, "end\n"]], "Add": [[118, "  `include \"inc_id.vh\"\n"], [118, "  localparam STATE_IDLE      = 3'h0;\n"], [118, "  localparam STATE_GEN_ID    = 3'h1;\n"], [118, "  localparam STATE_REWIND_ID = 3'h2;\n"], [118, "  localparam STATE_CONSUME   = 3'h3;\n"], [118, "  localparam STATE_WAIT_LAST = 3'h4;\n"], [118, "  reg [2:0] state = STATE_IDLE;\n"], [118, "  reg [2:0] nx_state;\n"], [118, "  reg [1:0] rew_transfer_id = 1'b0;\n"], [118, "  reg rew_req_xlast;\n"], [118, "  reg [ID_WIDTH-1:0] rew_id = 'h0;\n"], [118, "  reg cur_transfer_id = 1'b0;\n"], [118, "  reg cur_req_xlast;\n"], [118, "  wire transfer_id_match;\n"], [118, "  reg nx_completion_req_valid;\n"], [118, "  /*\n"], [118, "   * Here we only need to count the number of bursts, which means we can ignore\n"], [118, "   * the lower bits of the byte count. The last last burst may not contain the\n"], [118, "   * maximum number of bytes, but the address_generator and data_mover will take\n"], [118, "   * care that only the requested ammount of bytes is transfered.\n"], [118, "   */\n"], [118, "  reg [BURSTS_PER_TRANSFER_WIDTH-1:0] burst_count = 'h00;\n"], [118, "  reg [BURSTS_PER_TRANSFER_WIDTH-1:0] cur_burst_length = 'h00;\n"], [118, "  reg [ID_WIDTH-1:0] id;\n"], [118, "  wire [ID_WIDTH-1:0] id_next = inc_id(id);\n"], [118, "  wire incr_en;\n"], [118, "  wire incr_id;\n"], [118, "  assign eot = burst_count == 'h00;\n"], [118, "  assign request_id = id;\n"], [118, "  assign incr_en = (response_id != id_next) && (enable == 1'b1);\n"], [118, "  assign incr_id = (state == STATE_GEN_ID) && (incr_en == 1'b1);\n"], [118, "  always @(posedge clk) begin\n"], [118, "    if (state == STATE_IDLE) begin\n"], [118, "      burst_count <= req_burst_count;\n"], [118, "    end else if (state == STATE_REWIND_ID) begin\n"], [118, "      burst_count <= cur_burst_length;\n"], [118, "    end else if (incr_id == 1'b1) begin\n"], [118, "      burst_count <= burst_count - 1'b1;\n"], [118, "    end\n"]]}}