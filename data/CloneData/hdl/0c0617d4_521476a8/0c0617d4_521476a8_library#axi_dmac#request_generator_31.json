{"Source Block": ["hdl/library/axi_dmac/request_generator.v@167:232@HdlStmProcess", " *\n * Completion requests are generated for every segment that is\n * consumed/ignored. These are handled by the response_manager once the\n * interrupted segment got transferred to the destination.\n */\nalways @(*) begin\n  nx_state = state;\n  nx_completion_req_valid = 0;\n  case (state)\n    STATE_IDLE: begin\n      if (rewind_req_valid == 1'b1 && rewind_req_ready == 1'b1) begin\n        nx_state = STATE_REWIND_ID;\n      end else if (req_valid == 1'b1) begin\n        nx_state = STATE_GEN_ID;\n      end\n    end\n    STATE_GEN_ID: begin\n      if (rewind_req_valid == 1'b1 && rewind_req_ready == 1'b1) begin\n        nx_state = STATE_REWIND_ID;\n      end else if (eot == 1'b1 && incr_en == 1'b1) begin\n        nx_state = STATE_IDLE;\n      end\n    end\n    STATE_REWIND_ID: begin\n      if (transfer_id_match) begin\n        if (rew_req_xlast) begin\n          nx_state = STATE_IDLE;\n        end else begin\n          nx_state = STATE_CONSUME;\n        end\n      end else begin\n        if (rew_req_xlast) begin\n          nx_state = STATE_GEN_ID;\n        end else if (cur_req_xlast) begin\n          nx_state = STATE_IDLE;\n          nx_completion_req_valid = 1;\n        end else begin\n          nx_state = STATE_CONSUME;\n          nx_completion_req_valid = 1;\n        end\n      end\n    end\n    STATE_CONSUME: begin\n      if (req_valid) begin\n        nx_completion_req_valid = 1;\n        nx_state = STATE_WAIT_LAST;\n      end\n    end\n    STATE_WAIT_LAST:begin\n      if (cur_req_xlast) begin\n        nx_state = STATE_IDLE;\n      end else begin\n        nx_state = STATE_CONSUME;\n      end\n    end\n\n    default: begin\n      nx_state = STATE_IDLE;\n    end\n  endcase\nend\n\nalways @(posedge clk) begin\n  if (resetn == 1'b0) begin\n    state <= STATE_IDLE;\n  end else begin\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[172, "always @(*) begin\n"], [173, "  nx_state = state;\n"], [174, "  nx_completion_req_valid = 0;\n"], [175, "  case (state)\n"], [176, "    STATE_IDLE: begin\n"], [177, "      if (rewind_req_valid == 1'b1 && rewind_req_ready == 1'b1) begin\n"], [178, "        nx_state = STATE_REWIND_ID;\n"], [179, "      end else if (req_valid == 1'b1) begin\n"], [180, "        nx_state = STATE_GEN_ID;\n"], [181, "      end\n"], [183, "    STATE_GEN_ID: begin\n"], [184, "      if (rewind_req_valid == 1'b1 && rewind_req_ready == 1'b1) begin\n"], [185, "        nx_state = STATE_REWIND_ID;\n"], [186, "      end else if (eot == 1'b1 && incr_en == 1'b1) begin\n"], [187, "        nx_state = STATE_IDLE;\n"], [189, "    end\n"], [190, "    STATE_REWIND_ID: begin\n"], [191, "      if (transfer_id_match) begin\n"], [192, "        if (rew_req_xlast) begin\n"], [195, "          nx_state = STATE_CONSUME;\n"], [197, "      end else begin\n"], [198, "        if (rew_req_xlast) begin\n"], [199, "          nx_state = STATE_GEN_ID;\n"], [200, "        end else if (cur_req_xlast) begin\n"], [201, "          nx_state = STATE_IDLE;\n"], [205, "          nx_completion_req_valid = 1;\n"], [208, "    end\n"], [209, "    STATE_CONSUME: begin\n"], [210, "      if (req_valid) begin\n"], [211, "        nx_completion_req_valid = 1;\n"], [212, "        nx_state = STATE_WAIT_LAST;\n"], [213, "      end\n"], [214, "    end\n"], [215, "    STATE_WAIT_LAST:begin\n"], [216, "      if (cur_req_xlast) begin\n"], [218, "      end else begin\n"], [219, "        nx_state = STATE_CONSUME;\n"], [221, "    end\n"], [223, "    default: begin\n"], [224, "      nx_state = STATE_IDLE;\n"], [226, "  endcase\n"], [227, "end\n"]], "Add": [[181, "  always @(posedge clk) begin\n"], [181, "    if (resetn == 1'b0) begin\n"], [181, "      cur_transfer_id <= 1'b0;\n"], [181, "    end else if (req_valid == 1'b1 && req_ready == 1'b1) begin\n"], [181, "      cur_transfer_id <= ~cur_transfer_id;\n"], [187, "  end\n"], [187, "  /*\n"], [187, "   * Once rewind request is received we need to stop incrementing the burst ID.\n"], [187, "   *\n"], [187, "   * If the current segment matches the segment that was interrupted and\n"], [187, "   * if it was a last segment we ignore consecutive segments until the last\n"], [187, "   * segment is received, in other case we can jump to the next segment.\n"], [187, "   *\n"], [187, "   * If the current segment is newer than the one got interrupted and the\n"], [187, "   * interrupted one was a last segment we need to replay the current\n"], [187, "   * segment with the adjusted burst ID. If the interrupted segment was not last\n"], [187, "   * we need to consume/ignore all segments until a last segment is received.\n"], [187, "   *\n"], [187, "   * Completion requests are generated for every segment that is\n"], [187, "   * consumed/ignored. These are handled by the response_manager once the\n"], [187, "   * interrupted segment got transferred to the destination.\n"], [187, "   */\n"], [187, "  always @(*) begin\n"], [187, "    nx_state = state;\n"], [187, "    nx_completion_req_valid = 0;\n"], [187, "    case (state)\n"], [187, "      STATE_IDLE: begin\n"], [187, "        if (rewind_req_valid == 1'b1 && rewind_req_ready == 1'b1) begin\n"], [187, "          nx_state = STATE_REWIND_ID;\n"], [187, "        end else if (req_valid == 1'b1) begin\n"], [187, "          nx_state = STATE_GEN_ID;\n"], [187, "        end\n"], [192, "      STATE_GEN_ID: begin\n"], [192, "        if (rewind_req_valid == 1'b1 && rewind_req_ready == 1'b1) begin\n"], [192, "          nx_state = STATE_REWIND_ID;\n"], [192, "        end else if (eot == 1'b1 && incr_en == 1'b1) begin\n"], [193, "        end\n"], [193, "      end\n"], [193, "      STATE_REWIND_ID: begin\n"], [193, "        if (transfer_id_match) begin\n"], [193, "          if (rew_req_xlast) begin\n"], [193, "            nx_state = STATE_IDLE;\n"], [193, "          end else begin\n"], [193, "            nx_state = STATE_CONSUME;\n"], [193, "          end\n"], [195, "          if (rew_req_xlast) begin\n"], [195, "            nx_state = STATE_GEN_ID;\n"], [195, "          end else if (cur_req_xlast) begin\n"], [195, "            nx_state = STATE_IDLE;\n"], [195, "            nx_completion_req_valid = 1;\n"], [195, "          end else begin\n"], [195, "            nx_state = STATE_CONSUME;\n"], [195, "            nx_completion_req_valid = 1;\n"], [195, "          end\n"], [201, "      end\n"], [201, "      STATE_CONSUME: begin\n"], [201, "        if (req_valid) begin\n"], [202, "          nx_state = STATE_WAIT_LAST;\n"], [202, "        end\n"], [202, "      end\n"], [202, "      STATE_WAIT_LAST:begin\n"], [202, "        if (cur_req_xlast) begin\n"], [202, "          nx_state = STATE_IDLE;\n"], [216, "      default: begin\n"], [221, "    endcase\n"], [221, "  end\n"], [224, "  always @(posedge clk) begin\n"], [224, "    if (resetn == 1'b0) begin\n"], [224, "      state <= STATE_IDLE;\n"], [224, "    end else begin\n"], [224, "      state <= nx_state;\n"]]}}