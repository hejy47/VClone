{"Source Block": ["hdl/library/axi_dmac/axi_dmac_resize_dest.v@58:138@HdlStmIf", "/*\n * Resize the data width between the burst memory and the destination interface\n * if necessary.\n */\n\ngenerate if (DATA_WIDTH_DEST == DATA_WIDTH_MEM)  begin\n  assign dest_data_valid = mem_data_valid;\n  assign dest_data = mem_data;\n  assign dest_data_last = mem_data_last;\n  assign dest_data_strb = mem_data_strb;\n  assign mem_data_ready = dest_data_ready;\nend else begin\n\n  localparam RATIO = DATA_WIDTH_MEM / DATA_WIDTH_DEST;\n\n  reg [$clog2(RATIO)-1:0] count = 'h0;\n  reg valid = 1'b0;\n  reg [RATIO-1:0] last = 'h0;\n  reg [DATA_WIDTH_MEM-1:0] data = 'h0;\n  reg [DATA_WIDTH_MEM/8-1:0] strb = {DATA_WIDTH_MEM/8{1'b1}};\n\n  wire last_beat;\n\n  assign last_beat = (count == RATIO - 1) | last[0];\n\n  always @(posedge clk) begin\n    if (reset == 1'b1) begin\n      valid <= 1'b0;\n    end else if (mem_data_valid == 1'b1) begin\n      valid <= 1'b1;\n    end else if (last_beat == 1'b1 && dest_data_ready == 1'b1) begin\n      valid <= 1'b0;\n    end\n  end\n\n  always @(posedge clk) begin\n    if (reset == 1'b1) begin\n      count <= 'h0;\n    end else if (dest_data_ready == 1'b1 && dest_data_valid == 1'b1) begin\n      if (last_beat == 1'b1) begin\n        count <= 'h0;\n      end else begin\n        count <= count + 1;\n      end\n    end\n  end\n\n  assign mem_data_ready = ~valid | (dest_data_ready & last_beat);\n\n  integer i;\n  always @(posedge clk) begin\n    if (mem_data_ready == 1'b1) begin\n      data <= mem_data;\n\n      /*\n       * Skip those words where strb would be completely zero for the output\n       * word. We assume that strb is thermometer encoded (i.e. a certain number\n       * of LSBs are 1'b1 followed by all 1'b0 in the MSBs) and by extension\n       * that if the first strb bit for a word is zero that means that all strb\n       * bits for a word will be zero.\n       */\n      for (i = 0; i < RATIO-1; i = i + 1) begin\n        last[i] <= mem_data_last & ~mem_data_strb[(i+1)*(DATA_WIDTH_MEM/8/RATIO)];\n      end\n      last[RATIO-1] <= mem_data_last;\n      strb <= mem_data_strb;\n    end else if (dest_data_ready == 1'b1) begin\n      data[DATA_WIDTH_MEM-DATA_WIDTH_DEST-1:0] <= data[DATA_WIDTH_MEM-1:DATA_WIDTH_DEST];\n      strb[(DATA_WIDTH_MEM-DATA_WIDTH_DEST)/8-1:0] <= strb[DATA_WIDTH_MEM/8-1:DATA_WIDTH_DEST/8];\n      last[RATIO-2:0] <= last[RATIO-1:1];\n    end\n  end\n\n  assign dest_data_valid = valid;\n  assign dest_data = data[DATA_WIDTH_DEST-1:0];\n  assign dest_data_strb = strb[DATA_WIDTH_DEST/8-1:0];\n  assign dest_data_last = last[0];\n\nend endgenerate\n\nendmodule\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[63, "generate if (DATA_WIDTH_DEST == DATA_WIDTH_MEM)  begin\n"], [64, "  assign dest_data_valid = mem_data_valid;\n"], [65, "  assign dest_data = mem_data;\n"], [66, "  assign dest_data_last = mem_data_last;\n"], [67, "  assign dest_data_strb = mem_data_strb;\n"], [68, "  assign mem_data_ready = dest_data_ready;\n"], [69, "end else begin\n"], [71, "  localparam RATIO = DATA_WIDTH_MEM / DATA_WIDTH_DEST;\n"], [73, "  reg [$clog2(RATIO)-1:0] count = 'h0;\n"], [74, "  reg valid = 1'b0;\n"], [75, "  reg [RATIO-1:0] last = 'h0;\n"], [76, "  reg [DATA_WIDTH_MEM-1:0] data = 'h0;\n"], [77, "  reg [DATA_WIDTH_MEM/8-1:0] strb = {DATA_WIDTH_MEM/8{1'b1}};\n"], [79, "  wire last_beat;\n"], [81, "  assign last_beat = (count == RATIO - 1) | last[0];\n"], [83, "  always @(posedge clk) begin\n"], [84, "    if (reset == 1'b1) begin\n"], [85, "      valid <= 1'b0;\n"], [86, "    end else if (mem_data_valid == 1'b1) begin\n"], [87, "      valid <= 1'b1;\n"], [88, "    end else if (last_beat == 1'b1 && dest_data_ready == 1'b1) begin\n"], [89, "      valid <= 1'b0;\n"], [91, "  end\n"], [93, "  always @(posedge clk) begin\n"], [94, "    if (reset == 1'b1) begin\n"], [95, "      count <= 'h0;\n"], [96, "    end else if (dest_data_ready == 1'b1 && dest_data_valid == 1'b1) begin\n"], [97, "      if (last_beat == 1'b1) begin\n"], [99, "      end else begin\n"], [100, "        count <= count + 1;\n"], [103, "  end\n"], [105, "  assign mem_data_ready = ~valid | (dest_data_ready & last_beat);\n"], [107, "  integer i;\n"], [108, "  always @(posedge clk) begin\n"], [109, "    if (mem_data_ready == 1'b1) begin\n"], [110, "      data <= mem_data;\n"], [112, "      /*\n"], [113, "       * Skip those words where strb would be completely zero for the output\n"], [114, "       * word. We assume that strb is thermometer encoded (i.e. a certain number\n"], [115, "       * of LSBs are 1'b1 followed by all 1'b0 in the MSBs) and by extension\n"], [116, "       * that if the first strb bit for a word is zero that means that all strb\n"], [117, "       * bits for a word will be zero.\n"], [118, "       */\n"], [119, "      for (i = 0; i < RATIO-1; i = i + 1) begin\n"], [120, "        last[i] <= mem_data_last & ~mem_data_strb[(i+1)*(DATA_WIDTH_MEM/8/RATIO)];\n"], [122, "      last[RATIO-1] <= mem_data_last;\n"], [123, "      strb <= mem_data_strb;\n"], [124, "    end else if (dest_data_ready == 1'b1) begin\n"], [125, "      data[DATA_WIDTH_MEM-DATA_WIDTH_DEST-1:0] <= data[DATA_WIDTH_MEM-1:DATA_WIDTH_DEST];\n"], [126, "      strb[(DATA_WIDTH_MEM-DATA_WIDTH_DEST)/8-1:0] <= strb[DATA_WIDTH_MEM/8-1:DATA_WIDTH_DEST/8];\n"], [127, "      last[RATIO-2:0] <= last[RATIO-1:1];\n"], [129, "  end\n"], [131, "  assign dest_data_valid = valid;\n"], [132, "  assign dest_data = data[DATA_WIDTH_DEST-1:0];\n"], [133, "  assign dest_data_strb = strb[DATA_WIDTH_DEST/8-1:0];\n"], [134, "  assign dest_data_last = last[0];\n"], [136, "end endgenerate\n"]], "Add": [[89, "  /*\n"], [89, "   * Resize the data width between the burst memory and the destination interface\n"], [89, "   * if necessary.\n"], [89, "   */\n"], [89, "  generate if (DATA_WIDTH_DEST == DATA_WIDTH_MEM)  begin\n"], [89, "    assign dest_data_valid = mem_data_valid;\n"], [89, "    assign dest_data = mem_data;\n"], [89, "    assign dest_data_last = mem_data_last;\n"], [89, "    assign dest_data_strb = mem_data_strb;\n"], [89, "    assign mem_data_ready = dest_data_ready;\n"], [89, "  end else begin\n"], [89, "    localparam RATIO = DATA_WIDTH_MEM / DATA_WIDTH_DEST;\n"], [89, "    reg [$clog2(RATIO)-1:0] count = 'h0;\n"], [89, "    reg valid = 1'b0;\n"], [89, "    reg [RATIO-1:0] last = 'h0;\n"], [89, "    reg [DATA_WIDTH_MEM-1:0] data = 'h0;\n"], [89, "    reg [DATA_WIDTH_MEM/8-1:0] strb = {DATA_WIDTH_MEM/8{1'b1}};\n"], [89, "    wire last_beat;\n"], [89, "    assign last_beat = (count == RATIO - 1) | last[0];\n"], [89, "    always @(posedge clk) begin\n"], [89, "      if (reset == 1'b1) begin\n"], [89, "        valid <= 1'b0;\n"], [89, "      end else if (mem_data_valid == 1'b1) begin\n"], [89, "        valid <= 1'b1;\n"], [89, "      end else if (last_beat == 1'b1 && dest_data_ready == 1'b1) begin\n"], [89, "        valid <= 1'b0;\n"], [89, "      end\n"], [97, "    always @(posedge clk) begin\n"], [97, "      if (reset == 1'b1) begin\n"], [100, "      end else if (dest_data_ready == 1'b1 && dest_data_valid == 1'b1) begin\n"], [100, "        if (last_beat == 1'b1) begin\n"], [100, "          count <= 'h0;\n"], [100, "        end else begin\n"], [100, "          count <= count + 1;\n"], [100, "        end\n"], [120, "    assign mem_data_ready = ~valid | (dest_data_ready & last_beat);\n"], [120, "    integer i;\n"], [120, "    always @(posedge clk) begin\n"], [120, "      if (mem_data_ready == 1'b1) begin\n"], [120, "        data <= mem_data;\n"], [120, "        /*\n"], [120, "         * Skip those words where strb would be completely zero for the output\n"], [120, "         * word. We assume that strb is thermometer encoded (i.e. a certain number\n"], [120, "         * of LSBs are 1'b1 followed by all 1'b0 in the MSBs) and by extension\n"], [120, "         * that if the first strb bit for a word is zero that means that all strb\n"], [120, "         * bits for a word will be zero.\n"], [120, "         */\n"], [120, "        for (i = 0; i < RATIO-1; i = i + 1) begin\n"], [120, "          last[i] <= mem_data_last & ~mem_data_strb[(i+1)*(DATA_WIDTH_MEM/8/RATIO)];\n"], [120, "        end\n"], [120, "        last[RATIO-1] <= mem_data_last;\n"], [120, "        strb <= mem_data_strb;\n"], [120, "      end else if (dest_data_ready == 1'b1) begin\n"], [120, "        data[DATA_WIDTH_MEM-DATA_WIDTH_DEST-1:0] <= data[DATA_WIDTH_MEM-1:DATA_WIDTH_DEST];\n"], [120, "        strb[(DATA_WIDTH_MEM-DATA_WIDTH_DEST)/8-1:0] <= strb[DATA_WIDTH_MEM/8-1:DATA_WIDTH_DEST/8];\n"], [120, "        last[RATIO-2:0] <= last[RATIO-1:1];\n"], [134, "    assign dest_data_valid = valid;\n"], [134, "    assign dest_data = data[DATA_WIDTH_DEST-1:0];\n"], [134, "    assign dest_data_strb = strb[DATA_WIDTH_DEST/8-1:0];\n"], [134, "    assign dest_data_last = last[0];\n"], [136, "  end endgenerate\n"]]}}