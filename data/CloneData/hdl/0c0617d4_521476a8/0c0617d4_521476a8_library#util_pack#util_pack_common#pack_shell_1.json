{"Source Block": ["hdl/library/util_pack/util_pack_common/pack_shell.v@119:531@HdlStmIf", "      startup_ctrl <= reset_ctrl | startup_ctrl2;\n    end\n  end\n\n  generate\n    if (NUM_OF_CHANNELS == 1) begin\n      /*\n       * In the one channel case there is not much to do. Nevertheless we should\n       * support it to allow generic designs where the number of channels is\n       * selected programmatically.\n       */\n      assign out_data = in_data;\n      assign out_sync = 1'b1;\n      assign out_valid = {NUM_OF_SAMPLES{1'b1}};\n\n      always @(*) begin\n        ready <= ce & ~reset_data;\n      end\n    end else begin\n      localparam SAMPLE_ADDRESS_WIDTH =\n        NUM_OF_SAMPLES > 512 ? 10 :\n        NUM_OF_SAMPLES > 256 ? 9 :\n        NUM_OF_SAMPLES > 128 ? 8 :\n        NUM_OF_SAMPLES > 64 ? 7 :\n        NUM_OF_SAMPLES > 32 ? 6 :\n        NUM_OF_SAMPLES > 16 ? 5 :\n        NUM_OF_SAMPLES > 8 ? 4 :\n        NUM_OF_SAMPLES > 4 ? 3 :\n        NUM_OF_SAMPLES > 2 ? 2 : 1;\n\n      /*\n       * `rotate` is used as an offset into the input data vector. When not all\n       * samples are enabled it can take multiple cycles for the input vector to\n       * be consumed. `rotate` points to the first sample in the input vector\n       * that should consumed next. E.g. when there are 4 channels, but only 2\n       * are enabled `rotate` will oscillate between 0 and 2. If there are 4\n       * channels and 3 are enabled it will cycle through the sequence 0, 3, 2,\n       * 1.\n       */\n      reg [SAMPLE_ADDRESS_WIDTH-1:0] rotate = 'h00;\n\n      /*\n      * `prefix_count` counts the number of disabled channels that precede a\n      * channel. E.g. if channel 0 is enabled and channel 1 and 2 are disabled\n      * the prefix count for channel 3 is 2.\n      */\n      reg [SAMPLE_ADDRESS_WIDTH*NUM_OF_SAMPLES-1:0] prefix_count;\n\n      /*\n       * Clock enable for all the control signals. When asserted the next cycle\n       * for the control signals should computed\n       */\n      wire ce_ctrl;\n\n      /*\n       * Extended version of the `enable` signal that takes SAMPLES_PER_CHANNEL\n       * into account.\n       */\n      wire [NUM_OF_SAMPLES-1:0] samples_enable;\n\n      /*\n       * Used to connect the different intermediary stages of the routing\n       * network. There can be up to three sub-networks.\n       */\n      wire [TOTAL_DATA_WIDTH-1:0] data[0:2];\n\n      /*\n       * Unregistered version of `prefix_count`. This is used to add up the\n       * enable ports.\n       */\n      wire [SAMPLE_ADDRESS_WIDTH-1:0] prefix_count_s[0:NUM_OF_SAMPLES];\n\n      /*\n       * Samples are interleaved, so the sample mask is just the channel mask\n       * concatenated with itself SAMPLES_PER_CHANNEL times.\n       */\n      assign samples_enable = {SAMPLES_PER_CHANNEL{enable_int}};\n\n      /*\n       * Control pipeline is active and should compute the next state either\n       * during the startup phase or when a output data set is consumed.\n       */\n      assign ce_ctrl = startup_ctrl | ce;\n\n      /* First channel has no other channels before it */\n      assign prefix_count_s[0] = 'h0;\n\n      genvar i;\n      for (i = 0; i < NUM_OF_SAMPLES; i = i + 1) begin: gen_prefix_count\n        assign prefix_count_s[i+1] = prefix_count_s[i] + (samples_enable[i] ? 1'b0 : 1'b1);\n\n        if (i < 2 || NUM_OF_CHANNELS <= 2) begin\n          /* This will only be one bit, no need to register it */\n          always @(prefix_count_s[i]) begin\n            prefix_count[i*SAMPLE_ADDRESS_WIDTH+:SAMPLE_ADDRESS_WIDTH] <= prefix_count_s[i];\n          end\n        end else begin\n          always @(posedge clk) begin\n            prefix_count[i*SAMPLE_ADDRESS_WIDTH+:SAMPLE_ADDRESS_WIDTH] <= prefix_count_s[i];\n          end\n        end\n      end\n\n      /*\n       * Number of enabled channels - 1. Zero enabled channels is not a valid\n       * configuration and storing it this way allows for better utilization.\n       */\n      reg [SAMPLE_ADDRESS_WIDTH-1:0] enable_count = 'h0;\n\n      always @(posedge clk) begin\n        /*\n         * `prefix_count` tracks the number of disabled channels. Invert it to\n         * get the number of enabled channels - 1\n         */\n        enable_count <= ~prefix_count_s[NUM_OF_SAMPLES];\n      end\n\n      if (NON_POWER_OF_TWO == 1 && PACK == 0) begin: gen_input_buffer\n        /* Delayed data vector. Data from the previous cycle. */\n        reg [TOTAL_DATA_WIDTH-2*CHANNEL_DATA_WIDTH-1:0] data_d1 = 'h00;\n\n        /*\n         * Same as `rotate`, but two pipeline stages ahead of the data path.\n         * This is needed to compute some of the other control signals ahead of\n         * time.\n         */\n        reg [SAMPLE_ADDRESS_WIDTH:0] rotate_next;\n\n        /*\n         * MSB of the rotate control signal. This is used to move the source\n         * data index to the delayed data vector. This will only ever be\n         * asserted for one clock cycle at a time.\n         */\n        reg rotate_msb = 1'b0;\n\n\n        /*\n         * Extended version of the normal control and data signals that can\n         * handle 2*NUM_OF_CHANNELS channels.\n         */\n        wire [(SAMPLE_ADDRESS_WIDTH+1)*(2*NUM_OF_SAMPLES)-1:0] ext_prefix_count;\n        wire [TOTAL_DATA_WIDTH*2-1:0] ext_data_in;\n        wire [TOTAL_DATA_WIDTH*2-1:0] ext_data_out;\n        wire [TOTAL_DATA_WIDTH*2-1:0] ext_data_shuffled;\n        wire [SAMPLE_ADDRESS_WIDTH:0] rotate_next_next;\n\n        /*\n         * This stage needs to handle 2*NUM_OF_CHANNELS channels so the prefix\n         * count needs to padded with an extra bit.\n         */\n        for (i = 0; i < NUM_OF_SAMPLES; i = i + 1) begin: gen_ext_prefix_count1\n          assign ext_prefix_count[i*(SAMPLE_ADDRESS_WIDTH+1)+:SAMPLE_ADDRESS_WIDTH+1] = {1'b0,prefix_count[i*SAMPLE_ADDRESS_WIDTH+:SAMPLE_ADDRESS_WIDTH]};\n        end\n\n        /*\n         * The inversion and the addition of the constant will be folded into\n         * the LUT that generates the control signals. This does not use up any\n         * extra resources.\n         */\n        for (i = NUM_OF_SAMPLES; i < NUM_OF_SAMPLES * 2; i = i + 1) begin: gen_ext_prefix_count2\n          assign ext_prefix_count[i*(SAMPLE_ADDRESS_WIDTH+1)+:SAMPLE_ADDRESS_WIDTH+1] = ~enable_count + i;\n        end\n\n        /*\n         * For non power of two channel masks the previous data needs to be\n         * saved since a single read can span over two consecutive input data\n         * words. The lower two channels don't need to be saved since there are\n         * no configurations in which they'd be required.\n         */\n        always @(posedge clk) begin\n          if (ce == 1'b1 && ready == 1'b1) begin /* Just ready ??? */\n            data_d1 <= in_data[TOTAL_DATA_WIDTH-1:2*CHANNEL_DATA_WIDTH];\n          end\n        end\n\n        /* Three pipeline steps ahead of data */\n        assign rotate_next_next = rotate_next[SAMPLE_ADDRESS_WIDTH-1:0] + enable_count + 1'b1;\n\n        always @(posedge clk) begin\n          if (reset_ctrl == 1'b1) begin\n            ready <= 1'b0;\n            rotate_msb <= 1'b0;\n\n            rotate <= 'h0;\n            rotate_next <= 'h0;\n          end else if (ce_ctrl == 1'b1) begin\n            ready <= 1'b0;\n            rotate_msb <= 1'b0;\n\n            /*\n             * If the next cycle will consume more data than what is still\n             * available ready needs to be asserted and the network needs to be\n             * updated to source data from the delayed data register.\n             */\n            if (rotate_next_next[SAMPLE_ADDRESS_WIDTH] &\n                |rotate_next_next[SAMPLE_ADDRESS_WIDTH-1:0]) begin\n              ready <= 1'b1;\n              rotate_msb <= 1'b1;\n            end\n            /*\n             * If the current cycle consumes all available data ready needs to\n             * be asserted, but only if it wasn't already asserted on the\n             * previous cycle due to overconsumption.\n             */\n            if (rotate_next[SAMPLE_ADDRESS_WIDTH] == 1'b1 && rotate_msb == 1'b0) begin\n              ready <= 1'b1;\n            end\n\n            rotate <= rotate_next;\n            rotate_next <= rotate_next_next;\n          end\n        end\n\n        /*\n         * First stage of the routing network. We know that we have at least 4\n         * channels and hence 8 input to the network, so we'll always use a\n         * 4-MUX based stage here.\n         */\n        pack_network #(\n          .PORT_ADDRESS_WIDTH (SAMPLE_ADDRESS_WIDTH + 1),\n          .MUX_ORDER (2),\n          .MIN_STAGE (0),\n          .NUM_STAGES (1),\n          .PORT_DATA_WIDTH (SAMPLE_DATA_WIDTH)\n        ) i_ext_ctrl_interconnect (\n          .clk (clk),\n          .ce_ctrl (ce_ctrl),\n\n          .rotate ({rotate_msb,rotate}),\n          .prefix_count (ext_prefix_count),\n\n          .data_in (ext_data_in),\n          .data_out (ext_data_out)\n        );\n\n        /*\n         * In order to go from this stage that has 2 * NUM_OF_SAMPLES inputs\n         * and output to the remainder of the network that has only NUM_OF_SAMPLES\n         * inputs and outputs every second two ports need to be skipped. I.e.\n         * port 2, 3, 6, 7...\n         * The shuffle groups all ports that are wanted into the first half of\n         * `ext_data_shuffled` and the unwanted ports into the second half which\n         * will be discarded.\n         */\n        ad_perfect_shuffle #(\n          .NUM_GROUPS (NUM_OF_SAMPLES / 2),\n          .WORDS_PER_GROUP (2),\n          .WORD_WIDTH (2 * SAMPLE_DATA_WIDTH)\n        ) i_ext_shuffle (\n           .data_in (ext_data_out),\n           .data_out (ext_data_shuffled)\n        );\n\n        assign ext_data_in = {data_d1,{2*CHANNEL_DATA_WIDTH{1'b0}},in_data};\n        assign data[0] = ext_data_shuffled[0+:TOTAL_DATA_WIDTH];\n      end else begin\n        always @(posedge clk) begin\n          if (reset_ctrl == 1'b1) begin\n            ready <= 1'b0;\n            rotate <= 'h0;\n          end else if (ce_ctrl == 1'b1) begin\n            /*\n             * When all samples in the input vector has been consumed ready is\n             * asserted for a single clock cycle. Here the number of enabled\n             * channels is always a power of two. That means the input vector is\n             * evenly divisible into the output data and there is no fractional\n             * residual data. I.e. when ready is asserted rotate is 0.\n             */\n            {ready,rotate} <= rotate + enable_count + 1'b1;\n          end\n        end\n\n        assign data[0] = in_data;\n      end\n\n      /*\n       * The routing network can be built from any type of MUX. When it comes to\n       * resource usage 2:1 MUXes and 4:1 MUXes are the most efficient, both will\n       * require the same amount of LUTs. But a network built from 4:1 MUXes only uses\n       * half the number of stages of a network built from 2:1 MUXes, so it has a\n       * shorter routing delay and is the preferred architecture.\n       *\n       * For a pure 4:1 MUX network the number of ports is a power of 4. For a 2:1 MUX\n       * network the number of ports is a power of 2. To get the best from both worlds\n       * build the last stage from 2:1 MUXes when the number of ports is a power of\n       * 2 and use 4:1 MUXes for the other stages.\n       */\n      for (i = 0; i < 2; i = i + 1) begin: gen_network\n        localparam MUX_ORDER = i == 0 ? 2 : 1;\n        localparam MIN_STAGE = PACK ? (i == 0 ? SAMPLE_ADDRESS_WIDTH % 2 : 0) :\n                                      (i == 0 ? NON_POWER_OF_TWO : SAMPLE_ADDRESS_WIDTH - 1);\n        localparam NUM_STAGES = PACK ? (i == 0 ? SAMPLE_ADDRESS_WIDTH / 2 : SAMPLE_ADDRESS_WIDTH % 2) :\n                                       (i == 0 ? (SAMPLE_ADDRESS_WIDTH - NON_POWER_OF_TWO) / 2 :\n                                                 (SAMPLE_ADDRESS_WIDTH - NON_POWER_OF_TWO) % 2);\n\n        if (NUM_STAGES > 0) begin\n          pack_network #(\n            .PACK (PACK),\n            .PORT_ADDRESS_WIDTH (SAMPLE_ADDRESS_WIDTH),\n            .MUX_ORDER (MUX_ORDER),\n            .MIN_STAGE (MIN_STAGE),\n            .NUM_STAGES (NUM_STAGES),\n            .PORT_DATA_WIDTH (SAMPLE_DATA_WIDTH)\n          ) i_ctrl_interconnect (\n            .clk (clk),\n            .ce_ctrl (ce_ctrl),\n\n            .rotate (rotate),\n            .prefix_count (prefix_count),\n\n            .data_in (data[i]),\n            .data_out (data[i+1])\n          );\n        end else begin\n          assign data[i+1] = data[i];\n        end\n      end\n\n      if (PACK == 1) begin: gen_pack\n        /*\n         * Mask the qualifies the samples in the out_data vector. There is on\n         * entry for each sample. If the entry is 1 that means the corresponding\n         * sample has valid data. If the entry is 0 the data is undefined.\n         */\n        reg [NUM_OF_SAMPLES-1:0] valid = 'h00;\n\n        /*\n         * Mask that qualifies the samples that overflowed in the previous\n         * cycle.\n         */\n        reg [NUM_OF_SAMPLES-2*SAMPLES_PER_CHANNEL-1:0] prev_valid = 'h00;\n\n        always @(posedge clk) begin\n          if (ce_ctrl == 1'b1) begin\n            {prev_valid,valid} <= (({NUM_OF_SAMPLES{1'b1}} >> ~enable_count) << rotate) | prev_valid;\n          end\n        end\n\n        if (NON_POWER_OF_TWO == 1) begin: gen_output_buffer\n          localparam DELAYED_DATA_WIDTH = TOTAL_DATA_WIDTH - 2 * CHANNEL_DATA_WIDTH;\n\n          /*\n           * Delayed data from the previous cycle. When the number of enabled\n           * channels is not a power of two it is possible that not all\n           * incoming data can be consumed in one cycle since there might not\n           * be enough room in the output vector anymore. In this case it needs\n           * to be delayed and will be used in the next cycle.\n           */\n          reg [DELAYED_DATA_WIDTH-1:0] data_d1 = 'h00;\n\n          /*\n           * `prev_valid` delayed by one clock cyle. This is to compensate for\n           * the control pipeline delay.\n           */\n          reg [NUM_OF_SAMPLES-2*SAMPLES_PER_CHANNEL-1:0] prev_valid_d1 = 'h00;\n\n          /*\n           * synchronization signal that indicates whether the first enabled\n           * channel is in the first output sample. This will always be true if\n           * the number of enabled channels is a power of two.\n           */\n          reg sync = 1'b1;\n\n          always @(posedge clk) begin\n            if (reset_ctrl == 1'b1) begin\n              sync <= 1'b1;\n            end else if (ready == 1'b1 && ce == 1'b1) begin\n              if (rotate == 'h0) begin\n                sync <= 1'b1;\n              end else begin\n                sync <= 1'b0;\n              end\n            end\n          end\n\n          always @(posedge clk) begin\n            if (ce_ctrl == 1'b1) begin\n              prev_valid_d1 <= prev_valid;\n            end\n          end\n\n          always @(posedge clk) begin\n            if (ce == 1'b1) begin\n              data_d1 <= data[2][DELAYED_DATA_WIDTH-1:0];\n            end\n          end\n\n          for (i = 0; i < NUM_OF_SAMPLES; i = i + 1) begin: gen_out_data\n            localparam w = SAMPLE_DATA_WIDTH;\n            localparam base = i * w;\n            if (base >= DELAYED_DATA_WIDTH) begin\n              assign out_data[base+:w] = data[2][base+:w];\n            end else begin\n              assign out_data[base+:w] = prev_valid_d1[i] == 1'b1 ? data_d1[base+:w] : data[2][base+:w];\n            end\n          end\n\n          assign out_sync = sync;\n        end else begin\n          assign out_data = data[2];\n          assign out_sync = 1'b1;\n        end\n\n        assign out_valid = valid;\n      end else begin\n        assign out_sync = 1'b1;\n        assign out_valid = {NUM_OF_SAMPLES{1'b1}};\n        assign out_data = data[2];\n      end\n    end\n  endgenerate\n\nendmodule\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[351, "          .data_out (ext_data_out)\n"], [352, "        );\n"], [368, "           .data_in (ext_data_out),\n"], [369, "           .data_out (ext_data_shuffled)\n"], [370, "        );\n"], [430, "            .data_out (data[i+1])\n"], [431, "          );\n"]], "Add": [[352, "          .data_out (ext_data_out));\n"], [370, "          .data_in (ext_data_out),\n"], [370, "          .data_out (ext_data_shuffled));\n"], [431, "            .data_out (data[i+1]));\n"]]}}