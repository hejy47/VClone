{"Source Block": ["hdl/library/axi_dmac/data_mover.v@122:188@HdlStmIf", "assign m_axi_last = last || early_tlast;\nassign m_axi_partial_burst = early_tlast;\n\nassign block_descr_to_dst = transfer_abort_s;\n\ngenerate if (ALLOW_ABORT == 1) begin\n  wire programmed_last;\n\n  reg transfer_abort = 1'b0;\n  reg req_xlast_d = 1'b0;\n  reg [1:0] transfer_id = 2'b0;\n\n  assign programmed_last = (last == 1'b1 && eot == 1'b1 && req_xlast_d == 1'b1);\n  /*\n   * A 'last' on the external interface indicates the end of an packet. If such a\n   * 'last' indicator is observed before the end of the current transfer stop\n   * accepting data on the external interface until a new descriptor is\n   * received that is the first segment of a transfer.\n   */\n  always @(posedge clk) begin\n    if (resetn == 1'b0) begin\n      transfer_abort <= 1'b0;\n    end else if (req_valid == 1'b1 && req_ready == 1'b1 && req_xlast_d == 1'b1) begin\n      transfer_abort <= 1'b0;\n    end else if (m_axi_valid == 1'b1) begin\n      if (programmed_last == 1'b1) begin\n        transfer_abort <= 1'b0;\n      end else if (s_axi_last == 1'b1) begin\n        transfer_abort <= 1'b1;\n      end\n    end\n  end\n\n  always @(posedge clk) begin\n    if (req_ready == 1'b1 && req_valid == 1'b1) begin\n      req_xlast_d <= req_xlast;\n    end\n  end\n\n  assign transfer_abort_s = transfer_abort;\n  assign early_tlast = (s_axi_ready == 1'b1) && (m_axi_valid == 1'b1) &&\n                       (s_axi_last == 1'b1) && (programmed_last == 1'b0);\n\n  assign rewind_req_valid = early_tlast;\n  assign rewind_req_data = {transfer_id,req_xlast_d,id_next};\n\n  // The width of the id must fit the number of transfers that can be in flight\n  // in the burst memory\n  always @(posedge clk) begin\n    if (resetn == 1'b0) begin\n      transfer_id <= 2'b0;\n    end else if (req_valid == 1'b1 && req_ready == 1'b1) begin\n      transfer_id <= transfer_id + 1'b1;\n    end\n  end\n\nend else begin\n  assign transfer_abort_s = 1'b0;\n  assign early_tlast = 1'b0;\n  assign rewind_req_valid = 1'b0;\n  assign rewind_req_data = 'h0;\nend endgenerate\n\n/*\n * If req_sync_transfer_start is set all incoming beats will be skipped until\n * one has s_axi_sync set. This will be the first beat that is passsed through.\n */\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[127, "generate if (ALLOW_ABORT == 1) begin\n"], [128, "  wire programmed_last;\n"], [130, "  reg transfer_abort = 1'b0;\n"], [131, "  reg req_xlast_d = 1'b0;\n"], [132, "  reg [1:0] transfer_id = 2'b0;\n"], [134, "  assign programmed_last = (last == 1'b1 && eot == 1'b1 && req_xlast_d == 1'b1);\n"], [136, "   * A 'last' on the external interface indicates the end of an packet. If such a\n"], [137, "   * 'last' indicator is observed before the end of the current transfer stop\n"], [138, "   * accepting data on the external interface until a new descriptor is\n"], [139, "   * received that is the first segment of a transfer.\n"], [142, "    if (resetn == 1'b0) begin\n"], [143, "      transfer_abort <= 1'b0;\n"], [144, "    end else if (req_valid == 1'b1 && req_ready == 1'b1 && req_xlast_d == 1'b1) begin\n"], [145, "      transfer_abort <= 1'b0;\n"], [147, "      if (programmed_last == 1'b1) begin\n"], [148, "        transfer_abort <= 1'b0;\n"], [149, "      end else if (s_axi_last == 1'b1) begin\n"], [150, "        transfer_abort <= 1'b1;\n"], [151, "      end\n"], [156, "    if (req_ready == 1'b1 && req_valid == 1'b1) begin\n"], [157, "      req_xlast_d <= req_xlast;\n"], [161, "  assign transfer_abort_s = transfer_abort;\n"], [162, "  assign early_tlast = (s_axi_ready == 1'b1) && (m_axi_valid == 1'b1) &&\n"], [163, "                       (s_axi_last == 1'b1) && (programmed_last == 1'b0);\n"], [165, "  assign rewind_req_valid = early_tlast;\n"], [166, "  assign rewind_req_data = {transfer_id,req_xlast_d,id_next};\n"], [172, "      transfer_id <= 2'b0;\n"], [174, "      transfer_id <= transfer_id + 1'b1;\n"], [178, "end else begin\n"], [179, "  assign transfer_abort_s = 1'b0;\n"], [180, "  assign early_tlast = 1'b0;\n"], [181, "  assign rewind_req_valid = 1'b0;\n"], [182, "  assign rewind_req_data = 'h0;\n"], [183, "end endgenerate\n"]], "Add": [[128, "    assign transfer_abort_s = transfer_abort;\n"], [128, "    assign early_tlast = (s_axi_ready == 1'b1) && (m_axi_valid == 1'b1) &&\n"], [128, "                         (s_axi_last == 1'b1) && (programmed_last == 1'b0);\n"], [132, "    assign rewind_req_valid = early_tlast;\n"], [132, "    assign rewind_req_data = {transfer_id,req_xlast_d,id_next};\n"], [132, "    always @(posedge clk) begin\n"], [132, "      if (resetn == 1'b0) begin\n"], [132, "        transfer_id <= 2'b0;\n"], [132, "      end else if (req_valid == 1'b1 && req_ready == 1'b1) begin\n"], [132, "        transfer_id <= transfer_id + 1'b1;\n"], [132, "      end\n"], [132, "    end\n"], [132, "  end else begin\n"], [132, "    assign transfer_abort_s = 1'b0;\n"], [132, "    assign early_tlast = 1'b0;\n"], [132, "    assign rewind_req_valid = 1'b0;\n"], [132, "    assign rewind_req_data = 'h0;\n"], [132, "  end endgenerate\n"], [139, "   * If req_sync_transfer_start is set all incoming beats will be skipped until\n"], [139, "   * one has s_axi_sync set. This will be the first beat that is passsed through.\n"], [145, "    if (req_ready == 1'b1) begin\n"], [145, "      needs_sync <= req_sync_transfer_start;\n"], [151, "      needs_sync <= 1'b0;\n"], [153, "  assign last_load = m_axi_valid && last_eot && eot;\n"], [153, "  assign req_ready = (last_load && ~early_tlast) ||\n"], [153, "                     ((~active && ~transfer_abort_s) && pending_burst) ||\n"], [153, "                     (transfer_abort_s && rewind_req_ready);\n"], [157, "    if (req_ready) begin\n"], [157, "      last_eot <= req_last_burst_length == 'h0;\n"], [157, "      last_non_eot <= 1'b0;\n"], [157, "      beat_counter <= 'h1;\n"], [157, "    end else if (m_axi_valid == 1'b1) begin\n"], [157, "      last_eot <= beat_counter == last_burst_length;\n"], [157, "      last_non_eot <= beat_counter == BEAT_COUNTER_MAX;\n"], [157, "      beat_counter <= beat_counter + 1'b1;\n"], [163, "  always @(posedge clk) begin\n"], [163, "    if (req_ready)\n"], [163, "      last_burst_length <= req_last_burst_length;\n"], [163, "  end\n"], [166, "  always @(posedge clk) begin\n"], [166, "    if (req_ready) begin\n"], [166, "      beat_counter_minus_one <= 'h0;\n"], [166, "    end else if (m_axi_valid == 1'b1) begin\n"], [166, "      beat_counter_minus_one <= beat_counter;\n"], [166, "    end\n"], [166, "  end\n"], [166, "  always @(posedge clk) begin\n"], [166, "    if (last_load || early_tlast) begin\n"], [166, "      bl_valid <= 1'b1;\n"], [166, "      measured_last_burst_length <= beat_counter_minus_one;\n"], [166, "    end else if (bl_ready) begin\n"], [166, "      bl_valid <= 1'b0;\n"], [166, "    end\n"], [166, "  end\n"], [172, "      active <= 1'b0;\n"], [174, "      active <= 1'b1;\n"], [174, "    end else if (last_load == 1'b1) begin\n"], [174, "      active <= 1'b0;\n"]]}}