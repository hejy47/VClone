{"Source Block": ["hdl/library/spi_engine/spi_engine_offload/spi_engine_offload.v@182:244@HdlStmIf", "\nassign status_sync_data = sync_data;\nassign status_sync_valid = sync_valid;\nassign sync_ready = status_sync_ready;\n\ngenerate if (ASYNC_SPI_CLK) begin\n\n/*\n * The synchronization circuit takes care that there are no glitches on the\n * ctrl_enabled signal. ctrl_do_enable is asserted whenever ctrl_enable is\n * asserted, but only deasserted once the signal has been synchronized back from\n * the SPI domain. This makes sure that we can't end up in a state where the\n * enable signal in the SPI domain is asserted, but neither enable nor enabled\n * is asserted in the control domain.\n */\n\nreg ctrl_do_enable = 1'b0;\nwire ctrl_is_enabled;\nreg spi_enabled = 1'b0;\n\nalways @(posedge ctrl_clk) begin\n  if (ctrl_enable == 1'b1) begin\n    ctrl_do_enable <= 1'b1;\n  end else if (ctrl_is_enabled == 1'b1) begin\n    ctrl_do_enable <= 1'b0;\n  end\nend\n\nassign ctrl_enabled = ctrl_is_enabled | ctrl_do_enable;\n\nalways @(posedge spi_clk) begin\n  spi_enabled <= spi_enable | spi_active;\nend\n\nsync_bits # (\n    .NUM_OF_BITS(1),\n    .ASYNC_CLK(1)\n) i_sync_enable (\n    .in_bits(ctrl_do_enable),\n    .out_clk(spi_clk),\n    .out_resetn(1'b1),\n    .out_bits(spi_enable)\n);\n\nsync_bits # (\n    .NUM_OF_BITS(1),\n    .ASYNC_CLK(1)\n) i_sync_enabled (\n    .in_bits(spi_enabled),\n    .out_clk(ctrl_clk),\n    .out_resetn(1'b1),\n    .out_bits(ctrl_is_enabled)\n);\n\nend else begin\nassign spi_enable = ctrl_enable;\nassign ctrl_enabled = spi_enable | spi_active;\nend endgenerate\n\nassign spi_cmd_rd_addr_next = spi_cmd_rd_addr + 1;\n\nwire trigger_s;\nsync_bits #(\n"], "Clone Blocks": [["hdl/library/axi_ad5766/axi_ad5766.v@161:234", "  assign sdo_data = sdo_mem[spi_sdo_rd_addr];\n  assign sync_ready = 1'b1;\n\n  assign sdi_data_ready = 1'b0;\n\n  generate if (ASYNC_SPI_CLK) begin\n\n    /*\n     * The synchronization circuit takes care that there are no glitches on the\n     * ctrl_enabled signal. ctrl_do_enable is asserted whenever ctrl_enable is\n     * asserted, but only deasserted once the signal has been synchronized back from\n     * the SPI domain. This makes sure that we can't end up in a state where the\n     * enable signal in the SPI domain is asserted, but neither enable nor enabled\n     * is asserted in the control domain.\n     */\n\n    reg ctrl_do_enable = 1'b0;\n    wire ctrl_is_enabled;\n    reg spi_enabled = 1'b0;\n\n    always @(posedge ctrl_clk) begin\n        if (ctrl_enable == 1'b1) begin\n                ctrl_do_enable <= 1'b1;\n        end else if (ctrl_is_enabled == 1'b1) begin\n                ctrl_do_enable <= 1'b0;\n        end\n    end\n\n    assign ctrl_enabled = ctrl_is_enabled | ctrl_do_enable;\n\n    always @(posedge spi_clk) begin\n        spi_enabled <= spi_enable_s | spi_active;\n    end\n\n    sync_bits # (\n        .NUM_OF_BITS(1),\n        .ASYNC_CLK(1)\n    ) i_sync_enable (\n        .in_bits(ctrl_do_enable),\n        .out_clk(spi_clk),\n        .out_resetn(1'b1),\n        .out_bits(spi_enable_s)\n    );\n\n    sync_bits # (\n        .NUM_OF_BITS(1),\n        .ASYNC_CLK(1)\n    ) i_sync_enabled (\n        .in_bits(spi_enabled),\n        .out_clk(ctrl_clk),\n        .out_resetn(1'b1),\n        .out_bits(ctrl_is_enabled)\n    );\n\n    sync_bits # (\n        .NUM_OF_BITS(1),\n        .ASYNC_CLK(1)\n    ) i_sync_mem_reset (\n        .in_bits(ctrl_mem_reset),\n        .out_clk(spi_clk),\n        .out_resetn(1'b1),\n        .out_bits(spi_mem_reset_s)\n    );\n\n  end else begin\n    assign spi_enable_s = ctrl_enable;\n    assign ctrl_enabled = spi_enable_s | spi_active;\n    assign spi_mem_reset_s = ctrl_mem_reset;\n  end endgenerate\n\n  assign spi_cmd_rd_addr_next = spi_cmd_rd_addr + 1;\n\n  always @(posedge spi_clk) begin\n    if (spi_resetn == 1'b0) begin\n"]], "Diff Content": {"Delete": [[187, "generate if (ASYNC_SPI_CLK) begin\n"], [189, "/*\n"], [190, " * The synchronization circuit takes care that there are no glitches on the\n"], [191, " * ctrl_enabled signal. ctrl_do_enable is asserted whenever ctrl_enable is\n"], [192, " * asserted, but only deasserted once the signal has been synchronized back from\n"], [193, " * the SPI domain. This makes sure that we can't end up in a state where the\n"], [194, " * enable signal in the SPI domain is asserted, but neither enable nor enabled\n"], [195, " * is asserted in the control domain.\n"], [196, " */\n"], [198, "reg ctrl_do_enable = 1'b0;\n"], [199, "wire ctrl_is_enabled;\n"], [200, "reg spi_enabled = 1'b0;\n"], [202, "always @(posedge ctrl_clk) begin\n"], [203, "  if (ctrl_enable == 1'b1) begin\n"], [204, "    ctrl_do_enable <= 1'b1;\n"], [205, "  end else if (ctrl_is_enabled == 1'b1) begin\n"], [206, "    ctrl_do_enable <= 1'b0;\n"], [208, "end\n"], [210, "assign ctrl_enabled = ctrl_is_enabled | ctrl_do_enable;\n"], [212, "always @(posedge spi_clk) begin\n"], [213, "  spi_enabled <= spi_enable | spi_active;\n"], [214, "end\n"], [216, "sync_bits # (\n"], [219, ") i_sync_enable (\n"], [223, "    .out_bits(spi_enable)\n"], [224, ");\n"], [226, "sync_bits # (\n"], [229, ") i_sync_enabled (\n"], [233, "    .out_bits(ctrl_is_enabled)\n"], [234, ");\n"], [236, "end else begin\n"], [237, "assign spi_enable = ctrl_enable;\n"], [238, "assign ctrl_enabled = spi_enable | spi_active;\n"], [239, "end endgenerate\n"]], "Add": [[206, "  assign cmd = (cmd_int_s[15:8] == 8'h30) ? {cmd_int_s[15:8], spi_sync_id_counter} : cmd_int_s;\n"], [206, "  /*\n"], [206, "   * Forwarded SYNC interface, this can be used to monitor the state of the\n"], [206, "   * offload command sequence through SPI Engine regmap\n"], [206, "   */\n"], [206, "  assign status_sync_data = sync_data;\n"], [206, "  assign status_sync_valid = sync_valid;\n"], [206, "  assign sync_ready = status_sync_ready;\n"], [206, "  generate if (ASYNC_SPI_CLK) begin\n"], [206, "  /*\n"], [206, "   * The synchronization circuit takes care that there are no glitches on the\n"], [206, "   * ctrl_enabled signal. ctrl_do_enable is asserted whenever ctrl_enable is\n"], [206, "   * asserted, but only deasserted once the signal has been synchronized back from\n"], [206, "   * the SPI domain. This makes sure that we can't end up in a state where the\n"], [206, "   * enable signal in the SPI domain is asserted, but neither enable nor enabled\n"], [206, "   * is asserted in the control domain.\n"], [206, "   */\n"], [206, "  reg ctrl_do_enable = 1'b0;\n"], [206, "  wire ctrl_is_enabled;\n"], [206, "  reg spi_enabled = 1'b0;\n"], [206, "  always @(posedge ctrl_clk) begin\n"], [206, "    if (ctrl_enable == 1'b1) begin\n"], [206, "      ctrl_do_enable <= 1'b1;\n"], [206, "    end else if (ctrl_is_enabled == 1'b1) begin\n"], [206, "      ctrl_do_enable <= 1'b0;\n"], [206, "    end\n"], [210, "  assign ctrl_enabled = ctrl_is_enabled | ctrl_do_enable;\n"], [214, "  always @(posedge spi_clk) begin\n"], [214, "    spi_enabled <= spi_enable | spi_active;\n"], [214, "  end\n"], [216, "  sync_bits #(\n"], [219, "  ) i_sync_enable (\n"], [224, "    .out_bits(spi_enable));\n"], [226, "  sync_bits #(\n"], [229, "  ) i_sync_enabled (\n"], [234, "    .out_bits(ctrl_is_enabled));\n"]]}}