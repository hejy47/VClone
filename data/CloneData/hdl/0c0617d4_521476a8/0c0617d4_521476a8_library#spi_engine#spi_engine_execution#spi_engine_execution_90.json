{"Source Block": ["hdl/library/spi_engine/spi_engine_execution/spi_engine_execution.v@390:400@HdlStmAssign", "\nalways @(posedge clk) begin\n  trigger_rx_d <= {trigger_rx_d, trigger_rx};\nend\n\nassign trigger_rx_s = trigger_rx_d[SDI_DELAY+1];\n\n// Load the serial data into SDI shift register(s), then link it to the output\n// register of the module\n// NOTE: ECHO_SCLK mode can be used when the SCLK line is looped back to the FPGA\n// through an other level shifter, in order to remove the round-trip timing delays\n"], "Clone Blocks": [["hdl/library/spi_engine/spi_engine_execution/spi_engine_execution.v@386:398", "// the SDI line can be delayed with 1, 2 or 3 SPI core clock cycle.\n// Taking the fact that in high SCLK frequencies the pre-scaler most likely will\n// be set to 0, to reduce the core clock's speed, this delay will mean that SDI will\n// be latched at one of the next consecutive SCLK edge.\n\nalways @(posedge clk) begin\n  trigger_rx_d <= {trigger_rx_d, trigger_rx};\nend\n\nassign trigger_rx_s = trigger_rx_d[SDI_DELAY+1];\n\n// Load the serial data into SDI shift register(s), then link it to the output\n// register of the module\n"]], "Diff Content": {"Delete": [[395, "assign trigger_rx_s = trigger_rx_d[SDI_DELAY+1];\n"]], "Add": [[395, "  always @(posedge clk) begin\n"], [395, "    if ((inst_d1 == CMD_TRANSFER) && (!sdo_enabled)) begin\n"], [395, "      data_sdo_shift <= {DATA_WIDTH{SDO_DEFAULT}};\n"], [395, "    end else if (transfer_active == 1'b1 && trigger_tx == 1'b1) begin\n"], [395, "      if (first_bit == 1'b1)\n"], [395, "        data_sdo_shift <= sdo_data << left_aligned;\n"], [395, "      else\n"], [395, "        data_sdo_shift <= {data_sdo_shift[(DATA_WIDTH-2):0], 1'b0};\n"], [395, "    end\n"], [395, "  end\n"], [395, "  assign sdo_int_s = data_sdo_shift[DATA_WIDTH-1];\n"]]}}