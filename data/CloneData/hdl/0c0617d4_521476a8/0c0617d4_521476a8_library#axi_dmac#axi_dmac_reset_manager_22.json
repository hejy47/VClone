{"Source Block": ["hdl/library/axi_dmac/axi_dmac_reset_manager.v@147:201@HdlStmProcess", "  end else if (ctrl_enable == 1'b0) begin\n    needs_reset <= 1'b1;\n  end\nend\n\nalways @(posedge clk) begin\n  if (resetn == 1'b0) begin\n    state <= STATE_DO_RESET;\n  end else begin\n    case (state)\n    STATE_DO_RESET: begin\n      state <= STATE_RESET;\n    end\n    STATE_RESET: begin\n      /*\n       * Wait for the reset sequence to complete. Stay in this state when\n       * ctrl_enable == 1'b0, otherwise we'd go through the reset sequence\n       * again and again.\n       */\n      if (ctrl_enable == 1'b1 && req_resetn == 1'b1) begin\n        state <= STATE_DISABLED;\n      end\n    end\n    STATE_DISABLED: begin\n      if (needs_reset == 1'b1) begin\n        state <= STATE_DO_RESET;\n      end else if (ctrl_pause == 1'b0) begin\n        state <= STATE_STARTUP;\n      end\n    end\n    STATE_STARTUP: begin\n      /* Wait for all domains to be ready */\n      if (enabled_all == 1'b1) begin\n        state <= STATE_ENABLED;\n      end\n    end\n    STATE_ENABLED: begin\n      if (needs_reset == 1'b1 || ctrl_pause == 1'b1) begin\n        state <= STATE_SHUTDOWN;\n      end\n    end\n    STATE_SHUTDOWN: begin\n      /* Wait for all domains to complete outstanding transactions */\n      if (disabled_all == 1'b1) begin\n        state <= STATE_DISABLED;\n      end\n    end\n    endcase\n  end\nend\n\n/*\n * Chain the reset through all clock domains. This makes sure that is asserted\n * for at least 4 clock cycles of the slowest domain, no matter what. If\n * successive domains have the same clock they'll share their reset signal.\n"], "Clone Blocks": [], "Diff Content": {"Delete": [[152, "always @(posedge clk) begin\n"], [153, "  if (resetn == 1'b0) begin\n"], [154, "    state <= STATE_DO_RESET;\n"], [155, "  end else begin\n"], [156, "    case (state)\n"], [157, "    STATE_DO_RESET: begin\n"], [158, "      state <= STATE_RESET;\n"], [160, "    STATE_RESET: begin\n"], [161, "      /*\n"], [162, "       * Wait for the reset sequence to complete. Stay in this state when\n"], [163, "       * ctrl_enable == 1'b0, otherwise we'd go through the reset sequence\n"], [164, "       * again and again.\n"], [165, "       */\n"], [166, "      if (ctrl_enable == 1'b1 && req_resetn == 1'b1) begin\n"], [167, "        state <= STATE_DISABLED;\n"], [169, "    end\n"], [170, "    STATE_DISABLED: begin\n"], [171, "      if (needs_reset == 1'b1) begin\n"], [172, "        state <= STATE_DO_RESET;\n"], [173, "      end else if (ctrl_pause == 1'b0) begin\n"], [174, "        state <= STATE_STARTUP;\n"], [176, "    end\n"], [177, "    STATE_STARTUP: begin\n"], [178, "      /* Wait for all domains to be ready */\n"], [179, "      if (enabled_all == 1'b1) begin\n"], [180, "        state <= STATE_ENABLED;\n"], [182, "    end\n"], [183, "    STATE_ENABLED: begin\n"], [184, "      if (needs_reset == 1'b1 || ctrl_pause == 1'b1) begin\n"], [185, "        state <= STATE_SHUTDOWN;\n"], [187, "    end\n"], [188, "    STATE_SHUTDOWN: begin\n"], [189, "      /* Wait for all domains to complete outstanding transactions */\n"], [190, "      if (disabled_all == 1'b1) begin\n"], [191, "        state <= STATE_DISABLED;\n"], [194, "    endcase\n"], [196, "end\n"]], "Add": [[158, "  /*\n"], [158, "   * If ctrl_enable goes from 1 to 0 a shutdown procedure is initiated. During the\n"], [158, "   * shutdown procedure all domains are signaled that a shutdown should occur. The\n"], [158, "   * domains will then complete any active transactions that are required to\n"], [158, "   * complete according to the interface semantics. Once a domain has completed\n"], [158, "   * its transactions it will indicate that it has been shutdown. Once all domains\n"], [158, "   * indicate that they have been disabled a reset pulse will be generated to all\n"], [158, "   * domains to clear all residual state. The reset pulse is long enough so that it\n"], [158, "   * is active in all domains for at least 4 clock cycles.\n"], [158, "   *\n"], [158, "   * Once the reset signal is de-asserted the DMA is in an idle state and can be\n"], [158, "   * enabled again. If the DMA receives a enable while it is performing a shutdown\n"], [158, "   * sequence it will only be re-enabled once the shutdown sequence has\n"], [158, "   * successfully completed.\n"], [158, "   *\n"], [158, "   * If ctrl_pause is asserted all domains will be disabled. But there will be no\n"], [158, "   * reset, so when the ctrl_pause signal is de-asserted again the DMA will resume\n"], [158, "   * with its previous state.\n"], [158, "   *\n"], [158, "   */\n"], [158, "  /*\n"], [158, "   * If ctrl_enable goes low, even for a single clock cycle, we want to go through\n"], [158, "   * a full reset sequence. This might happen when the state machine is busy, e.g.\n"], [158, "   * going through a startup sequence. To avoid missing the event store it for\n"], [158, "   * later.\n"], [158, "   */\n"], [158, "  always @(posedge clk) begin\n"], [158, "    if (state == STATE_RESET) begin\n"], [158, "      needs_reset <= 1'b0;\n"], [158, "    end else if (ctrl_enable == 1'b0) begin\n"], [158, "      needs_reset <= 1'b1;\n"], [167, "  end\n"], [167, "  always @(posedge clk) begin\n"], [167, "    if (resetn == 1'b0) begin\n"], [167, "      state <= STATE_DO_RESET;\n"], [167, "    end else begin\n"], [167, "      case (state)\n"], [167, "      STATE_DO_RESET: begin\n"], [167, "        state <= STATE_RESET;\n"], [174, "      STATE_RESET: begin\n"], [174, "        /*\n"], [174, "         * Wait for the reset sequence to complete. Stay in this state when\n"], [174, "         * ctrl_enable == 1'b0, otherwise we'd go through the reset sequence\n"], [174, "         * again and again.\n"], [174, "         */\n"], [174, "        if (ctrl_enable == 1'b1 && req_resetn == 1'b1) begin\n"], [174, "          state <= STATE_DISABLED;\n"], [174, "        end\n"], [180, "      STATE_DISABLED: begin\n"], [180, "        if (needs_reset == 1'b1) begin\n"], [180, "          state <= STATE_DO_RESET;\n"], [180, "        end else if (ctrl_pause == 1'b0) begin\n"], [180, "          state <= STATE_STARTUP;\n"], [180, "        end\n"], [185, "      STATE_STARTUP: begin\n"], [185, "        /* Wait for all domains to be ready */\n"], [185, "        if (enabled_all == 1'b1) begin\n"], [185, "          state <= STATE_ENABLED;\n"], [185, "        end\n"], [191, "      STATE_ENABLED: begin\n"], [191, "        if (needs_reset == 1'b1 || ctrl_pause == 1'b1) begin\n"], [191, "          state <= STATE_SHUTDOWN;\n"], [191, "        end\n"], [191, "      end\n"], [191, "      STATE_SHUTDOWN: begin\n"], [191, "        /* Wait for all domains to complete outstanding transactions */\n"], [191, "        if (disabled_all == 1'b1) begin\n"], [191, "          state <= STATE_DISABLED;\n"], [191, "        end\n"], [192, "      endcase\n"]]}}