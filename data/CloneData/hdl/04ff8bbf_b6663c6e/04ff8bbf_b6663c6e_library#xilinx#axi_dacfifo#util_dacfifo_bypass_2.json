{"Source Block": ["hdl/library/xilinx/axi_dacfifo/util_dacfifo_bypass.v@179:207@HdlStmProcess", "    end\n  end\n\n  // The memory module request data until reaches the high threshold.\n\n  always @(posedge dma_clk) begin\n    if (dma_rst == 1'b1) begin\n      dma_mem_addr_diff <= 'b0;\n      dma_mem_raddr_m1 <= 'b0;\n      dma_mem_raddr_m2 <= 'b0;\n      dma_mem_raddr <= 'b0;\n      dma_ready_out <= 1'b0;\n    end else begin\n      dma_mem_raddr_m1 <= dac_mem_raddr_g;\n      dma_mem_raddr_m2 <= dma_mem_raddr_m1;\n      dma_mem_raddr <= g2b(dma_mem_raddr_m2);\n      dma_mem_addr_diff <= dma_address_diff_s[DMA_ADDRESS_WIDTH-1:0];\n      if (dma_mem_addr_diff >= DMA_BUF_THRESHOLD_HI) begin\n        dma_ready_out <= 1'b0;\n      end else begin\n        dma_ready_out <= 1'b1;\n      end\n    end\n  end\n\n  // relative address offset on dma domain\n  assign dma_address_diff_s = {1'b1, dma_mem_waddr} - dma_mem_raddr_s;\n  assign dma_mem_raddr_s = (DMA_DATA_WIDTH>DAC_DATA_WIDTH) ?\n                                ((MEM_RATIO == 1) ? (dma_mem_raddr) :\n"], "Clone Blocks": [["hdl/library/xilinx/axi_dacfifo/axi_dacfifo_wr.v@258:286", "    .din (dma_mem_waddr),\n    .dout (dma_mem_waddr_b2g_s));\n\n  // The memory module request data until reaches the high threshold\n\n  always @(posedge dma_clk) begin\n    if (dma_fifo_reset_s == 1'b1) begin\n      dma_mem_addr_diff <= 'b0;\n      dma_mem_raddr_m1 <= 'b0;\n      dma_mem_raddr_m2 <= 'b0;\n      dma_mem_raddr <= 'b0;\n      dma_ready_out <= 1'b1;\n    end else begin\n      dma_mem_raddr_m1 <= axi_mem_raddr_g;\n      dma_mem_raddr_m2 <= dma_mem_raddr_m1;\n      dma_mem_raddr <= dma_mem_raddr_m2_g2b_s;\n      dma_mem_addr_diff <= dma_mem_addr_diff_s[DMA_MEM_ADDRESS_WIDTH-1:0];\n      if (dma_mem_addr_diff >= DMA_BUF_THRESHOLD_HI) begin\n        dma_ready_out <= 1'b0;\n      end else begin\n        dma_ready_out <= 1'b1;\n      end\n    end\n  end\n\n  ad_g2b # (\n    .DATA_WIDTH(AXI_MEM_ADDRESS_WIDTH)\n  ) i_dma_mem_raddr_g2b (\n    .din (dma_mem_raddr_m2),\n"], ["hdl/library/altera/avl_dacfifo/util_dacfifo_bypass.v@174:202", "    end\n  end\n\n  // The memory module request data until reaches the high threshold.\n\n  always @(posedge dma_clk) begin\n    if (dma_rst == 1'b1) begin\n      dma_mem_addr_diff <= 'b0;\n      dma_mem_raddr_m1 <= 'b0;\n      dma_mem_raddr_m2 <= 'b0;\n      dma_mem_raddr <= 'b0;\n      dma_ready_out <= 1'b0;\n    end else begin\n      dma_mem_raddr_m1 <= dac_mem_raddr_g;\n      dma_mem_raddr_m2 <= dma_mem_raddr_m1;\n      dma_mem_raddr <= g2b(dma_mem_raddr_m2);\n      dma_mem_addr_diff <= dma_address_diff_s[DMA_ADDRESS_WIDTH-1:0];\n      if (dma_mem_addr_diff >= DMA_BUF_THRESHOLD_HI) begin\n        dma_ready_out <= 1'b0;\n      end else begin\n        dma_ready_out <= 1'b1;\n      end\n    end\n  end\n\n  // relative address offset on dma domain\n  assign dma_address_diff_s = {1'b1, dma_mem_waddr} - dma_mem_raddr_s;\n  assign dma_mem_raddr_s = (DMA_DATA_WIDTH>DAC_DATA_WIDTH) ?\n                                ((MEM_RATIO == 1) ? (dma_mem_raddr) :\n"]], "Diff Content": {"Delete": [[194, "      dma_mem_raddr <= g2b(dma_mem_raddr_m2);\n"]], "Add": [[194, "      dma_mem_raddr <= dma_mem_raddr_m2_g2b_s;\n"], [202, "  ad_g2b #(\n"], [202, "    .DATA_WIDTH (DAC_ADDRESS_WIDTH))\n"], [202, "  i_dma_mem_raddr_g2b (\n"], [202, "    .din (dma_mem_raddr_m2),\n"], [202, "    .dout (dma_mem_raddr_m2_g2b_s));\n"]]}}